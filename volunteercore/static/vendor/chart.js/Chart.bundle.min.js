/*!
 * Chart.js v2.9.4
 * https://www.chartjs.org
 * (c) 2020 Chart.js Contributors
 * Released under the MIT License
 */
!(function (t, e) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = e())
    : typeof define === 'function' && define.amd
      ? define(e)
      : ((t = t || self).Chart = e())
})(this, function () {
  'use strict'
  typeof globalThis !== 'undefined'
    ? globalThis
    : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
        ? global
        : typeof self !== 'undefined' && self
  function t () {
    throw new Error(
      'Dynamic requires are not currently supported by rollup-plugin-commonjs'
    )
  }
  function e (t, e) {
    return t((e = { exports: {} }), e.exports), e.exports
  }
  const n = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }
  let i = e(function (t) {
    const e = {}
    for (const i in n) n.hasOwnProperty(i) && (e[n[i]] = i)
    const a = (t.exports = {
      rgb: { channels: 3, labels: 'rgb' },
      hsl: { channels: 3, labels: 'hsl' },
      hsv: { channels: 3, labels: 'hsv' },
      hwb: { channels: 3, labels: 'hwb' },
      cmyk: { channels: 4, labels: 'cmyk' },
      xyz: { channels: 3, labels: 'xyz' },
      lab: { channels: 3, labels: 'lab' },
      lch: { channels: 3, labels: 'lch' },
      hex: { channels: 1, labels: ['hex'] },
      keyword: { channels: 1, labels: ['keyword'] },
      ansi16: { channels: 1, labels: ['ansi16'] },
      ansi256: { channels: 1, labels: ['ansi256'] },
      hcg: { channels: 3, labels: ['h', 'c', 'g'] },
      apple: { channels: 3, labels: ['r16', 'g16', 'b16'] },
      gray: { channels: 1, labels: ['gray'] }
    })
    for (const r in a) {
      if (a.hasOwnProperty(r)) {
        if (!('channels' in a[r])) { throw new Error('missing channels property: ' + r) }
        if (!('labels' in a[r])) { throw new Error('missing channel labels property: ' + r) }
        if (a[r].labels.length !== a[r].channels) { throw new Error('channel and label counts mismatch: ' + r) }
        var o = a[r].channels
        var s = a[r].labels
        delete a[r].channels,
        delete a[r].labels,
        Object.defineProperty(a[r], 'channels', { value: o }),
        Object.defineProperty(a[r], 'labels', { value: s })
      } 
}
    (a.rgb.hsl = function (t) {
      let e
      let n
      let i = t[0] / 255
      let a = t[1] / 255
      let r = t[2] / 255
      let o = Math.min(i, a, r)
      let s = Math.max(i, a, r)
      let l = s - o
      return (
        s === o
          ? (e = 0)
          : i === s
            ? (e = (a - r) / l)
            : a === s
              ? (e = 2 + (r - i) / l)
              : r === s && (e = 4 + (i - a) / l),
        (e = Math.min(60 * e, 360)) < 0 && (e += 360),
        (n = (o + s) / 2),
        [
          e,
          100 * (s === o ? 0 : n <= 0.5 ? l / (s + o) : l / (2 - s - o)),
          100 * n
        ]
      )
    }),
    (a.rgb.hsv = function (t) {
      let e
      let n
      let i
      let a
      let r
      let o = t[0] / 255
      let s = t[1] / 255
      let l = t[2] / 255
      let u = Math.max(o, s, l)
      let d = u - Math.min(o, s, l)
      let h = function (t) {
        return (u - t) / 6 / d + 0.5
      }
      return (
        d === 0
          ? (a = r = 0)
          : ((r = d / u),
            (e = h(o)),
            (n = h(s)),
            (i = h(l)),
            o === u
              ? (a = i - n)
              : s === u
                ? (a = 1 / 3 + e - i)
                : l === u && (a = 2 / 3 + n - e),
            a < 0 ? (a += 1) : a > 1 && (a -= 1)),
        [360 * a, 100 * r, 100 * u]
      )
    }),
    (a.rgb.hwb = function (t) {
      const e = t[0]
      let n = t[1]
      let i = t[2]
      return [
        a.rgb.hsl(t)[0],
        100 * ((1 / 255) * Math.min(e, Math.min(n, i))),
        100 * (i = 1 - (1 / 255) * Math.max(e, Math.max(n, i)))
      ]
    }),
    (a.rgb.cmyk = function (t) {
      let e
      let n = t[0] / 255
      let i = t[1] / 255
      let a = t[2] / 255
      return [
        100 *
              ((1 - n - (e = Math.min(1 - n, 1 - i, 1 - a))) / (1 - e) || 0),
        100 * ((1 - i - e) / (1 - e) || 0),
        100 * ((1 - a - e) / (1 - e) || 0),
        100 * e
      ]
    }),
    (a.rgb.keyword = function (t) {
      const i = e[t]
      if (i) return i
      let a
      let r
      let o
      let s = 1 / 0
      for (const l in n) { if (n.hasOwnProperty(l)) {
        var u = n[l]
        var d =
                  ((r = t),
                  (o = u),
                  Math.pow(r[0] - o[0], 2) +
                    Math.pow(r[1] - o[1], 2) +
                    Math.pow(r[2] - o[2], 2))
        d < s && ((s = d), (a = l))
      } }
      return a
    }),
    (a.keyword.rgb = function (t) {
      return n[t]
    }),
    (a.rgb.xyz = function (t) {
      let e = t[0] / 255
      let n = t[1] / 255
      let i = t[2] / 255
      return [
        100 *
              (0.4124 *
                (e =
                  e > 0.04045
                    ? Math.pow((e + 0.055) / 1.055, 2.4)
                    : e / 12.92) +
                0.3576 *
                  (n =
                    n > 0.04045
                      ? Math.pow((n + 0.055) / 1.055, 2.4)
                      : n / 12.92) +
                0.1805 *
                  (i =
                    i > 0.04045
                      ? Math.pow((i + 0.055) / 1.055, 2.4)
                      : i / 12.92)),
        100 * (0.2126 * e + 0.7152 * n + 0.0722 * i),
        100 * (0.0193 * e + 0.1192 * n + 0.9505 * i)
      ]
    }),
    (a.rgb.lab = function (t) {
      const e = a.rgb.xyz(t)
      let n = e[0]
      let i = e[1]
      let r = e[2]
      return (
        (i /= 100),
        (r /= 108.883),
        (n =
              (n /= 95.047) > 0.008856
                ? Math.pow(n, 1 / 3)
                : 7.787 * n + 16 / 116),
        [
          116 *
                (i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116) -
                16,
          500 * (n - i),
          200 *
                (i -
                  (r =
                    r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))
        ]
      )
    }),
    (a.hsl.rgb = function (t) {
      let e
      let n
      let i
      let a
      let r
      let o = t[0] / 360
      let s = t[1] / 100
      let l = t[2] / 100
      if (s === 0) return [(r = 255 * l), r, r];
      (e = 2 * l - (n = l < 0.5 ? l * (1 + s) : l + s - l * s)),
      (a = [0, 0, 0])
      for (let u = 0; u < 3; u++) { (i = o + (1 / 3) * -(u - 1)) < 0 && i++,
      i > 1 && i--,
      (r =
                6 * i < 1
                  ? e + 6 * (n - e) * i
                  : 2 * i < 1
                    ? n
                    : 3 * i < 2
                      ? e + (n - e) * (2 / 3 - i) * 6
                      : e),
      (a[u] = 255 * r) }
      return a
    }),
    (a.hsl.hsv = function (t) {
      const e = t[0]
      let n = t[1] / 100
      let i = t[2] / 100
      let a = n
      let r = Math.max(i, 0.01)
      return (
        (n *= (i *= 2) <= 1 ? i : 2 - i),
        (a *= r <= 1 ? r : 2 - r),
        [
          e,
          100 * (i === 0 ? (2 * a) / (r + a) : (2 * n) / (i + n)),
          100 * ((i + n) / 2)
        ]
      )
    }),
    (a.hsv.rgb = function (t) {
      const e = t[0] / 60
      let n = t[1] / 100
      let i = t[2] / 100
      let a = Math.floor(e) % 6
      let r = e - Math.floor(e)
      let o = 255 * i * (1 - n)
      let s = 255 * i * (1 - n * r)
      let l = 255 * i * (1 - n * (1 - r))
      switch (((i *= 255), a)) {
        case 0:
          return [i, l, o]
        case 1:
          return [s, i, o]
        case 2:
          return [o, i, l]
        case 3:
          return [o, s, i]
        case 4:
          return [l, o, i]
        case 5:
          return [i, o, s]
      }
    }),
    (a.hsv.hsl = function (t) {
      let e
      let n
      let i
      let a = t[0]
      let r = t[1] / 100
      let o = t[2] / 100
      let s = Math.max(o, 0.01)
      return (
        (i = (2 - r) * o),
        (n = r * s),
        [
          a,
          100 * (n = (n /= (e = (2 - r) * s) <= 1 ? e : 2 - e) || 0),
          100 * (i /= 2)
        ]
      )
    }),
    (a.hwb.rgb = function (t) {
      let e
      let n
      let i
      let a
      let r
      let o
      let s
      let l = t[0] / 360
      let u = t[1] / 100
      let d = t[2] / 100
      let h = u + d
      switch (
        (h > 1 && ((u /= h), (d /= h)),
        (i = 6 * l - (e = Math.floor(6 * l))),
        (1 & e) != 0 && (i = 1 - i),
        (a = u + i * ((n = 1 - d) - u)),
        e)
      ) {
        default:
        case 6:
        case 0:
          (r = n), (o = a), (s = u)
          break
        case 1:
          (r = a), (o = n), (s = u)
          break
        case 2:
          (r = u), (o = n), (s = a)
          break
        case 3:
          (r = u), (o = a), (s = n)
          break
        case 4:
          (r = a), (o = u), (s = n)
          break
        case 5:
          (r = n), (o = u), (s = a)
      }
      return [255 * r, 255 * o, 255 * s]
    }),
    (a.cmyk.rgb = function (t) {
      const e = t[0] / 100
      let n = t[1] / 100
      let i = t[2] / 100
      let a = t[3] / 100
      return [
        255 * (1 - Math.min(1, e * (1 - a) + a)),
        255 * (1 - Math.min(1, n * (1 - a) + a)),
        255 * (1 - Math.min(1, i * (1 - a) + a))
      ]
    }),
    (a.xyz.rgb = function (t) {
      let e
      let n
      let i
      let a = t[0] / 100
      let r = t[1] / 100
      let o = t[2] / 100
      return (
        (n = -0.9689 * a + 1.8758 * r + 0.0415 * o),
        (i = 0.0557 * a + -0.204 * r + 1.057 * o),
        (e =
              (e = 3.2406 * a + -1.5372 * r + -0.4986 * o) > 0.0031308
                ? 1.055 * Math.pow(e, 1 / 2.4) - 0.055
                : 12.92 * e),
        (n =
              n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n),
        (i =
              i > 0.0031308 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : 12.92 * i),
        [
          255 * (e = Math.min(Math.max(0, e), 1)),
          255 * (n = Math.min(Math.max(0, n), 1)),
          255 * (i = Math.min(Math.max(0, i), 1))
        ]
      )
    }),
    (a.xyz.lab = function (t) {
      let e = t[0]
      let n = t[1]
      let i = t[2]
      return (
        (n /= 100),
        (i /= 108.883),
        (e =
              (e /= 95.047) > 0.008856
                ? Math.pow(e, 1 / 3)
                : 7.787 * e + 16 / 116),
        [
          116 *
                (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) -
                16,
          500 * (e - n),
          200 *
                (n -
                  (i =
                    i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116))
        ]
      )
    }),
    (a.lab.xyz = function (t) {
      let e
      let n
      let i
      let a = t[0];
      (e = t[1] / 500 + (n = (a + 16) / 116)), (i = n - t[2] / 200)
      const r = Math.pow(n, 3)
      let o = Math.pow(e, 3)
      let s = Math.pow(i, 3)
      return (
        (n = r > 0.008856 ? r : (n - 16 / 116) / 7.787),
        (e = o > 0.008856 ? o : (e - 16 / 116) / 7.787),
        (i = s > 0.008856 ? s : (i - 16 / 116) / 7.787),
        [(e *= 95.047), (n *= 100), (i *= 108.883)]
      )
    }),
    (a.lab.lch = function (t) {
      let e
      let n = t[0]
      let i = t[1]
      let a = t[2]
      return (
        (e = (360 * Math.atan2(a, i)) / 2 / Math.PI) < 0 && (e += 360),
        [n, Math.sqrt(i * i + a * a), e]
      )
    }),
    (a.lch.lab = function (t) {
      let e
      let n = t[0]
      let i = t[1]
      return (
        (e = (t[2] / 360) * 2 * Math.PI),
        [n, i * Math.cos(e), i * Math.sin(e)]
      )
    }),
    (a.rgb.ansi16 = function (t) {
      const e = t[0]
      let n = t[1]
      let i = t[2]
      let r = 1 in arguments ? arguments[1] : a.rgb.hsv(t)[2]
      if ((r = Math.round(r / 50)) === 0) return 30
      let o =
            30 +
            ((Math.round(i / 255) << 2) |
              (Math.round(n / 255) << 1) |
              Math.round(e / 255))
      return r === 2 && (o += 60), o
    }),
    (a.hsv.ansi16 = function (t) {
      return a.rgb.ansi16(a.hsv.rgb(t), t[2])
    }),
    (a.rgb.ansi256 = function (t) {
      const e = t[0]
      let n = t[1]
      let i = t[2]
      return e === n && n === i
        ? e < 8
          ? 16
          : e > 248
            ? 231
            : Math.round(((e - 8) / 247) * 24) + 232
        : 16 +
                36 * Math.round((e / 255) * 5) +
                6 * Math.round((n / 255) * 5) +
                Math.round((i / 255) * 5)
    }),
    (a.ansi16.rgb = function (t) {
      let e = t % 10
      if (e === 0 || e === 7) { return t > 50 && (e += 3.5), [(e = (e / 10.5) * 255), e, e] }
      const n = 0.5 * (1 + ~~(t > 50))
      return [
        (1 & e) * n * 255,
        ((e >> 1) & 1) * n * 255,
        ((e >> 2) & 1) * n * 255
      ]
    }),
    (a.ansi256.rgb = function (t) {
      if (t >= 232) {
        const e = 10 * (t - 232) + 8
        return [e, e, e]
      }
      let n
      return (
        (t -= 16),
        [
          (Math.floor(t / 36) / 5) * 255,
          (Math.floor((n = t % 36) / 6) / 5) * 255,
          ((n % 6) / 5) * 255
        ]
      )
    }),
    (a.rgb.hex = function (t) {
      const e = (
        ((255 & Math.round(t[0])) << 16) +
            ((255 & Math.round(t[1])) << 8) +
            (255 & Math.round(t[2]))
      )
        .toString(16)
        .toUpperCase()
      return '000000'.substring(e.length) + e
    }),
    (a.hex.rgb = function (t) {
      const e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i)
      if (!e) return [0, 0, 0]
      let n = e[0]
      e[0].length === 3 &&
            (n = n
              .split('')
              .map(function (t) {
                return t + t
              })
              .join(''))
      const i = parseInt(n, 16)
      return [(i >> 16) & 255, (i >> 8) & 255, 255 & i]
    }),
    (a.rgb.hcg = function (t) {
      let e
      let n = t[0] / 255
      let i = t[1] / 255
      let a = t[2] / 255
      let r = Math.max(Math.max(n, i), a)
      let o = Math.min(Math.min(n, i), a)
      let s = r - o
      return (
        (e =
              s <= 0
                ? 0
                : r === n
                  ? ((i - a) / s) % 6
                  : r === i
                    ? 2 + (a - n) / s
                    : 4 + (n - i) / s + 4),
        (e /= 6),
        [360 * (e %= 1), 100 * s, 100 * (s < 1 ? o / (1 - s) : 0)]
      )
    }),
    (a.hsl.hcg = function (t) {
      const e = t[1] / 100
      let n = t[2] / 100
      let i = 1
      let a = 0
      return (
        (i = n < 0.5 ? 2 * e * n : 2 * e * (1 - n)) < 1 &&
              (a = (n - 0.5 * i) / (1 - i)),
        [t[0], 100 * i, 100 * a]
      )
    }),
    (a.hsv.hcg = function (t) {
      const e = t[1] / 100
      let n = t[2] / 100
      let i = e * n
      let a = 0
      return i < 1 && (a = (n - i) / (1 - i)), [t[0], 100 * i, 100 * a]
    }),
    (a.hcg.rgb = function (t) {
      const e = t[0] / 360
      let n = t[1] / 100
      let i = t[2] / 100
      if (n === 0) return [255 * i, 255 * i, 255 * i]
      let a
      let r = [0, 0, 0]
      let o = (e % 1) * 6
      let s = o % 1
      let l = 1 - s
      switch (Math.floor(o)) {
        case 0:
          (r[0] = 1), (r[1] = s), (r[2] = 0)
          break
        case 1:
          (r[0] = l), (r[1] = 1), (r[2] = 0)
          break
        case 2:
          (r[0] = 0), (r[1] = 1), (r[2] = s)
          break
        case 3:
          (r[0] = 0), (r[1] = l), (r[2] = 1)
          break
        case 4:
          (r[0] = s), (r[1] = 0), (r[2] = 1)
          break
        default:
          (r[0] = 1), (r[1] = 0), (r[2] = l)
      }
      return (
        (a = (1 - n) * i),
        [255 * (n * r[0] + a), 255 * (n * r[1] + a), 255 * (n * r[2] + a)]
      )
    }),
    (a.hcg.hsv = function (t) {
      const e = t[1] / 100
      let n = e + (t[2] / 100) * (1 - e)
      let i = 0
      return n > 0 && (i = e / n), [t[0], 100 * i, 100 * n]
    }),
    (a.hcg.hsl = function (t) {
      const e = t[1] / 100
      let n = (t[2] / 100) * (1 - e) + 0.5 * e
      let i = 0
      return (
        n > 0 && n < 0.5
          ? (i = e / (2 * n))
          : n >= 0.5 && n < 1 && (i = e / (2 * (1 - n))),
        [t[0], 100 * i, 100 * n]
      )
    }),
    (a.hcg.hwb = function (t) {
      const e = t[1] / 100
      let n = e + (t[2] / 100) * (1 - e)
      return [t[0], 100 * (n - e), 100 * (1 - n)]
    }),
    (a.hwb.hcg = function (t) {
      const e = t[1] / 100
      let n = 1 - t[2] / 100
      let i = n - e
      let a = 0
      return i < 1 && (a = (n - i) / (1 - i)), [t[0], 100 * i, 100 * a]
    }),
    (a.apple.rgb = function (t) {
      return [
        (t[0] / 65535) * 255,
        (t[1] / 65535) * 255,
        (t[2] / 65535) * 255
      ]
    }),
    (a.rgb.apple = function (t) {
      return [
        (t[0] / 255) * 65535,
        (t[1] / 255) * 65535,
        (t[2] / 255) * 65535
      ]
    }),
    (a.gray.rgb = function (t) {
      return [(t[0] / 100) * 255, (t[0] / 100) * 255, (t[0] / 100) * 255]
    }),
    (a.gray.hsl = a.gray.hsv =
          function (t) {
            return [0, 0, t[0]]
          }),
    (a.gray.hwb = function (t) {
      return [0, 100, t[0]]
    }),
    (a.gray.cmyk = function (t) {
      return [0, 0, 0, t[0]]
    }),
    (a.gray.lab = function (t) {
      return [t[0], 0, 0]
    }),
    (a.gray.hex = function (t) {
      const e = 255 & Math.round((t[0] / 100) * 255)
      let n = ((e << 16) + (e << 8) + e).toString(16).toUpperCase()
      return '000000'.substring(n.length) + n
    }),
    (a.rgb.gray = function (t) {
      return [((t[0] + t[1] + t[2]) / 3 / 255) * 100]
    })
  })
  i.rgb,
  i.hsl,
  i.hsv,
  i.hwb,
  i.cmyk,
  i.xyz,
  i.lab,
  i.lch,
  i.hex,
  i.keyword,
  i.ansi16,
  i.ansi256,
  i.hcg,
  i.apple,
  i.gray
  function a (t) {
    const e = (function () {
      for (var t = {}, e = Object.keys(i), n = e.length, a = 0; a < n; a++) { t[e[a]] = { distance: -1, parent: null } }
      return t
    })()
    let n = [t]
    for (e[t].distance = 0; n.length;) {
      for (
        let a = n.pop(), r = Object.keys(i[a]), o = r.length, s = 0;
        s < o;
        s++
      ) {
        let l = r[s]
        var u = e[l]
      u.distance === -1 &&
          ((u.distance = e[a].distance + 1), (u.parent = a), n.unshift(l))
      } 
}
    return e
  }
  function r (t, e) {
    return function (n) {
      return e(t(n))
    }
  }
  function o (t, e) {
    for (
      var n = [e[t].parent, t], a = i[e[t].parent][t], o = e[t].parent;
      e[o].parent;

    ) { n.unshift(e[o].parent), (a = r(i[e[o].parent][o], a)), (o = e[o].parent) }
    return (a.conversion = n), a
  }
  const s = {}
  Object.keys(i).forEach(function (t) {
    (s[t] = {}),
    Object.defineProperty(s[t], 'channels', { value: i[t].channels }),
    Object.defineProperty(s[t], 'labels', { value: i[t].labels })
    const e = (function (t) {
      for (
        var e = a(t), n = {}, i = Object.keys(e), r = i.length, s = 0;
        s < r;
        s++
      ) {
        const l = i[s]
        e[l].parent !== null && (n[l] = o(l, e))
      }
      return n
    })(t)
    Object.keys(e).forEach(function (n) {
      const i = e[n];
      (s[t][n] = (function (t) {
        const e = function (e) {
          if (e == null) return e
          arguments.length > 1 && (e = Array.prototype.slice.call(arguments))
          const n = t(e)
          if (typeof n === 'object') { for (let i = n.length, a = 0; a < i; a++) n[a] = Math.round(n[a]) }
          return n
        }
        return 'conversion' in t && (e.conversion = t.conversion), e
      })(i)),
      (s[t][n].raw = (function (t) {
        const e = function (e) {
          return e == null
            ? e
            : (arguments.length > 1 &&
                  (e = Array.prototype.slice.call(arguments)),
              t(e))
        }
        return 'conversion' in t && (e.conversion = t.conversion), e
      })(i))
    })
  })
  const l = s
  let u = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }
  let d = {
    getRgba: h,
    getHsla: c,
    getRgb: function (t) {
      const e = h(t)
      return e && e.slice(0, 3)
    },
    getHsl: function (t) {
      const e = c(t)
      return e && e.slice(0, 3)
    },
    getHwb: f,
    getAlpha: function (t) {
      let e = h(t)
      if (e) return e[3]
      if ((e = c(t))) return e[3]
      if ((e = f(t))) return e[3]
    },
    hexString: function (t, e) {
      e = void 0 !== e && t.length === 3 ? e : t[3]
      return (
        '#' +
          b(t[0]) +
          b(t[1]) +
          b(t[2]) +
          (e >= 0 && e < 1 ? b(Math.round(255 * e)) : '')
      )
    },
    rgbString: function (t, e) {
      if (e < 1 || (t[3] && t[3] < 1)) return g(t, e)
      return 'rgb(' + t[0] + ', ' + t[1] + ', ' + t[2] + ')'
    },
    rgbaString: g,
    percentString: function (t, e) {
      if (e < 1 || (t[3] && t[3] < 1)) return m(t, e)
      const n = Math.round((t[0] / 255) * 100)
      let i = Math.round((t[1] / 255) * 100)
      let a = Math.round((t[2] / 255) * 100)
      return 'rgb(' + n + '%, ' + i + '%, ' + a + '%)'
    },
    percentaString: m,
    hslString: function (t, e) {
      if (e < 1 || (t[3] && t[3] < 1)) return p(t, e)
      return 'hsl(' + t[0] + ', ' + t[1] + '%, ' + t[2] + '%)'
    },
    hslaString: p,
    hwbString: function (t, e) {
      void 0 === e && (e = void 0 !== t[3] ? t[3] : 1)
      return (
        'hwb(' +
          t[0] +
          ', ' +
          t[1] +
          '%, ' +
          t[2] +
          '%' +
          (void 0 !== e && e !== 1 ? ', ' + e : '') +
          ')'
      )
    },
    keyword: function (t) {
      return y[t.slice(0, 3)]
    }
  }
  function h (t) {
    if (t) {
      let e = [0, 0, 0]
      let n = 1
      let i = t.match(/^#([a-fA-F0-9]{3,4})$/i)
      let a = ''
      if (i) {
        a = (i = i[1])[3]
        for (var r = 0; r < e.length; r++) e[r] = parseInt(i[r] + i[r], 16)
        a && (n = Math.round((parseInt(a + a, 16) / 255) * 100) / 100)
      } else if ((i = t.match(/^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i))) {
        (a = i[2]), (i = i[1])
        for (r = 0; r < e.length; r++) { e[r] = parseInt(i.slice(2 * r, 2 * r + 2), 16) }
        a && (n = Math.round((parseInt(a, 16) / 255) * 100) / 100)
      } else if (
        (i = t.match(
          /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i
        ))
      ) {
        for (r = 0; r < e.length; r++) e[r] = parseInt(i[r + 1])
        n = parseFloat(i[4])
      } else if (
        (i = t.match(
          /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i
        ))
      ) {
        for (r = 0; r < e.length; r++) { e[r] = Math.round(2.55 * parseFloat(i[r + 1])) }
        n = parseFloat(i[4])
      } else if ((i = t.match(/(\w+)/))) {
        if (i[1] == 'transparent') return [0, 0, 0, 0]
        if (!(e = u[i[1]])) return
      }
      for (r = 0; r < e.length; r++) e[r] = v(e[r], 0, 255)
      return (n = n || n == 0 ? v(n, 0, 1) : 1), (e[3] = n), e
    }
  }
  function c (t) {
    if (t) {
      const e = t.match(
        /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/
      )
      if (e) {
        const n = parseFloat(e[4])
        return [
          v(parseInt(e[1]), 0, 360),
          v(parseFloat(e[2]), 0, 100),
          v(parseFloat(e[3]), 0, 100),
          v(isNaN(n) ? 1 : n, 0, 1)
        ]
      }
    }
  }
  function f (t) {
    if (t) {
      const e = t.match(
        /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/
      )
      if (e) {
        const n = parseFloat(e[4])
        return [
          v(parseInt(e[1]), 0, 360),
          v(parseFloat(e[2]), 0, 100),
          v(parseFloat(e[3]), 0, 100),
          v(isNaN(n) ? 1 : n, 0, 1)
        ]
      }
    }
  }
  function g (t, e) {
    return (
      void 0 === e && (e = void 0 !== t[3] ? t[3] : 1),
      'rgba(' + t[0] + ', ' + t[1] + ', ' + t[2] + ', ' + e + ')'
    )
  }
  function m (t, e) {
    return (
      'rgba(' +
      Math.round((t[0] / 255) * 100) +
      '%, ' +
      Math.round((t[1] / 255) * 100) +
      '%, ' +
      Math.round((t[2] / 255) * 100) +
      '%, ' +
      (e || t[3] || 1) +
      ')'
    )
  }
  function p (t, e) {
    return (
      void 0 === e && (e = void 0 !== t[3] ? t[3] : 1),
      'hsla(' + t[0] + ', ' + t[1] + '%, ' + t[2] + '%, ' + e + ')'
    )
  }
  function v (t, e, n) {
    return Math.min(Math.max(e, t), n)
  }
  function b (t) {
    const e = t.toString(16).toUpperCase()
    return e.length < 2 ? '0' + e : e
  }
  var y = {}
  for (const x in u) y[u[x]] = x
  var _ = function (t) {
    return t instanceof _
      ? t
      : this instanceof _
        ? ((this.valid = !1),
          (this.values = {
            rgb: [0, 0, 0],
            hsl: [0, 0, 0],
            hsv: [0, 0, 0],
            hwb: [0, 0, 0],
            cmyk: [0, 0, 0, 0],
            alpha: 1
          }),
          void (typeof t === 'string'
            ? (e = d.getRgba(t))
                ? this.setValues('rgb', e)
                : (e = d.getHsla(t))
                    ? this.setValues('hsl', e)
                    : (e = d.getHwb(t)) && this.setValues('hwb', e)
            : typeof t === 'object' &&
            (void 0 !== (e = t).r || void 0 !== e.red
              ? this.setValues('rgb', e)
              : void 0 !== e.l || void 0 !== e.lightness
                ? this.setValues('hsl', e)
                : void 0 !== e.v || void 0 !== e.value
                  ? this.setValues('hsv', e)
                  : void 0 !== e.w || void 0 !== e.whiteness
                    ? this.setValues('hwb', e)
                    : (void 0 === e.c && void 0 === e.cyan) ||
                this.setValues('cmyk', e))))
        : new _(t)
    let e
  };
  (_.prototype = {
    isValid: function () {
      return this.valid
    },
    rgb: function () {
      return this.setSpace('rgb', arguments)
    },
    hsl: function () {
      return this.setSpace('hsl', arguments)
    },
    hsv: function () {
      return this.setSpace('hsv', arguments)
    },
    hwb: function () {
      return this.setSpace('hwb', arguments)
    },
    cmyk: function () {
      return this.setSpace('cmyk', arguments)
    },
    rgbArray: function () {
      return this.values.rgb
    },
    hslArray: function () {
      return this.values.hsl
    },
    hsvArray: function () {
      return this.values.hsv
    },
    hwbArray: function () {
      const t = this.values
      return t.alpha !== 1 ? t.hwb.concat([t.alpha]) : t.hwb
    },
    cmykArray: function () {
      return this.values.cmyk
    },
    rgbaArray: function () {
      const t = this.values
      return t.rgb.concat([t.alpha])
    },
    hslaArray: function () {
      const t = this.values
      return t.hsl.concat([t.alpha])
    },
    alpha: function (t) {
      return void 0 === t
        ? this.values.alpha
        : (this.setValues('alpha', t), this)
    },
    red: function (t) {
      return this.setChannel('rgb', 0, t)
    },
    green: function (t) {
      return this.setChannel('rgb', 1, t)
    },
    blue: function (t) {
      return this.setChannel('rgb', 2, t)
    },
    hue: function (t) {
      return (
        t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel('hsl', 0, t)
      )
    },
    saturation: function (t) {
      return this.setChannel('hsl', 1, t)
    },
    lightness: function (t) {
      return this.setChannel('hsl', 2, t)
    },
    saturationv: function (t) {
      return this.setChannel('hsv', 1, t)
    },
    whiteness: function (t) {
      return this.setChannel('hwb', 1, t)
    },
    blackness: function (t) {
      return this.setChannel('hwb', 2, t)
    },
    value: function (t) {
      return this.setChannel('hsv', 2, t)
    },
    cyan: function (t) {
      return this.setChannel('cmyk', 0, t)
    },
    magenta: function (t) {
      return this.setChannel('cmyk', 1, t)
    },
    yellow: function (t) {
      return this.setChannel('cmyk', 2, t)
    },
    black: function (t) {
      return this.setChannel('cmyk', 3, t)
    },
    hexString: function () {
      return d.hexString(this.values.rgb)
    },
    rgbString: function () {
      return d.rgbString(this.values.rgb, this.values.alpha)
    },
    rgbaString: function () {
      return d.rgbaString(this.values.rgb, this.values.alpha)
    },
    percentString: function () {
      return d.percentString(this.values.rgb, this.values.alpha)
    },
    hslString: function () {
      return d.hslString(this.values.hsl, this.values.alpha)
    },
    hslaString: function () {
      return d.hslaString(this.values.hsl, this.values.alpha)
    },
    hwbString: function () {
      return d.hwbString(this.values.hwb, this.values.alpha)
    },
    keyword: function () {
      return d.keyword(this.values.rgb, this.values.alpha)
    },
    rgbNumber: function () {
      const t = this.values.rgb
      return (t[0] << 16) | (t[1] << 8) | t[2]
    },
    luminosity: function () {
      for (var t = this.values.rgb, e = [], n = 0; n < t.length; n++) {
        const i = t[n] / 255
        e[n] = i <= 0.03928 ? i / 12.92 : Math.pow((i + 0.055) / 1.055, 2.4)
      }
      return 0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]
    },
    contrast: function (t) {
      const e = this.luminosity()
      let n = t.luminosity()
      return e > n ? (e + 0.05) / (n + 0.05) : (n + 0.05) / (e + 0.05)
    },
    level: function (t) {
      const e = this.contrast(t)
      return e >= 7.1 ? 'AAA' : e >= 4.5 ? 'AA' : ''
    },
    dark: function () {
      const t = this.values.rgb
      return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128
    },
    light: function () {
      return !this.dark()
    },
    negate: function () {
      for (var t = [], e = 0; e < 3; e++) t[e] = 255 - this.values.rgb[e]
      return this.setValues('rgb', t), this
    },
    lighten: function (t) {
      const e = this.values.hsl
      return (e[2] += e[2] * t), this.setValues('hsl', e), this
    },
    darken: function (t) {
      const e = this.values.hsl
      return (e[2] -= e[2] * t), this.setValues('hsl', e), this
    },
    saturate: function (t) {
      const e = this.values.hsl
      return (e[1] += e[1] * t), this.setValues('hsl', e), this
    },
    desaturate: function (t) {
      const e = this.values.hsl
      return (e[1] -= e[1] * t), this.setValues('hsl', e), this
    },
    whiten: function (t) {
      const e = this.values.hwb
      return (e[1] += e[1] * t), this.setValues('hwb', e), this
    },
    blacken: function (t) {
      const e = this.values.hwb
      return (e[2] += e[2] * t), this.setValues('hwb', e), this
    },
    greyscale: function () {
      const t = this.values.rgb
      let e = 0.3 * t[0] + 0.59 * t[1] + 0.11 * t[2]
      return this.setValues('rgb', [e, e, e]), this
    },
    clearer: function (t) {
      const e = this.values.alpha
      return this.setValues('alpha', e - e * t), this
    },
    opaquer: function (t) {
      const e = this.values.alpha
      return this.setValues('alpha', e + e * t), this
    },
    rotate: function (t) {
      const e = this.values.hsl
      let n = (e[0] + t) % 360
      return (e[0] = n < 0 ? 360 + n : n), this.setValues('hsl', e), this
    },
    mix: function (t, e) {
      const n = t
      let i = void 0 === e ? 0.5 : e
      let a = 2 * i - 1
      let r = this.alpha() - n.alpha()
      let o = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2
      let s = 1 - o
      return this.rgb(
        o * this.red() + s * n.red(),
        o * this.green() + s * n.green(),
        o * this.blue() + s * n.blue()
      ).alpha(this.alpha() * i + n.alpha() * (1 - i))
    },
    toJSON: function () {
      return this.rgb()
    },
    clone: function () {
      let t
      let e
      let n = new _()
      let i = this.values
      let a = n.values
      for (const r in i) {
        i.hasOwnProperty(r) &&
          ((t = i[r]),
          (e = {}.toString.call(t)) === '[object Array]'
            ? (a[r] = t.slice(0))
            : e === '[object Number]'
              ? (a[r] = t)
              : console.error('unexpected color value:', t)) 
}
      return n
    }
  }),
  (_.prototype.spaces = {
    rgb: ['red', 'green', 'blue'],
    hsl: ['hue', 'saturation', 'lightness'],
    hsv: ['hue', 'saturation', 'value'],
    hwb: ['hue', 'whiteness', 'blackness'],
    cmyk: ['cyan', 'magenta', 'yellow', 'black']
  }),
  (_.prototype.maxes = {
    rgb: [255, 255, 255],
    hsl: [360, 100, 100],
    hsv: [360, 100, 100],
    hwb: [360, 100, 100],
    cmyk: [100, 100, 100, 100]
  }),
  (_.prototype.getValues = function (t) {
    for (var e = this.values, n = {}, i = 0; i < t.length; i++) { n[t.charAt(i)] = e[t][i] }
    return e.alpha !== 1 && (n.a = e.alpha), n
  }),
  (_.prototype.setValues = function (t, e) {
    let n
    let i
    let a = this.values
    let r = this.spaces
    let o = this.maxes
    let s = 1
    if (((this.valid = !0), t === 'alpha')) s = e
    else if (e.length) (a[t] = e.slice(0, t.length)), (s = e[t.length])
    else if (void 0 !== e[t.charAt(0)]) {
      for (n = 0; n < t.length; n++) a[t][n] = e[t.charAt(n)]
      s = e.a
    } else if (void 0 !== e[r[t][0]]) {
      const u = r[t]
      for (n = 0; n < t.length; n++) a[t][n] = e[u[n]]
      s = e.alpha
    }
    if (
      ((a.alpha = Math.max(0, Math.min(1, void 0 === s ? a.alpha : s))),
      t === 'alpha')
    ) { return !1 }
    for (n = 0; n < t.length; n++) {
 (i = Math.max(0, Math.min(o[t][n], a[t][n]))),
    (a[t][n] = Math.round(i)) 
}
    for (const d in r) d !== t && (a[d] = l[t][d](a[t]))
    return !0
  }),
  (_.prototype.setSpace = function (t, e) {
    let n = e[0]
    return void 0 === n
      ? this.getValues(t)
      : (typeof n === 'number' && (n = Array.prototype.slice.call(e)),
        this.setValues(t, n),
        this)
  }),
  (_.prototype.setChannel = function (t, e, n) {
    const i = this.values[t]
    return void 0 === n
      ? i[e]
      : n === i[e]
        ? this
        : ((i[e] = n), this.setValues(t, i), this)
  }),
  typeof window !== 'undefined' && (window.Color = _)
  const w = _
  function k (t) {
    return ['__proto__', 'prototype', 'constructor'].indexOf(t) === -1
  }
  let M
  var S = {
    noop: function () {},
    uid:
        ((M = 0),
        function () {
          return M++
        }),
    isNullOrUndef: function (t) {
      return t == null
    },
    isArray: function (t) {
      if (Array.isArray && Array.isArray(t)) return !0
      let e = Object.prototype.toString.call(t)
      return e.substr(0, 7) === '[object' && e.substr(-6) === 'Array]'
    },
    isObject: function (t) {
      return (
        t !== null && Object.prototype.toString.call(t) === '[object Object]'
      )
    },
    isFinite: function (t) {
      return (typeof t === 'number' || t instanceof Number) && isFinite(t)
    },
    valueOrDefault: function (t, e) {
      return void 0 === t ? e : t
    },
    valueAtIndexOrDefault: function (t, e, n) {
      return S.valueOrDefault(S.isArray(t) ? t[e] : t, n)
    },
    callback: function (t, e, n) {
      if (t && typeof t.call === 'function') return t.apply(n, e)
    },
    each: function (t, e, n, i) {
      let a, r, o
      if (S.isArray(t)) { if (((r = t.length), i))
        for (a = r - 1; a >= 0; a--) e.call(n, t[a], a)
      else for (a = 0; a < r; a++) e.call(n, t[a], a) } else if (S.isObject(t)) { for (r = (o = Object.keys(t)).length, a = 0; a < r; a++)
        e.call(n, t[o[a]], o[a]) }
    },
    arrayEquals: function (t, e) {
      let n, i, a, r
      if (!t || !e || t.length !== e.length) return !1
      for (n = 0, i = t.length; n < i; ++n) { if (
        ((a = t[n]), (r = e[n]), a instanceof Array && r instanceof Array)
      ) {
        if (!S.arrayEquals(a, r)) return !1
      } else if (a !== r) return !1 }
      return !0
    },
    clone: function (t) {
      if (S.isArray(t)) return t.map(S.clone)
      if (S.isObject(t)) {
        for (
          var e = Object.create(t), n = Object.keys(t), i = n.length, a = 0;
          a < i;
          ++a
        ) { e[n[a]] = S.clone(t[n[a]]) }
        return e
      }
      return t
    },
    _merger: function (t, e, n, i) {
      if (k(t)) {
        const a = e[t]
        var r = n[t]
        S.isObject(a) && S.isObject(r)
          ? S.merge(a, r, i)
          : (e[t] = S.clone(r))
      }
    },
    _mergerIf: function (t, e, n) {
      if (k(t)) {
        const i = e[t]
        var a = n[t]
        S.isObject(i) && S.isObject(a)
          ? S.mergeIf(i, a)
          : e.hasOwnProperty(t) || (e[t] = S.clone(a))
      }
    },
    merge: function (t, e, n) {
      let i
      var a
      var r
      var o
      var s
      var l = S.isArray(e) ? e : [e]
      var u = l.length
      if (!S.isObject(t)) return t
      for (i = (n = n || {}).merger || S._merger, a = 0; a < u; ++a) { if (((e = l[a]), S.isObject(e)))
        for (s = 0, o = (r = Object.keys(e)).length; s < o; ++s)
          i(r[s], t, e, n) }
      return t
    },
    mergeIf: function (t, e) {
      return S.merge(t, e, { merger: S._mergerIf })
    },
    extend:
        Object.assign ||
        function (t) {
          return S.merge(t, [].slice.call(arguments, 1), {
            merger: function (t, e, n) {
              e[t] = n[t]
            }
          })
        },
    inherits: function (t) {
      const e = this
      var n =
            t && t.hasOwnProperty('constructor')
              ? t.constructor
              : function () {
                return e.apply(this, arguments)
              };
      let i = function () {
        this.constructor = n
      }
      return (
        (i.prototype = e.prototype),
        (n.prototype = new i()),
        (n.extend = S.inherits),
        t && S.extend(n.prototype, t),
        (n.__super__ = e.prototype),
        n
      )
    },
    _deprecated: function (t, e, n, i) {
      void 0 !== e &&
          console.warn(
            t + ': "' + n + '" is deprecated. Please use "' + i + '" instead'
          )
    }
  }
  let D = S;
  (S.callCallback = S.callback),
  (S.indexOf = function (t, e, n) {
    return Array.prototype.indexOf.call(t, e, n)
  }),
  (S.getValueOrDefault = S.valueOrDefault),
  (S.getValueAtIndexOrDefault = S.valueAtIndexOrDefault)
  var C = {
    linear: function (t) {
      return t
    },
    easeInQuad: function (t) {
      return t * t
    },
    easeOutQuad: function (t) {
      return -t * (t - 2)
    },
    easeInOutQuad: function (t) {
      return (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1)
    },
    easeInCubic: function (t) {
      return t * t * t
    },
    easeOutCubic: function (t) {
      return (t -= 1) * t * t + 1
    },
    easeInOutCubic: function (t) {
      return (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2)
    },
    easeInQuart: function (t) {
      return t * t * t * t
    },
    easeOutQuart: function (t) {
      return -((t -= 1) * t * t * t - 1)
    },
    easeInOutQuart: function (t) {
      return (t /= 0.5) < 1
        ? 0.5 * t * t * t * t
        : -0.5 * ((t -= 2) * t * t * t - 2)
    },
    easeInQuint: function (t) {
      return t * t * t * t * t
    },
    easeOutQuint: function (t) {
      return (t -= 1) * t * t * t * t + 1
    },
    easeInOutQuint: function (t) {
      return (t /= 0.5) < 1
        ? 0.5 * t * t * t * t * t
        : 0.5 * ((t -= 2) * t * t * t * t + 2)
    },
    easeInSine: function (t) {
      return 1 - Math.cos(t * (Math.PI / 2))
    },
    easeOutSine: function (t) {
      return Math.sin(t * (Math.PI / 2))
    },
    easeInOutSine: function (t) {
      return -0.5 * (Math.cos(Math.PI * t) - 1)
    },
    easeInExpo: function (t) {
      return t === 0 ? 0 : Math.pow(2, 10 * (t - 1))
    },
    easeOutExpo: function (t) {
      return t === 1 ? 1 : 1 - Math.pow(2, -10 * t)
    },
    easeInOutExpo: function (t) {
      return t === 0
        ? 0
        : t === 1
          ? 1
          : (t /= 0.5) < 1
              ? 0.5 * Math.pow(2, 10 * (t - 1))
              : 0.5 * (2 - Math.pow(2, -10 * --t))
    },
    easeInCirc: function (t) {
      return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)
    },
    easeOutCirc: function (t) {
      return Math.sqrt(1 - (t -= 1) * t)
    },
    easeInOutCirc: function (t) {
      return (t /= 0.5) < 1
        ? -0.5 * (Math.sqrt(1 - t * t) - 1)
        : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
    },
    easeInElastic: function (t) {
      let e = 1.70158
      let n = 0
      let i = 1
      return t === 0
        ? 0
        : t === 1
          ? 1
          : (n || (n = 0.3),
            i < 1
              ? ((i = 1), (e = n / 4))
              : (e = (n / (2 * Math.PI)) * Math.asin(1 / i)),
            -i *
              Math.pow(2, 10 * (t -= 1)) *
              Math.sin(((t - e) * (2 * Math.PI)) / n))
    },
    easeOutElastic: function (t) {
      let e = 1.70158
      let n = 0
      let i = 1
      return t === 0
        ? 0
        : t === 1
          ? 1
          : (n || (n = 0.3),
            i < 1
              ? ((i = 1), (e = n / 4))
              : (e = (n / (2 * Math.PI)) * Math.asin(1 / i)),
            i * Math.pow(2, -10 * t) * Math.sin(((t - e) * (2 * Math.PI)) / n) +
              1)
    },
    easeInOutElastic: function (t) {
      let e = 1.70158
      let n = 0
      let i = 1
      return t === 0
        ? 0
        : (t /= 0.5) == 2
            ? 1
            : (n || (n = 0.45),
              i < 1
                ? ((i = 1), (e = n / 4))
                : (e = (n / (2 * Math.PI)) * Math.asin(1 / i)),
              t < 1
                ? i *
                Math.pow(2, 10 * (t -= 1)) *
                Math.sin(((t - e) * (2 * Math.PI)) / n) *
                -0.5
                : i *
                  Math.pow(2, -10 * (t -= 1)) *
                  Math.sin(((t - e) * (2 * Math.PI)) / n) *
                  0.5 +
                1)
    },
    easeInBack: function (t) {
      const e = 1.70158
      return t * t * ((e + 1) * t - e)
    },
    easeOutBack: function (t) {
      const e = 1.70158
      return (t -= 1) * t * ((e + 1) * t + e) + 1
    },
    easeInOutBack: function (t) {
      let e = 1.70158
      return (t /= 0.5) < 1
        ? t * t * ((1 + (e *= 1.525)) * t - e) * 0.5
        : 0.5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
    },
    easeInBounce: function (t) {
      return 1 - C.easeOutBounce(1 - t)
    },
    easeOutBounce: function (t) {
      return t < 1 / 2.75
        ? 7.5625 * t * t
        : t < 2 / 2.75
          ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75
          : t < 2.5 / 2.75
            ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375
            : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375
    },
    easeInOutBounce: function (t) {
      return t < 0.5
        ? 0.5 * C.easeInBounce(2 * t)
        : 0.5 * C.easeOutBounce(2 * t - 1) + 0.5
    }
  }
  let P = { effects: C }
  D.easingEffects = C
  const T = Math.PI
  let O = T / 180
  let A = 2 * T
  let F = T / 2
  let I = T / 4
  let L = (2 * T) / 3
  let R = {
    clear: function (t) {
      t.ctx.clearRect(0, 0, t.width, t.height)
    },
    roundedRect: function (t, e, n, i, a, r) {
      if (r) {
        const o = Math.min(r, a / 2, i / 2)
        var s = e + o
        var l = n + o
        var u = e + i - o
        var d = n + a - o
        t.moveTo(e, l),
        s < u && l < d
          ? (t.arc(s, l, o, -T, -F),
            t.arc(u, l, o, -F, 0),
            t.arc(u, d, o, 0, F),
            t.arc(s, d, o, F, T))
          : s < u
            ? (t.moveTo(s, n),
              t.arc(u, l, o, -F, F),
              t.arc(s, l, o, F, T + F))
            : l < d
              ? (t.arc(s, l, o, -T, 0), t.arc(s, d, o, 0, T))
              : t.arc(s, l, o, -T, T),
        t.closePath(),
        t.moveTo(e, n)
      } else t.rect(e, n, i, a)
    },
    drawPoint: function (t, e, n, i, a, r) {
      let o
      var s
      var l
      var u
      var d
      var h = (r || 0) * O
      if (
        e &&
          typeof e === 'object' &&
          ((o = e.toString()) === '[object HTMLImageElement]' ||
            o === '[object HTMLCanvasElement]')
      ) { return (
        t.save(),
        t.translate(i, a),
        t.rotate(h),
        t.drawImage(e, -e.width / 2, -e.height / 2, e.width, e.height),
        void t.restore()
      ); }
      if (!(isNaN(n) || n <= 0)) {
        switch ((t.beginPath(), e)) {
          default:
            t.arc(i, a, n, 0, A), t.closePath()
            break
          case 'triangle':
            t.moveTo(i + Math.sin(h) * n, a - Math.cos(h) * n),
            (h += L),
            t.lineTo(i + Math.sin(h) * n, a - Math.cos(h) * n),
            (h += L),
            t.lineTo(i + Math.sin(h) * n, a - Math.cos(h) * n),
            t.closePath()
            break
          case 'rectRounded':
            (u = n - (d = 0.516 * n)),
            (s = Math.cos(h + I) * u),
            (l = Math.sin(h + I) * u),
            t.arc(i - s, a - l, d, h - T, h - F),
            t.arc(i + l, a - s, d, h - F, h),
            t.arc(i + s, a + l, d, h, h + F),
            t.arc(i - l, a + s, d, h + F, h + T),
            t.closePath()
            break
          case 'rect':
            if (!r) {
              (u = Math.SQRT1_2 * n), t.rect(i - u, a - u, 2 * u, 2 * u)
              break
            }
            h += I
          case 'rectRot':
            (s = Math.cos(h) * n),
            (l = Math.sin(h) * n),
            t.moveTo(i - s, a - l),
            t.lineTo(i + l, a - s),
            t.lineTo(i + s, a + l),
            t.lineTo(i - l, a + s),
            t.closePath()
            break
          case 'crossRot':
            h += I
          case 'cross':
            (s = Math.cos(h) * n),
            (l = Math.sin(h) * n),
            t.moveTo(i - s, a - l),
            t.lineTo(i + s, a + l),
            t.moveTo(i + l, a - s),
            t.lineTo(i - l, a + s)
            break
          case 'star':
            (s = Math.cos(h) * n),
            (l = Math.sin(h) * n),
            t.moveTo(i - s, a - l),
            t.lineTo(i + s, a + l),
            t.moveTo(i + l, a - s),
            t.lineTo(i - l, a + s),
            (h += I),
            (s = Math.cos(h) * n),
            (l = Math.sin(h) * n),
            t.moveTo(i - s, a - l),
            t.lineTo(i + s, a + l),
            t.moveTo(i + l, a - s),
            t.lineTo(i - l, a + s)
            break
          case 'line':
            (s = Math.cos(h) * n),
            (l = Math.sin(h) * n),
            t.moveTo(i - s, a - l),
            t.lineTo(i + s, a + l)
            break
          case 'dash':
            t.moveTo(i, a),
            t.lineTo(i + Math.cos(h) * n, a + Math.sin(h) * n)
        }
        t.fill(), t.stroke()
      }
    },
    _isPointInArea: function (t, e) {
      return (
        t.x > e.left - 1e-6 &&
          t.x < e.right + 1e-6 &&
          t.y > e.top - 1e-6 &&
          t.y < e.bottom + 1e-6
      )
    },
    clipArea: function (t, e) {
      t.save(),
      t.beginPath(),
      t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top),
      t.clip()
    },
    unclipArea: function (t) {
      t.restore()
    },
    lineTo: function (t, e, n, i) {
      const a = n.steppedLine
      if (a) {
        if (a === 'middle') {
          const r = (e.x + n.x) / 2
          t.lineTo(r, i ? n.y : e.y), t.lineTo(r, i ? e.y : n.y)
        } else { (a === 'after' && !i) || (a !== 'after' && i)
          ? t.lineTo(e.x, n.y)
          : t.lineTo(n.x, e.y) }
        t.lineTo(n.x, n.y)
      } else { n.tension
        ? t.bezierCurveTo(
          i ? e.controlPointPreviousX : e.controlPointNextX,
          i ? e.controlPointPreviousY : e.controlPointNextY,
          i ? n.controlPointNextX : n.controlPointPreviousX,
          i ? n.controlPointNextY : n.controlPointPreviousY,
          n.x,
          n.y
        )
        : t.lineTo(n.x, n.y) }
    }
  }
  let N = R;
  (D.clear = R.clear),
  (D.drawRoundedRectangle = function (t) {
    t.beginPath(), R.roundedRect.apply(R, arguments)
  })
  const W = {
    _set: function (t, e) {
      return D.merge(this[t] || (this[t] = {}), e)
    }
  }
  W._set('global', {
    defaultColor: 'rgba(0,0,0,0.1)',
    defaultFontColor: '#666',
    defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
    defaultFontSize: 12,
    defaultFontStyle: 'normal',
    defaultLineHeight: 1.2,
    showLines: !0
  })
  const Y = W
  let z = D.valueOrDefault
  const E = {
    toLineHeight: function (t, e) {
      const n = ('' + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/)
      if (!n || n[1] === 'normal') return 1.2 * e
      switch (((t = +n[2]), n[3])) {
        case 'px':
          return t
        case '%':
          t /= 100
      }
      return e * t
    },
    toPadding: function (t) {
      let e, n, i, a
      return (
        D.isObject(t)
          ? ((e = +t.top || 0),
            (n = +t.right || 0),
            (i = +t.bottom || 0),
            (a = +t.left || 0))
          : (e = n = i = a = +t || 0),
        { top: e, right: n, bottom: i, left: a, height: e + i, width: a + n }
      )
    },
    _parseFont: function (t) {
      const e = Y.global
      var n = z(t.fontSize, e.defaultFontSize)
      var i = {
        family: z(t.fontFamily, e.defaultFontFamily),
        lineHeight: D.options.toLineHeight(
          z(t.lineHeight, e.defaultLineHeight),
          n
        ),
        size: n,
        style: z(t.fontStyle, e.defaultFontStyle),
        weight: null,
        string: ''
      }
      return (
        (i.string = (function (t) {
          return !t || D.isNullOrUndef(t.size) || D.isNullOrUndef(t.family)
            ? null
            : (t.style ? t.style + ' ' : '') +
                  (t.weight ? t.weight + ' ' : '') +
                  t.size +
                  'px ' +
                  t.family
        })(i)),
        i
      )
    },
    resolve: function (t, e, n, i) {
      let a
      var r
      var o
      var s = !0
      for (a = 0, r = t.length; a < r; ++a) {
 if (
        void 0 !== (o = t[a]) &&
            (void 0 !== e && typeof o === 'function' && ((o = o(e)), (s = !1)),
            void 0 !== n && D.isArray(o) && ((o = o[n]), (s = !1)),
            void 0 !== o)
      )
        {return i && !s && (i.cacheable = !1), o}}
    }
  }
  let V = {
    _factorize: function (t) {
      let e
      var n = []
      var i = Math.sqrt(t)
      for (e = 1; e < i; e++) t % e == 0 && (n.push(e), n.push(t / e))
      return (
        i === (0 | i) && n.push(i),
        n
          .sort(function (t, e) {
            return t - e
          })
          .pop(),
        n
      )
    },
    log10:
        Math.log10 ||
        function (t) {
          const e = Math.log(t) * Math.LOG10E
          var n = Math.round(e)
          return t === Math.pow(10, n) ? n : e
        }
  }
  let H = V
  D.log10 = V.log10
  const B = D
  let j = P
  let U = N
  let G = E
  let q = H
  let Z = {
    getRtlAdapter: function (t, e, n) {
      return t
        ? (function (t, e) {
            return {
              x: function (n) {
                return t + t + e - n
              },
              setWidth: function (t) {
                e = t
              },
              textAlign: function (t) {
                return t === 'center' ? t : t === 'right' ? 'left' : 'right'
              },
              xPlus: function (t, e) {
                return t - e
              },
              leftForLtr: function (t, e) {
                return t - e
              }
            }
          })(e, n)
        : {
            x: function (t) {
              return t
            },
            setWidth: function (t) {},
            textAlign: function (t) {
              return t
            },
            xPlus: function (t, e) {
              return t + e
            },
            leftForLtr: function (t, e) {
              return t
            }
          }
    },
    overrideTextDirection: function (t, e) {
      let n, i;
      (e !== 'ltr' && e !== 'rtl') ||
          ((i = [
            (n = t.canvas.style).getPropertyValue('direction'),
            n.getPropertyPriority('direction')
          ]),
          n.setProperty('direction', e, 'important'),
          (t.prevTextDirection = i))
    },
    restoreTextDirection: function (t) {
      const e = t.prevTextDirection
      void 0 !== e &&
          (delete t.prevTextDirection,
          t.canvas.style.setProperty('direction', e[0], e[1]))
    }
  };
  (B.easing = j), (B.canvas = U), (B.options = G), (B.math = q), (B.rtl = Z)
  const $ = function (t) {
    B.extend(this, t), this.initialize.apply(this, arguments)
  }
  B.extend($.prototype, {
    _type: void 0,
    initialize: function () {
      this.hidden = !1
    },
    pivot: function () {
      const t = this
      return t._view || (t._view = B.extend({}, t._model)), (t._start = {}), t
    },
    transition: function (t) {
      const e = this
      let n = e._model
      let i = e._start
      let a = e._view
      return n && t !== 1
        ? (a || (a = e._view = {}),
          i || (i = e._start = {}),
          (function (t, e, n, i) {
            let a
            let r
            let o
            let s
            let l
            let u
            let d
            let h
            let c
            let f = Object.keys(n)
            for (a = 0, r = f.length; a < r; ++a) {
              if (
                ((u = n[(o = f[a])]),
                e.hasOwnProperty(o) || (e[o] = u),
                (s = e[o]) !== u && o[0] !== '_')
              ) {
                if (
                  (t.hasOwnProperty(o) || (t[o] = s),
                  (d = typeof u) === typeof (l = t[o]))
                ) { if (d === 'string') {
                  if ((h = w(l)).valid && (c = w(u)).valid) {
                    e[o] = c.mix(h, i).rgbString()
                    continue;
                  }
                } else if (B.isFinite(l) && B.isFinite(u)) {
                  e[o] = l + (u - l) * i
                  continue;
                } }
                e[o] = u
              } 
}
          })(i, a, n, t),
          e)
        : ((e._view = B.extend({}, n)), (e._start = null), e)
    },
    tooltipPosition: function () {
      return { x: this._model.x, y: this._model.y }
    },
    hasValue: function () {
      return B.isNumber(this._model.x) && B.isNumber(this._model.y)
    }
  }),
  ($.extend = B.inherits)
  const X = $
  let K = X.extend({
    chart: null,
    currentStep: 0,
    numSteps: 60,
    easing: '',
    render: null,
    onAnimationProgress: null,
    onAnimationComplete: null
  })
  let J = K
  Object.defineProperty(K.prototype, 'animationObject', {
    get: function () {
      return this
    }
  }),
  Object.defineProperty(K.prototype, 'chartInstance', {
    get: function () {
      return this.chart
    },
    set: function (t) {
      this.chart = t
    }
  }),
  Y._set('global', {
    animation: {
      duration: 1e3,
      easing: 'easeOutQuart',
      onProgress: B.noop,
      onComplete: B.noop
    }
  })
  const Q = {
    animations: [],
    request: null,
    addAnimation: function (t, e, n, i) {
      let a
      var r
      var o = this.animations
      for (
        e.chart = t,
        e.startTime = Date.now(),
        e.duration = n,
        i || (t.animating = !0),
        a = 0,
        r = o.length;
        a < r;
        ++a
      ) { if (o[a].chart === t) return void (o[a] = e) }
      o.push(e), o.length === 1 && this.requestAnimationFrame()
    },
    cancelAnimation: function (t) {
      const e = B.findIndex(this.animations, function (e) {
        return e.chart === t
      })
      e !== -1 && (this.animations.splice(e, 1), (t.animating = !1))
    },
    requestAnimationFrame: function () {
      const t = this
      t.request === null &&
          (t.request = B.requestAnimFrame.call(window, function () {
            (t.request = null), t.startDigest()
          }))
    },
    startDigest: function () {
      this.advance(),
      this.animations.length > 0 && this.requestAnimationFrame()
    },
    advance: function () {
      for (var t, e, n, i, a = this.animations, r = 0; r < a.length;) {
 (e = (t = a[r]).chart),
      (n = t.numSteps),
      (i = Math.floor(((Date.now() - t.startTime) / t.duration) * n) + 1),
      (t.currentStep = Math.min(i, n)),
      B.callback(t.render, [e, t], e),
      B.callback(t.onAnimationProgress, [t], e),
      t.currentStep >= n
        ? (B.callback(t.onAnimationComplete, [t], e),
          (e.animating = !1),
          a.splice(r, 1))
        : ++r }
    }
  }
  let tt = B.options.resolve
  let et = ['push', 'pop', 'shift', 'splice', 'unshift']
  function nt (t, e) {
    const n = t._chartjs
    if (n) {
      const i = n.listeners
      let a = i.indexOf(e)
      a !== -1 && i.splice(a, 1),
      i.length > 0 ||
          (et.forEach(function (e) {
            delete t[e]
          }),
          delete t._chartjs)
    }
  }
  const it = function (t, e) {
    this.initialize(t, e)
  }
  B.extend(it.prototype, {
    datasetElementType: null,
    dataElementType: null,
    _datasetElementOptions: [
      'backgroundColor',
      'borderCapStyle',
      'borderColor',
      'borderDash',
      'borderDashOffset',
      'borderJoinStyle',
      'borderWidth'
    ],
    _dataElementOptions: [
      'backgroundColor',
      'borderColor',
      'borderWidth',
      'pointStyle'
    ],
    initialize: function (t, e) {
      const n = this;
      (n.chart = t),
      (n.index = e),
      n.linkScales(),
      n.addElements(),
      (n._type = n.getMeta().type)
    },
    updateIndex: function (t) {
      this.index = t
    },
    linkScales: function () {
      const t = this.getMeta()
      let e = this.chart
      let n = e.scales
      let i = this.getDataset()
      let a = e.options.scales;
      (t.xAxisID !== null && t.xAxisID in n && !i.xAxisID) ||
        (t.xAxisID = i.xAxisID || a.xAxes[0].id),
      (t.yAxisID !== null && t.yAxisID in n && !i.yAxisID) ||
          (t.yAxisID = i.yAxisID || a.yAxes[0].id)
    },
    getDataset: function () {
      return this.chart.data.datasets[this.index]
    },
    getMeta: function () {
      return this.chart.getDatasetMeta(this.index)
    },
    getScaleForId: function (t) {
      return this.chart.scales[t]
    },
    _getValueScaleId: function () {
      return this.getMeta().yAxisID
    },
    _getIndexScaleId: function () {
      return this.getMeta().xAxisID
    },
    _getValueScale: function () {
      return this.getScaleForId(this._getValueScaleId())
    },
    _getIndexScale: function () {
      return this.getScaleForId(this._getIndexScaleId())
    },
    reset: function () {
      this._update(!0)
    },
    destroy: function () {
      this._data && nt(this._data, this)
    },
    createMetaDataset: function () {
      const t = this.datasetElementType
      return t && new t({ _chart: this.chart, _datasetIndex: this.index })
    },
    createMetaData: function (t) {
      const e = this.dataElementType
      return (
        e && new e({ _chart: this.chart, _datasetIndex: this.index, _index: t })
      )
    },
    addElements: function () {
      let t
      let e
      let n = this.getMeta()
      let i = this.getDataset().data || []
      let a = n.data
      for (t = 0, e = i.length; t < e; ++t) { a[t] = a[t] || this.createMetaData(t) }
      n.dataset = n.dataset || this.createMetaDataset()
    },
    addElementAndReset: function (t) {
      const e = this.createMetaData(t)
      this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0)
    },
    buildOrUpdateElements: function () {
      let t
      let e
      let n = this
      let i = n.getDataset()
      let a = i.data || (i.data = [])
      n._data !== a &&
        (n._data && nt(n._data, n),
        a &&
          Object.isExtensible(a) &&
          ((e = n),
          (t = a)._chartjs
            ? t._chartjs.listeners.push(e)
            : (Object.defineProperty(t, '_chartjs', {
                configurable: !0,
                enumerable: !1,
                value: { listeners: [e] }
              }),
              et.forEach(function (e) {
                const n = 'onData' + e.charAt(0).toUpperCase() + e.slice(1)
                let i = t[e]
                Object.defineProperty(t, e, {
                  configurable: !0,
                  enumerable: !1,
                  value: function () {
                    const e = Array.prototype.slice.call(arguments)
                    let a = i.apply(this, e)
                    return (
                      B.each(t._chartjs.listeners, function (t) {
                        typeof t[n] === 'function' && t[n].apply(t, e)
                      }),
                      a
                    )
                  }
                })
              }))),
        (n._data = a)),
      n.resyncElements()
    },
    _configure: function () {
      this._config = B.merge(
        Object.create(null),
        [this.chart.options.datasets[this._type], this.getDataset()],
        {
          merger: function (t, e, n) {
            t !== '_meta' && t !== 'data' && B._merger(t, e, n)
          }
        }
      )
    },
    _update: function (t) {
      this._configure(), (this._cachedDataOpts = null), this.update(t)
    },
    update: B.noop,
    transition: function (t) {
      for (
        var e = this.getMeta(), n = e.data || [], i = n.length, a = 0;
        a < i;
        ++a
      ) { n[a].transition(t) }
      e.dataset && e.dataset.transition(t)
    },
    draw: function () {
      const t = this.getMeta()
      let e = t.data || []
      let n = e.length
      let i = 0
      for (t.dataset && t.dataset.draw(); i < n; ++i) e[i].draw()
    },
    getStyle: function (t) {
      let e
      let n = this.getMeta()
      let i = n.dataset
      return (
        this._configure(),
        i && void 0 === t
          ? (e = this._resolveDatasetElementOptions(i || {}))
          : ((t = t || 0),
            (e = this._resolveDataElementOptions(n.data[t] || {}, t))),
        (!1 !== e.fill && e.fill !== null) ||
          (e.backgroundColor = e.borderColor),
        e
      )
    },
    _resolveDatasetElementOptions: function (t, e) {
      let n
      let i
      let a
      let r
      let o = this
      let s = o.chart
      let l = o._config
      let u = t.custom || {}
      let d = s.options.elements[o.datasetElementType.prototype._type] || {}
      let h = o._datasetElementOptions
      let c = {}
      let f = {
        chart: s,
        dataset: o.getDataset(),
        datasetIndex: o.index,
        hover: e
      }
      for (n = 0, i = h.length; n < i; ++n) {
        (a = h[n]),
        (r = e ? 'hover' + a.charAt(0).toUpperCase() + a.slice(1) : a),
        (c[a] = tt([u[r], l[r], d[r]], f)) 
}
      return c
    },
    _resolveDataElementOptions: function (t, e) {
      const n = this
      let i = t && t.custom
      let a = n._cachedDataOpts
      if (a && !i) return a
      let r
      let o
      let s
      let l
      let u = n.chart
      let d = n._config
      let h = u.options.elements[n.dataElementType.prototype._type] || {}
      let c = n._dataElementOptions
      let f = {}
      let g = {
        chart: u,
        dataIndex: e,
        dataset: n.getDataset(),
        datasetIndex: n.index
      }
      let m = { cacheable: !i }
      if (((i = i || {}), B.isArray(c))) {
        for (o = 0, s = c.length; o < s; ++o) { f[(l = c[o])] = tt([i[l], d[l], h[l]], g, e, m) } } else {
        for (o = 0, s = (r = Object.keys(c)).length; o < s; ++o) { f[(l = r[o])] = tt([i[l], d[c[l]], d[l], h[l]], g, e, m) } }
      return m.cacheable && (n._cachedDataOpts = Object.freeze(f)), f
    },
    removeHoverStyle: function (t) {
      B.merge(t._model, t.$previousStyle || {}), delete t.$previousStyle
    },
    setHoverStyle: function (t) {
      const e = this.chart.data.datasets[t._datasetIndex]
      let n = t._index
      let i = t.custom || {}
      let a = t._model
      let r = B.getHoverColor;
      (t.$previousStyle = {
        backgroundColor: a.backgroundColor,
        borderColor: a.borderColor,
        borderWidth: a.borderWidth
      }),
      (a.backgroundColor = tt(
        [
          i.hoverBackgroundColor,
          e.hoverBackgroundColor,
          r(a.backgroundColor)
        ],
        void 0,
        n
      )),
      (a.borderColor = tt(
        [i.hoverBorderColor, e.hoverBorderColor, r(a.borderColor)],
        void 0,
        n
      )),
      (a.borderWidth = tt(
        [i.hoverBorderWidth, e.hoverBorderWidth, a.borderWidth],
        void 0,
        n
      ))
    },
    _removeDatasetHoverStyle: function () {
      const t = this.getMeta().dataset
      t && this.removeHoverStyle(t)
    },
    _setDatasetHoverStyle: function () {
      let t
      let e
      let n
      let i
      let a
      let r
      let o = this.getMeta().dataset
      let s = {}
      if (o) {
        for (
          r = o._model,
          a = this._resolveDatasetElementOptions(o, !0),
          t = 0,
          e = (i = Object.keys(a)).length;
          t < e;
          ++t
        ) { (s[(n = i[t])] = r[n]), (r[n] = a[n]) }
        o.$previousStyle = s
      }
    },
    resyncElements: function () {
      const t = this.getMeta()
      let e = this.getDataset().data
      let n = t.data.length
      let i = e.length
      i < n ? t.data.splice(i, n - i) : i > n && this.insertElements(n, i - n)
    },
    insertElements: function (t, e) {
      for (let n = 0; n < e; ++n) this.addElementAndReset(t + n)
    },
    onDataPush: function () {
      const t = arguments.length
      this.insertElements(this.getDataset().data.length - t, t)
    },
    onDataPop: function () {
      this.getMeta().data.pop()
    },
    onDataShift: function () {
      this.getMeta().data.shift()
    },
    onDataSplice: function (t, e) {
      this.getMeta().data.splice(t, e),
      this.insertElements(t, arguments.length - 2)
    },
    onDataUnshift: function () {
      this.insertElements(0, arguments.length)
    }
  }),
  (it.extend = B.inherits)
  const at = it
  let rt = 2 * Math.PI
  function ot (t, e) {
    const n = e.startAngle
    let i = e.endAngle
    let a = e.pixelMargin
    let r = a / e.outerRadius
    let o = e.x
    let s = e.y
    t.beginPath(),
    t.arc(o, s, e.outerRadius, n - r, i + r),
    e.innerRadius > a
      ? ((r = a / e.innerRadius),
        t.arc(o, s, e.innerRadius - a, i + r, n - r, !0))
      : t.arc(o, s, a, i + Math.PI / 2, n - Math.PI / 2),
    t.closePath(),
    t.clip()
  }
  function st (t, e, n) {
    const i = e.borderAlign === 'inner'
    i
      ? ((t.lineWidth = 2 * e.borderWidth), (t.lineJoin = 'round'))
      : ((t.lineWidth = e.borderWidth), (t.lineJoin = 'bevel')),
    n.fullCircles &&
        (function (t, e, n, i) {
          let a
          let r = n.endAngle
          for (
            i &&
              ((n.endAngle = n.startAngle + rt),
              ot(t, n),
              (n.endAngle = r),
              n.endAngle === n.startAngle &&
                n.fullCircles &&
                ((n.endAngle += rt), n.fullCircles--)),
            t.beginPath(),
            t.arc(
              n.x,
              n.y,
              n.innerRadius,
              n.startAngle + rt,
              n.startAngle,
              !0
            ),
            a = 0;
            a < n.fullCircles;
            ++a
          ) { t.stroke() }
          for (
            t.beginPath(),
            t.arc(n.x, n.y, e.outerRadius, n.startAngle, n.startAngle + rt),
            a = 0;
            a < n.fullCircles;
            ++a
          ) { t.stroke() }
        })(t, e, n, i),
    i && ot(t, n),
    t.beginPath(),
    t.arc(n.x, n.y, e.outerRadius, n.startAngle, n.endAngle),
    t.arc(n.x, n.y, n.innerRadius, n.endAngle, n.startAngle, !0),
    t.closePath(),
    t.stroke()
  }
  Y._set('global', {
    elements: {
      arc: {
        backgroundColor: Y.global.defaultColor,
        borderColor: '#fff',
        borderWidth: 2,
        borderAlign: 'center'
      }
    }
  })
  const lt = X.extend({
    _type: 'arc',
    inLabelRange: function (t) {
      const e = this._view
      return (
        !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2)
      )
    },
    inRange: function (t, e) {
      const n = this._view
      if (n) {
        for (
          var i = B.getAngleFromPoint(n, { x: t, y: e }),
            a = i.angle,
            r = i.distance,
            o = n.startAngle,
            s = n.endAngle;
          s < o;

        ) { s += rt }
        for (; a > s;) a -= rt
        for (; a < o;) a += rt
        let l = a >= o && a <= s
        var u = r >= n.innerRadius && r <= n.outerRadius
        return l && u
      }
      return !1
    },
    getCenterPoint: function () {
      const t = this._view
      var e = (t.startAngle + t.endAngle) / 2
      var n = (t.innerRadius + t.outerRadius) / 2
      return { x: t.x + Math.cos(e) * n, y: t.y + Math.sin(e) * n }
    },
    getArea: function () {
      const t = this._view
      return (
        Math.PI *
          ((t.endAngle - t.startAngle) / (2 * Math.PI)) *
          (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2))
      )
    },
    tooltipPosition: function () {
      const t = this._view
      var e = t.startAngle + (t.endAngle - t.startAngle) / 2
      var n = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius
      return { x: t.x + Math.cos(e) * n, y: t.y + Math.sin(e) * n }
    },
    draw: function () {
      let t
      var e = this._chart.ctx
      var n = this._view
      var i = n.borderAlign === 'inner' ? 0.33 : 0
      var a = {
        x: n.x,
        y: n.y,
        innerRadius: n.innerRadius,
        outerRadius: Math.max(n.outerRadius - i, 0),
        pixelMargin: i,
        startAngle: n.startAngle,
        endAngle: n.endAngle,
        fullCircles: Math.floor(n.circumference / rt)
      }
      if (
        (e.save(),
        (e.fillStyle = n.backgroundColor),
        (e.strokeStyle = n.borderColor),
        a.fullCircles)
      ) {
        for (
          a.endAngle = a.startAngle + rt,
          e.beginPath(),
          e.arc(a.x, a.y, a.outerRadius, a.startAngle, a.endAngle),
          e.arc(a.x, a.y, a.innerRadius, a.endAngle, a.startAngle, !0),
          e.closePath(),
          t = 0;
          t < a.fullCircles;
          ++t
        ) { e.fill() }
        a.endAngle = a.startAngle + (n.circumference % rt)
      }
      e.beginPath(),
      e.arc(a.x, a.y, a.outerRadius, a.startAngle, a.endAngle),
      e.arc(a.x, a.y, a.innerRadius, a.endAngle, a.startAngle, !0),
      e.closePath(),
      e.fill(),
      n.borderWidth && st(e, n, a),
      e.restore()
    }
  })
  let ut = B.valueOrDefault
  let dt = Y.global.defaultColor
  Y._set('global', {
    elements: {
      line: {
        tension: 0.4,
        backgroundColor: dt,
        borderWidth: 3,
        borderColor: dt,
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: 'miter',
        capBezierPoints: !0,
        fill: !0
      }
    }
  })
  const ht = X.extend({
    _type: 'line',
    draw: function () {
      let t
      var e
      var n
      var i = this
      var a = i._view
      var r = i._chart.ctx
      var o = a.spanGaps
      var s = i._children.slice()
      var l = Y.global
      var u = l.elements.line
      var d = -1
      var h = i._loop
      if (s.length) {
        if (i._loop) {
          for (t = 0; t < s.length; ++t) {
 if (
            ((e = B.previousItem(s, t)), !s[t]._view.skip && e._view.skip)
          ) {
            (s = s.slice(t).concat(s.slice(0, t))), (h = o)
            break;
          } 
}
          h && s.push(s[0])
        }
        for (
          r.save(),
          r.lineCap = a.borderCapStyle || u.borderCapStyle,
          r.setLineDash && r.setLineDash(a.borderDash || u.borderDash),
          r.lineDashOffset = ut(a.borderDashOffset, u.borderDashOffset),
          r.lineJoin = a.borderJoinStyle || u.borderJoinStyle,
          r.lineWidth = ut(a.borderWidth, u.borderWidth),
          r.strokeStyle = a.borderColor || l.defaultColor,
          r.beginPath(),
          (n = s[0]._view).skip || (r.moveTo(n.x, n.y), (d = 0)),
          t = 1;
          t < s.length;
          ++t
        ) {
 (n = s[t]._view),
        (e = d === -1 ? B.previousItem(s, t) : s[d]),
        n.skip ||
                ((d !== t - 1 && !o) || d === -1
                  ? r.moveTo(n.x, n.y)
                  : B.canvas.lineTo(r, e._view, n),
                (d = t)) }
        h && r.closePath(), r.stroke(), r.restore()
      }
    }
  })
  let ct = B.valueOrDefault
  let ft = Y.global.defaultColor
  function gt (t) {
    const e = this._view
    return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius
  }
  Y._set('global', {
    elements: {
      point: {
        radius: 3,
        pointStyle: 'circle',
        backgroundColor: ft,
        borderColor: ft,
        borderWidth: 1,
        hitRadius: 1,
        hoverRadius: 4,
        hoverBorderWidth: 1
      }
    }
  })
  const mt = X.extend({
    _type: 'point',
    inRange: function (t, e) {
      const n = this._view
      return (
        !!n &&
          Math.pow(t - n.x, 2) + Math.pow(e - n.y, 2) <
            Math.pow(n.hitRadius + n.radius, 2)
      )
    },
    inLabelRange: gt,
    inXRange: gt,
    inYRange: function (t) {
      const e = this._view
      return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius
    },
    getCenterPoint: function () {
      const t = this._view
      return { x: t.x, y: t.y }
    },
    getArea: function () {
      return Math.PI * Math.pow(this._view.radius, 2)
    },
    tooltipPosition: function () {
      const t = this._view
      return { x: t.x, y: t.y, padding: t.radius + t.borderWidth }
    },
    draw: function (t) {
      const e = this._view
      var n = this._chart.ctx
      var i = e.pointStyle
      var a = e.rotation
      var r = e.radius
      var o = e.x
      var s = e.y
      var l = Y.global
      var u = l.defaultColor
      e.skip ||
          ((void 0 === t || B.canvas._isPointInArea(e, t)) &&
            ((n.strokeStyle = e.borderColor || u),
            (n.lineWidth = ct(e.borderWidth, l.elements.point.borderWidth)),
            (n.fillStyle = e.backgroundColor || u),
            B.canvas.drawPoint(n, i, r, o, s, a)))
    }
  })
  let pt = Y.global.defaultColor
  function vt (t) {
    return t && void 0 !== t.width
  }
  function bt (t) {
    let e, n, i, a, r
    return (
      vt(t)
        ? ((r = t.width / 2),
          (e = t.x - r),
          (n = t.x + r),
          (i = Math.min(t.y, t.base)),
          (a = Math.max(t.y, t.base)))
        : ((r = t.height / 2),
          (e = Math.min(t.x, t.base)),
          (n = Math.max(t.x, t.base)),
          (i = t.y - r),
          (a = t.y + r)),
      { left: e, top: i, right: n, bottom: a }
    )
  }
  function yt (t, e, n) {
    return t === e ? n : t === n ? e : t
  }
  function xt (t, e, n) {
    let i
    let a
    let r
    let o
    let s = t.borderWidth
    let l = (function (t) {
      let e = t.borderSkipped
      let n = {}
      return e
        ? (t.horizontal
            ? t.base > t.x && (e = yt(e, 'left', 'right'))
            : t.base < t.y && (e = yt(e, 'bottom', 'top')),
          (n[e] = !0),
          n)
        : n
    })(t)
    return (
      B.isObject(s)
        ? ((i = +s.top || 0),
          (a = +s.right || 0),
          (r = +s.bottom || 0),
          (o = +s.left || 0))
        : (i = a = r = o = +s || 0),
      {
        t: l.top || i < 0 ? 0 : i > n ? n : i,
        r: l.right || a < 0 ? 0 : a > e ? e : a,
        b: l.bottom || r < 0 ? 0 : r > n ? n : r,
        l: l.left || o < 0 ? 0 : o > e ? e : o
      }
    )
  }
  function _t (t, e, n) {
    const i = e === null
      const a = n === null
      const r = !(!t || (i && a)) && bt(t)
    return (
      r &&
      (i || (e >= r.left && e <= r.right)) &&
      (a || (n >= r.top && n <= r.bottom))
    )
  }
  Y._set('global', {
    elements: {
      rectangle: {
        backgroundColor: pt,
        borderColor: pt,
        borderSkipped: 'bottom',
        borderWidth: 0
      }
    }
  })
  const wt = X.extend({
    _type: 'rectangle',
    draw: function () {
      const t = this._chart.ctx
      var e = this._view
      var n = (function (t) {
        let e = bt(t)
              var n = e.right - e.left
              var i = e.bottom - e.top
              var a = xt(t, n / 2, i / 2)
        return {
          outer: { x: e.left, y: e.top, w: n, h: i },
          inner: {
            x: e.left + a.l,
            y: e.top + a.t,
            w: n - a.l - a.r,
            h: i - a.t - a.b
          }
        }
      })(e)
      var i = n.outer
      var a = n.inner;
      (t.fillStyle = e.backgroundColor),
      t.fillRect(i.x, i.y, i.w, i.h),
      (i.w === a.w && i.h === a.h) ||
            (t.save(),
            t.beginPath(),
            t.rect(i.x, i.y, i.w, i.h),
            t.clip(),
            (t.fillStyle = e.borderColor),
            t.rect(a.x, a.y, a.w, a.h),
            t.fill('evenodd'),
            t.restore())
    },
    height: function () {
      const t = this._view
      return t.base - t.y
    },
    inRange: function (t, e) {
      return _t(this._view, t, e)
    },
    inLabelRange: function (t, e) {
      const n = this._view
      return vt(n) ? _t(n, t, null) : _t(n, null, e)
    },
    inXRange: function (t) {
      return _t(this._view, t, null)
    },
    inYRange: function (t) {
      return _t(this._view, null, t)
    },
    getCenterPoint: function () {
      let t
      var e
      var n = this._view
      return (
        vt(n)
          ? ((t = n.x), (e = (n.y + n.base) / 2))
          : ((t = (n.x + n.base) / 2), (e = n.y)),
        { x: t, y: e }
      )
    },
    getArea: function () {
      const t = this._view
      return vt(t)
        ? t.width * Math.abs(t.y - t.base)
        : t.height * Math.abs(t.x - t.base)
    },
    tooltipPosition: function () {
      const t = this._view
      return { x: t.x, y: t.y }
    }
  })
  let kt = {}
  let Mt = lt
  let St = ht
  let Dt = mt
  let Ct = wt;
  (kt.Arc = Mt), (kt.Line = St), (kt.Point = Dt), (kt.Rectangle = Ct)
  const Pt = B._deprecated
  let Tt = B.valueOrDefault
  function Ot (t, e, n) {
    let i
    let a
    let r = n.barThickness
    let o = e.stackCount
    let s = e.pixels[t]
    let l = B.isNullOrUndef(r)
      ? (function (t, e) {
          let n
          let i
          let a
          let r
          let o = t._length
          for (a = 1, r = e.length; a < r; ++a) { o = Math.min(o, Math.abs(e[a] - e[a - 1])) }
          for (a = 0, r = t.getTicks().length; a < r; ++a) {
            (i = t.getPixelForTick(a)),
            (o = a > 0 ? Math.min(o, Math.abs(i - n)) : o),
            (n = i) 
}
          return o
        })(e.scale, e.pixels)
      : -1
    return (
      B.isNullOrUndef(r)
        ? ((i = l * n.categoryPercentage), (a = n.barPercentage))
        : ((i = r * o), (a = 1)),
      { chunk: i / o, ratio: a, start: s - i / 2 }
    )
  }
  Y._set('bar', {
    hover: { mode: 'label' },
    scales: {
      xAxes: [
        { type: 'category', offset: !0, gridLines: { offsetGridLines: !0 } }
      ],
      yAxes: [{ type: 'linear' }]
    }
  }),
  Y._set('global', {
    datasets: { bar: { categoryPercentage: 0.8, barPercentage: 0.9 } }
  })
  const At = at.extend({
    dataElementType: kt.Rectangle,
    _dataElementOptions: [
      'backgroundColor',
      'borderColor',
      'borderSkipped',
      'borderWidth',
      'barPercentage',
      'barThickness',
      'categoryPercentage',
      'maxBarThickness',
      'minBarLength'
    ],
    initialize: function () {
      let t
      var e
      var n = this
      at.prototype.initialize.apply(n, arguments),
      ((t = n.getMeta()).stack = n.getDataset().stack),
      (t.bar = !0),
      (e = n._getIndexScale().options),
      Pt(
        'bar chart',
        e.barPercentage,
        'scales.[x/y]Axes.barPercentage',
        'dataset.barPercentage'
      ),
      Pt(
        'bar chart',
        e.barThickness,
        'scales.[x/y]Axes.barThickness',
        'dataset.barThickness'
      ),
      Pt(
        'bar chart',
        e.categoryPercentage,
        'scales.[x/y]Axes.categoryPercentage',
        'dataset.categoryPercentage'
      ),
      Pt(
        'bar chart',
        n._getValueScale().options.minBarLength,
        'scales.[x/y]Axes.minBarLength',
        'dataset.minBarLength'
      ),
      Pt(
        'bar chart',
        e.maxBarThickness,
        'scales.[x/y]Axes.maxBarThickness',
        'dataset.maxBarThickness'
      )
    },
    update: function (t) {
      let e
      var n
      var i = this.getMeta().data
      for (this._ruler = this.getRuler(), e = 0, n = i.length; e < n; ++e) { this.updateElement(i[e], e, t) }
    },
    updateElement: function (t, e, n) {
      const i = this
      var a = i.getMeta()
      var r = i.getDataset()
      var o = i._resolveDataElementOptions(t, e);
      (t._xScale = i.getScaleForId(a.xAxisID)),
      (t._yScale = i.getScaleForId(a.yAxisID)),
      (t._datasetIndex = i.index),
      (t._index = e),
      (t._model = {
        backgroundColor: o.backgroundColor,
        borderColor: o.borderColor,
        borderSkipped: o.borderSkipped,
        borderWidth: o.borderWidth,
        datasetLabel: r.label,
        label: i.chart.data.labels[e]
      }),
      B.isArray(r.data[e]) && (t._model.borderSkipped = null),
      i._updateElementGeometry(t, e, n, o),
      t.pivot()
    },
    _updateElementGeometry: function (t, e, n, i) {
      const a = this
      var r = t._model
      var o = a._getValueScale()
      var s = o.getBasePixel()
      var l = o.isHorizontal()
      var u = a._ruler || a.getRuler()
      var d = a.calculateBarValuePixels(a.index, e, i)
      var h = a.calculateBarIndexPixels(a.index, e, u, i);
      (r.horizontal = l),
      (r.base = n ? s : d.base),
      (r.x = l ? (n ? s : d.head) : h.center),
      (r.y = l ? h.center : n ? s : d.head),
      (r.height = l ? h.size : void 0),
      (r.width = l ? void 0 : h.size)
    },
    _getStacks: function (t) {
      let e
      var n
      var i = this._getIndexScale()
      var a = i._getMatchingVisibleMetas(this._type)
      var r = i.options.stacked
      var o = a.length
      var s = []
      for (
        e = 0;
        e < o &&
          ((n = a[e]),
          (!1 === r ||
            s.indexOf(n.stack) === -1 ||
            (void 0 === r && void 0 === n.stack)) &&
            s.push(n.stack),
          n.index !== t);
        ++e
      );
      return s
    },
    getStackCount: function () {
      return this._getStacks().length
    },
    getStackIndex: function (t, e) {
      const n = this._getStacks(t)
      var i = void 0 !== e ? n.indexOf(e) : -1
      return i === -1 ? n.length - 1 : i
    },
    getRuler: function () {
      let t
      var e
      var n = this._getIndexScale()
      var i = []
      for (t = 0, e = this.getMeta().data.length; t < e; ++t) { i.push(n.getPixelForValue(null, t, this.index)) }
      return {
        pixels: i,
        start: n._startPixel,
        end: n._endPixel,
        stackCount: this.getStackCount(),
        scale: n
      }
    },
    calculateBarValuePixels: function (t, e, n) {
      let i
      var a
      var r
      var o
      var s
      var l
      var u
      var d = this.chart
      var h = this._getValueScale()
      var c = h.isHorizontal()
      var f = d.data.datasets
      var g = h._getMatchingVisibleMetas(this._type)
      var m = h._parseValue(f[t].data[e])
      var p = n.minBarLength
      var v = h.options.stacked
      var b = this.getMeta().stack
      var y = void 0 === m.start ? 0 : m.max >= 0 && m.min >= 0 ? m.min : m.max
      var x =
            void 0 === m.start
              ? m.end
              : m.max >= 0 && m.min >= 0
                ? m.max - m.min
                : m.min - m.max
      var _ = g.length
      if (v || (void 0 === v && void 0 !== b)) {
 for (i = 0; i < _ && (a = g[i]).index !== t; ++i)
        {a.stack === b &&
              ((r =
                void 0 === (u = h._parseValue(f[a.index].data[e])).start
                  ? u.end
                  : u.min >= 0 && u.max >= 0
                    ? u.max
                    : u.min),
              ((m.min < 0 && r < 0) || (m.max >= 0 && r > 0)) && (y += r))}}
      return (
        (o = h.getPixelForValue(y)),
        (l = (s = h.getPixelForValue(y + x)) - o),
        void 0 !== p &&
            Math.abs(l) < p &&
            ((l = p), (s = (x >= 0 && !c) || (x < 0 && c) ? o - p : o + p)),
        { size: l, base: o, head: s, center: s + l / 2 }
      )
    },
    calculateBarIndexPixels: function (t, e, n, i) {
      const a =
            i.barThickness === 'flex'
              ? (function (t, e, n) {
                  let i
                    var a = e.pixels
                    var r = a[t]
                    var o = t > 0 ? a[t - 1] : null
                    var s = t < a.length - 1 ? a[t + 1] : null
                    var l = n.categoryPercentage
                  return (
                    o === null &&
                      (o = r - (s === null ? e.end - e.start : s - r)),
                    s === null && (s = r + r - o),
                    (i = r - ((r - Math.min(o, s)) / 2) * l),
                    {
                      chunk: ((Math.abs(s - o) / 2) * l) / e.stackCount,
                      ratio: n.barPercentage,
                      start: i
                    }
                  )
                })(e, n, i)
              : Ot(e, n, i)
      var r = this.getStackIndex(t, this.getMeta().stack)
      var o = a.start + a.chunk * r + a.chunk / 2
      var s = Math.min(Tt(i.maxBarThickness, 1 / 0), a.chunk * a.ratio)
      return { base: o - s / 2, head: o + s / 2, center: o, size: s }
    },
    draw: function () {
      const t = this.chart
      var e = this._getValueScale()
      var n = this.getMeta().data
      var i = this.getDataset()
      var a = n.length
      var r = 0
      for (B.canvas.clipArea(t.ctx, t.chartArea); r < a; ++r) {
        const o = e._parseValue(i.data[r])
        isNaN(o.min) || isNaN(o.max) || n[r].draw()
      }
      B.canvas.unclipArea(t.ctx)
    },
    _resolveDataElementOptions: function () {
      const t = this
      var e = B.extend(
        {},
        at.prototype._resolveDataElementOptions.apply(t, arguments)
      )
      var n = t._getIndexScale().options
      var i = t._getValueScale().options
      return (
        (e.barPercentage = Tt(n.barPercentage, e.barPercentage)),
        (e.barThickness = Tt(n.barThickness, e.barThickness)),
        (e.categoryPercentage = Tt(
          n.categoryPercentage,
          e.categoryPercentage
        )),
        (e.maxBarThickness = Tt(n.maxBarThickness, e.maxBarThickness)),
        (e.minBarLength = Tt(i.minBarLength, e.minBarLength)),
        e
      )
    }
  })
  let Ft = B.valueOrDefault
  let It = B.options.resolve
  Y._set('bubble', {
    hover: { mode: 'single' },
    scales: {
      xAxes: [{ type: 'linear', position: 'bottom', id: 'x-axis-0' }],
      yAxes: [{ type: 'linear', position: 'left', id: 'y-axis-0' }]
    },
    tooltips: {
      callbacks: {
        title: function () {
          return ''
        },
        label: function (t, e) {
          const n = e.datasets[t.datasetIndex].label || ''
            const i = e.datasets[t.datasetIndex].data[t.index]
          return n + ': (' + t.xLabel + ', ' + t.yLabel + ', ' + i.r + ')'
        }
      }
    }
  })
  const Lt = at.extend({
    dataElementType: kt.Point,
    _dataElementOptions: [
      'backgroundColor',
      'borderColor',
      'borderWidth',
      'hoverBackgroundColor',
      'hoverBorderColor',
      'hoverBorderWidth',
      'hoverRadius',
      'hitRadius',
      'pointStyle',
      'rotation'
    ],
    update: function (t) {
      const e = this
      var n = e.getMeta().data
      B.each(n, function (n, i) {
        e.updateElement(n, i, t)
      })
    },
    updateElement: function (t, e, n) {
      const i = this
      var a = i.getMeta()
      var r = t.custom || {}
      var o = i.getScaleForId(a.xAxisID)
      var s = i.getScaleForId(a.yAxisID)
      var l = i._resolveDataElementOptions(t, e)
      var u = i.getDataset().data[e]
      var d = i.index
      var h = n
        ? o.getPixelForDecimal(0.5)
        : o.getPixelForValue(typeof u === 'object' ? u : NaN, e, d)
      var c = n ? s.getBasePixel() : s.getPixelForValue(u, e, d);
      (t._xScale = o),
      (t._yScale = s),
      (t._options = l),
      (t._datasetIndex = d),
      (t._index = e),
      (t._model = {
        backgroundColor: l.backgroundColor,
        borderColor: l.borderColor,
        borderWidth: l.borderWidth,
        hitRadius: l.hitRadius,
        pointStyle: l.pointStyle,
        rotation: l.rotation,
        radius: n ? 0 : l.radius,
        skip: r.skip || isNaN(h) || isNaN(c),
        x: h,
        y: c
      }),
      t.pivot()
    },
    setHoverStyle: function (t) {
      const e = t._model
      var n = t._options
      var i = B.getHoverColor;
      (t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth,
        radius: e.radius
      }),
      (e.backgroundColor = Ft(
        n.hoverBackgroundColor,
        i(n.backgroundColor)
      )),
      (e.borderColor = Ft(n.hoverBorderColor, i(n.borderColor))),
      (e.borderWidth = Ft(n.hoverBorderWidth, n.borderWidth)),
      (e.radius = n.radius + n.hoverRadius)
    },
    _resolveDataElementOptions: function (t, e) {
      const n = this
      var i = n.chart
      var a = n.getDataset()
      var r = t.custom || {}
      var o = a.data[e] || {}
      var s = at.prototype._resolveDataElementOptions.apply(n, arguments)
      var l = { chart: i, dataIndex: e, dataset: a, datasetIndex: n.index }
      return (
        n._cachedDataOpts === s && (s = B.extend({}, s)),
        (s.radius = It(
          [r.radius, o.r, n._config.radius, i.options.elements.point.radius],
          l,
          e
        )),
        s
      )
    }
  })
  let Rt = B.valueOrDefault
  let Nt = Math.PI
  let Wt = 2 * Nt
  let Yt = Nt / 2
  Y._set('doughnut', {
    animation: { animateRotate: !0, animateScale: !1 },
    hover: { mode: 'single' },
    legendCallback: function (t) {
      let e
      let n
      let i
      let a = document.createElement('ul')
      let r = t.data
      let o = r.datasets
      let s = r.labels
      if ((a.setAttribute('class', t.id + '-legend'), o.length)) {
        for (e = 0, n = o[0].data.length; e < n; ++e) { ((i = a.appendChild(document.createElement('li'))).appendChild(
          document.createElement('span')
        ).style.backgroundColor = o[0].backgroundColor[e]),
        s[e] && i.appendChild(document.createTextNode(s[e])) } }
      return a.outerHTML
    },
    legend: {
      labels: {
        generateLabels: function (t) {
          const e = t.data
          return e.labels.length && e.datasets.length
            ? e.labels.map(function (n, i) {
              const a = t.getDatasetMeta(0)
              let r = a.controller.getStyle(i)
              return {
                text: n,
                fillStyle: r.backgroundColor,
                strokeStyle: r.borderColor,
                lineWidth: r.borderWidth,
                hidden: isNaN(e.datasets[0].data[i]) || a.data[i].hidden,
                index: i
              }
            })
            : []
        }
      },
      onClick: function (t, e) {
        let n
        let i
        let a
        let r = e.index
        let o = this.chart
        for (n = 0, i = (o.data.datasets || []).length; n < i; ++n) {
          (a = o.getDatasetMeta(n)).data[r] &&
            (a.data[r].hidden = !a.data[r].hidden) 
}
        o.update()
      }
    },
    cutoutPercentage: 50,
    rotation: -Yt,
    circumference: Wt,
    tooltips: {
      callbacks: {
        title: function () {
          return ''
        },
        label: function (t, e) {
          let n = e.labels[t.index]
          let i = ': ' + e.datasets[t.datasetIndex].data[t.index]
          return B.isArray(n) ? ((n = n.slice())[0] += i) : (n += i), n
        }
      }
    }
  })
  const zt = at.extend({
    dataElementType: kt.Arc,
    linkScales: B.noop,
    _dataElementOptions: [
      'backgroundColor',
      'borderColor',
      'borderWidth',
      'borderAlign',
      'hoverBackgroundColor',
      'hoverBorderColor',
      'hoverBorderWidth'
    ],
    getRingIndex: function (t) {
      for (var e = 0, n = 0; n < t; ++n) this.chart.isDatasetVisible(n) && ++e
      return e
    },
    update: function (t) {
      let e
      var n
      var i
      var a
      var r = this
      var o = r.chart
      var s = o.chartArea
      var l = o.options
      var u = 1
      var d = 1
      var h = 0
      var c = 0
      var f = r.getMeta()
      var g = f.data
      var m = l.cutoutPercentage / 100 || 0
      var p = l.circumference
      var v = r._getRingWeight(r.index)
      if (p < Wt) {
        let b = l.rotation % Wt
        var y = (b += b >= Nt ? -Wt : b < -Nt ? Wt : 0) + p
        var x = Math.cos(b)
        var _ = Math.sin(b)
        var w = Math.cos(y)
        var k = Math.sin(y)
        var M = (b <= 0 && y >= 0) || y >= Wt
        var S = (b <= Yt && y >= Yt) || y >= Wt + Yt
        var D = (b <= -Yt && y >= -Yt) || y >= Nt + Yt
        var C = b === -Nt || y >= Nt ? -1 : Math.min(x, x * m, w, w * m)
        var P = D ? -1 : Math.min(_, _ * m, k, k * m)
        var T = M ? 1 : Math.max(x, x * m, w, w * m)
        var O = S ? 1 : Math.max(_, _ * m, k, k * m);
        (u = (T - C) / 2),
        (d = (O - P) / 2),
        (h = -(T + C) / 2),
        (c = -(O + P) / 2)
      }
      for (i = 0, a = g.length; i < a; ++i) { g[i]._options = r._resolveDataElementOptions(g[i], i) }
      for (
        o.borderWidth = r.getMaxBorderWidth(),
        e = (s.right - s.left - o.borderWidth) / u,
        n = (s.bottom - s.top - o.borderWidth) / d,
        o.outerRadius = Math.max(Math.min(e, n) / 2, 0),
        o.innerRadius = Math.max(o.outerRadius * m, 0),
        o.radiusLength =
            (o.outerRadius - o.innerRadius) /
            (r._getVisibleDatasetWeightTotal() || 1),
        o.offsetX = h * o.outerRadius,
        o.offsetY = c * o.outerRadius,
        f.total = r.calculateTotal(),
        r.outerRadius =
            o.outerRadius - o.radiusLength * r._getRingWeightOffset(r.index),
        r.innerRadius = Math.max(r.outerRadius - o.radiusLength * v, 0),
        i = 0,
        a = g.length;
        i < a;
        ++i
      ) { r.updateElement(g[i], i, t) }
    },
    updateElement: function (t, e, n) {
      const i = this
      var a = i.chart
      var r = a.chartArea
      var o = a.options
      var s = o.animation
      var l = (r.left + r.right) / 2
      var u = (r.top + r.bottom) / 2
      var d = o.rotation
      var h = o.rotation
      var c = i.getDataset()
      var f =
          n && s.animateRotate
            ? 0
            : t.hidden
              ? 0
              : i.calculateCircumference(c.data[e]) * (o.circumference / Wt)
      var g = n && s.animateScale ? 0 : i.innerRadius
      var m = n && s.animateScale ? 0 : i.outerRadius
      var p = t._options || {}
      B.extend(t, {
        _datasetIndex: i.index,
        _index: e,
        _model: {
          backgroundColor: p.backgroundColor,
          borderColor: p.borderColor,
          borderWidth: p.borderWidth,
          borderAlign: p.borderAlign,
          x: l + a.offsetX,
          y: u + a.offsetY,
          startAngle: d,
          endAngle: h,
          circumference: f,
          outerRadius: m,
          innerRadius: g,
          label: B.valueAtIndexOrDefault(c.label, e, a.data.labels[e])
        }
      })
      const v = t._model;
      (n && s.animateRotate) ||
        ((v.startAngle =
          e === 0 ? o.rotation : i.getMeta().data[e - 1]._model.endAngle),
        (v.endAngle = v.startAngle + v.circumference)),
      t.pivot()
    },
    calculateTotal: function () {
      let t
      var e = this.getDataset()
      var n = this.getMeta()
      var i = 0
      return (
        B.each(n.data, function (n, a) {
          (t = e.data[a]), isNaN(t) || n.hidden || (i += Math.abs(t))
        }),
        i
      )
    },
    calculateCircumference: function (t) {
      const e = this.getMeta().total
      return e > 0 && !isNaN(t) ? Wt * (Math.abs(t) / e) : 0
    },
    getMaxBorderWidth: function (t) {
      let e
      var n
      var i
      var a
      var r
      var o
      var s
      var l
      var u = 0
      var d = this.chart
      if (!t) {
 for (e = 0, n = d.data.datasets.length; e < n; ++e)
        {if (d.isDatasetVisible(e)) {
          (t = (i = d.getDatasetMeta(e)).data),
          e !== this.index && (r = i.controller)
            break;
        }} 
}
      if (!t) return 0
      for (e = 0, n = t.length; e < n; ++e) {
 (a = t[e]),
      r
        ? (r._configure(), (o = r._resolveDataElementOptions(a, e)))
        : (o = a._options),
      'inner' !== o.borderAlign &&
            ((s = o.borderWidth),
            (u = (l = o.hoverBorderWidth) > (u = s > u ? s : u) ? l : u)) }
      return u
    },
    setHoverStyle: function (t) {
      const e = t._model
      var n = t._options
      var i = B.getHoverColor;
      (t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth
      }),
      (e.backgroundColor = Rt(n.hoverBackgroundColor, i(n.backgroundColor))),
      (e.borderColor = Rt(n.hoverBorderColor, i(n.borderColor))),
      (e.borderWidth = Rt(n.hoverBorderWidth, n.borderWidth))
    },
    _getRingWeightOffset: function (t) {
      for (var e = 0, n = 0; n < t; ++n) { this.chart.isDatasetVisible(n) && (e += this._getRingWeight(n)) }
      return e
    },
    _getRingWeight: function (t) {
      return Math.max(Rt(this.chart.data.datasets[t].weight, 1), 0)
    },
    _getVisibleDatasetWeightTotal: function () {
      return this._getRingWeightOffset(this.chart.data.datasets.length)
    }
  })
  Y._set('horizontalBar', {
    hover: { mode: 'index', axis: 'y' },
    scales: {
      xAxes: [{ type: 'linear', position: 'bottom' }],
      yAxes: [
        {
          type: 'category',
          position: 'left',
          offset: !0,
          gridLines: { offsetGridLines: !0 }
        }
      ]
    },
    elements: { rectangle: { borderSkipped: 'left' } },
    tooltips: { mode: 'index', axis: 'y' }
  }),
  Y._set('global', {
    datasets: {
      horizontalBar: { categoryPercentage: 0.8, barPercentage: 0.9 }
    }
  })
  const Et = At.extend({
    _getValueScaleId: function () {
      return this.getMeta().xAxisID
    },
    _getIndexScaleId: function () {
      return this.getMeta().yAxisID
    }
  })
  let Vt = B.valueOrDefault
  let Ht = B.options.resolve
  let Bt = B.canvas._isPointInArea
  function jt (t, e) {
    const n = (t && t.options.ticks) || {}
    let i = n.reverse
    let a = void 0 === n.min ? e : 0
    let r = void 0 === n.max ? e : 0
    return { start: i ? r : a, end: i ? a : r }
  }
  function Ut (t, e, n) {
    const i = n / 2
    let a = jt(t, i)
    let r = jt(e, i)
    return { top: r.end, right: a.end, bottom: r.start, left: a.start }
  }
  function Gt (t) {
    let e, n, i, a
    return (
      B.isObject(t)
        ? ((e = t.top), (n = t.right), (i = t.bottom), (a = t.left))
        : (e = n = i = a = t),
      { top: e, right: n, bottom: i, left: a }
    )
  }
  Y._set('line', {
    showLines: !0,
    spanGaps: !1,
    hover: { mode: 'label' },
    scales: {
      xAxes: [{ type: 'category', id: 'x-axis-0' }],
      yAxes: [{ type: 'linear', id: 'y-axis-0' }]
    }
  })
  const qt = at.extend({
    datasetElementType: kt.Line,
    dataElementType: kt.Point,
    _datasetElementOptions: [
      'backgroundColor',
      'borderCapStyle',
      'borderColor',
      'borderDash',
      'borderDashOffset',
      'borderJoinStyle',
      'borderWidth',
      'cubicInterpolationMode',
      'fill'
    ],
    _dataElementOptions: {
      backgroundColor: 'pointBackgroundColor',
      borderColor: 'pointBorderColor',
      borderWidth: 'pointBorderWidth',
      hitRadius: 'pointHitRadius',
      hoverBackgroundColor: 'pointHoverBackgroundColor',
      hoverBorderColor: 'pointHoverBorderColor',
      hoverBorderWidth: 'pointHoverBorderWidth',
      hoverRadius: 'pointHoverRadius',
      pointStyle: 'pointStyle',
      radius: 'pointRadius',
      rotation: 'pointRotation'
    },
    update: function (t) {
      let e
      var n
      var i = this
      var a = i.getMeta()
      var r = a.dataset
      var o = a.data || []
      var s = i.chart.options
      var l = i._config
      var u = (i._showLine = Vt(l.showLine, s.showLines))
      for (
        i._xScale = i.getScaleForId(a.xAxisID),
        i._yScale = i.getScaleForId(a.yAxisID),
        u &&
              (void 0 !== l.tension &&
                void 0 === l.lineTension &&
                (l.lineTension = l.tension),
              (r._scale = i._yScale),
              (r._datasetIndex = i.index),
              (r._children = o),
              (r._model = i._resolveDatasetElementOptions(r)),
              r.pivot()),
        e = 0,
        n = o.length;
        e < n;
        ++e
      ) { i.updateElement(o[e], e, t) }
      for (
        u && r._model.tension !== 0 && i.updateBezierControlPoints(),
        e = 0,
        n = o.length;
        e < n;
        ++e
      ) { o[e].pivot() }
    },
    updateElement: function (t, e, n) {
      let i
      var a
      var r = this
      var o = r.getMeta()
      var s = t.custom || {}
      var l = r.getDataset()
      var u = r.index
      var d = l.data[e]
      var h = r._xScale
      var c = r._yScale
      var f = o.dataset._model
      var g = r._resolveDataElementOptions(t, e);
      (i = h.getPixelForValue(typeof d === 'object' ? d : NaN, e, u)),
      (a = n ? c.getBasePixel() : r.calculatePointY(d, e, u)),
      (t._xScale = h),
      (t._yScale = c),
      (t._options = g),
      (t._datasetIndex = u),
      (t._index = e),
      (t._model = {
        x: i,
        y: a,
        skip: s.skip || isNaN(i) || isNaN(a),
        radius: g.radius,
        pointStyle: g.pointStyle,
        rotation: g.rotation,
        backgroundColor: g.backgroundColor,
        borderColor: g.borderColor,
        borderWidth: g.borderWidth,
        tension: Vt(s.tension, f ? f.tension : 0),
        steppedLine: !!f && f.steppedLine,
        hitRadius: g.hitRadius
      })
    },
    _resolveDatasetElementOptions: function (t) {
      const e = this
      var n = e._config
      var i = t.custom || {}
      var a = e.chart.options
      var r = a.elements.line
      var o = at.prototype._resolveDatasetElementOptions.apply(e, arguments)
      return (
        (o.spanGaps = Vt(n.spanGaps, a.spanGaps)),
        (o.tension = Vt(n.lineTension, r.tension)),
        (o.steppedLine = Ht([i.steppedLine, n.steppedLine, r.stepped])),
        (o.clip = Gt(Vt(n.clip, Ut(e._xScale, e._yScale, o.borderWidth)))),
        o
      )
    },
    calculatePointY: function (t, e, n) {
      let i
      var a
      var r
      var o
      var s
      var l
      var u
      var d = this.chart
      var h = this._yScale
      var c = 0
      var f = 0
      if (h.options.stacked) {
        for (
          s = +h.getRightValue(t),
          u = (l = d._getSortedVisibleDatasetMetas()).length,
          i = 0;
          i < u && (r = l[i]).index !== n;
          ++i
        ) {
 (a = d.data.datasets[r.index]),
        'line' === r.type &&
                r.yAxisID === h.id &&
                ((o = +h.getRightValue(a.data[e])) < 0
                  ? (f += o || 0)
                  : (c += o || 0)) }
        return s < 0 ? h.getPixelForValue(f + s) : h.getPixelForValue(c + s)
      }
      return h.getPixelForValue(t)
    },
    updateBezierControlPoints: function () {
      let t
      var e
      var n
      var i
      var a = this.chart
      var r = this.getMeta()
      var o = r.dataset._model
      var s = a.chartArea
      var l = r.data || []
      function u (t, e, n) {
        return Math.max(Math.min(t, n), e)
      }
      if (
        (o.spanGaps &&
            (l = l.filter(function (t) {
              return !t._model.skip
            })),
        o.cubicInterpolationMode === 'monotone')
      ) { B.splineCurveMonotone(l) } else {
 for (t = 0, e = l.length; t < e; ++t)
        {(n = l[t]._model),
        (i = B.splineCurve(
          B.previousItem(l, t)._model,
          n,
          B.nextItem(l, t)._model,
          o.tension
        )),
        (n.controlPointPreviousX = i.previous.x),
        (n.controlPointPreviousY = i.previous.y),
        (n.controlPointNextX = i.next.x),
        (n.controlPointNextY = i.next.y)}}
      if (a.options.elements.line.capBezierPoints) {
 for (t = 0, e = l.length; t < e; ++t)
        {(n = l[t]._model),
        Bt(n, s) &&
                (t > 0 &&
                  Bt(l[t - 1]._model, s) &&
                  ((n.controlPointPreviousX = u(
                    n.controlPointPreviousX,
                    s.left,
                    s.right
                  )),
                  (n.controlPointPreviousY = u(
                    n.controlPointPreviousY,
                    s.top,
                    s.bottom
                  ))),
                t < l.length - 1 &&
                  Bt(l[t + 1]._model, s) &&
                  ((n.controlPointNextX = u(
                    n.controlPointNextX,
                    s.left,
                    s.right
                  )),
                  (n.controlPointNextY = u(
                    n.controlPointNextY,
                    s.top,
                    s.bottom
                  ))))}}
    },
    draw: function () {
      let t
      var e = this.chart
      var n = this.getMeta()
      var i = n.data || []
      var a = e.chartArea
      var r = e.canvas
      var o = 0
      var s = i.length
      for (
        this._showLine &&
          ((t = n.dataset._model.clip),
          B.canvas.clipArea(e.ctx, {
            left: !1 === t.left ? 0 : a.left - t.left,
            right: !1 === t.right ? r.width : a.right + t.right,
            top: !1 === t.top ? 0 : a.top - t.top,
            bottom: !1 === t.bottom ? r.height : a.bottom + t.bottom
          }),
          n.dataset.draw(),
          B.canvas.unclipArea(e.ctx));
        o < s;
        ++o
      ) { i[o].draw(a) }
    },
    setHoverStyle: function (t) {
      const e = t._model
      var n = t._options
      var i = B.getHoverColor;
      (t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth,
        radius: e.radius
      }),
      (e.backgroundColor = Vt(
        n.hoverBackgroundColor,
        i(n.backgroundColor)
      )),
      (e.borderColor = Vt(n.hoverBorderColor, i(n.borderColor))),
      (e.borderWidth = Vt(n.hoverBorderWidth, n.borderWidth)),
      (e.radius = Vt(n.hoverRadius, n.radius))
    }
  })
  let Zt = B.options.resolve
  Y._set('polarArea', {
    scale: {
      type: 'radialLinear',
      angleLines: { display: !1 },
      gridLines: { circular: !0 },
      pointLabels: { display: !1 },
      ticks: { beginAtZero: !0 }
    },
    animation: { animateRotate: !0, animateScale: !0 },
    startAngle: -0.5 * Math.PI,
    legendCallback: function (t) {
      let e
      let n
      let i
      let a = document.createElement('ul')
      let r = t.data
      let o = r.datasets
      let s = r.labels
      if ((a.setAttribute('class', t.id + '-legend'), o.length)) {
        for (e = 0, n = o[0].data.length; e < n; ++e) { ((i = a.appendChild(document.createElement('li'))).appendChild(
          document.createElement('span')
        ).style.backgroundColor = o[0].backgroundColor[e]),
        s[e] && i.appendChild(document.createTextNode(s[e])) } }
      return a.outerHTML
    },
    legend: {
      labels: {
        generateLabels: function (t) {
          const e = t.data
          return e.labels.length && e.datasets.length
            ? e.labels.map(function (n, i) {
              const a = t.getDatasetMeta(0)
              let r = a.controller.getStyle(i)
              return {
                text: n,
                fillStyle: r.backgroundColor,
                strokeStyle: r.borderColor,
                lineWidth: r.borderWidth,
                hidden: isNaN(e.datasets[0].data[i]) || a.data[i].hidden,
                index: i
              }
            })
            : []
        }
      },
      onClick: function (t, e) {
        let n
        let i
        let a
        let r = e.index
        let o = this.chart
        for (n = 0, i = (o.data.datasets || []).length; n < i; ++n) { (a = o.getDatasetMeta(n)).data[r].hidden = !a.data[r].hidden }
        o.update()
      }
    },
    tooltips: {
      callbacks: {
        title: function () {
          return ''
        },
        label: function (t, e) {
          return e.labels[t.index] + ': ' + t.yLabel
        }
      }
    }
  })
  const $t = at.extend({
    dataElementType: kt.Arc,
    linkScales: B.noop,
    _dataElementOptions: [
      'backgroundColor',
      'borderColor',
      'borderWidth',
      'borderAlign',
      'hoverBackgroundColor',
      'hoverBorderColor',
      'hoverBorderWidth'
    ],
    _getIndexScaleId: function () {
      return this.chart.scale.id
    },
    _getValueScaleId: function () {
      return this.chart.scale.id
    },
    update: function (t) {
      let e
      var n
      var i
      var a = this
      var r = a.getDataset()
      var o = a.getMeta()
      var s = a.chart.options.startAngle || 0
      var l = (a._starts = [])
      var u = (a._angles = [])
      var d = o.data
      for (
        a._updateRadius(),
        o.count = a.countVisibleElements(),
        e = 0,
        n = r.data.length;
        e < n;
        e++
      ) { (l[e] = s), (i = a._computeAngle(e)), (u[e] = i), (s += i) }
      for (e = 0, n = d.length; e < n; ++e) {
 (d[e]._options = a._resolveDataElementOptions(d[e], e)),
      a.updateElement(d[e], e, t) }
    },
    _updateRadius: function () {
      const t = this
      var e = t.chart
      var n = e.chartArea
      var i = e.options
      var a = Math.min(n.right - n.left, n.bottom - n.top);
      (e.outerRadius = Math.max(a / 2, 0)),
      (e.innerRadius = Math.max(
        i.cutoutPercentage ? (e.outerRadius / 100) * i.cutoutPercentage : 1,
        0
      )),
      (e.radiusLength =
          (e.outerRadius - e.innerRadius) / e.getVisibleDatasetCount()),
      (t.outerRadius = e.outerRadius - e.radiusLength * t.index),
      (t.innerRadius = t.outerRadius - e.radiusLength)
    },
    updateElement: function (t, e, n) {
      const i = this
      var a = i.chart
      var r = i.getDataset()
      var o = a.options
      var s = o.animation
      var l = a.scale
      var u = a.data.labels
      var d = l.xCenter
      var h = l.yCenter
      var c = o.startAngle
      var f = t.hidden ? 0 : l.getDistanceFromCenterForValue(r.data[e])
      var g = i._starts[e]
      var m = g + (t.hidden ? 0 : i._angles[e])
      var p = s.animateScale ? 0 : l.getDistanceFromCenterForValue(r.data[e])
      var v = t._options || {}
      B.extend(t, {
        _datasetIndex: i.index,
        _index: e,
        _scale: l,
        _model: {
          backgroundColor: v.backgroundColor,
          borderColor: v.borderColor,
          borderWidth: v.borderWidth,
          borderAlign: v.borderAlign,
          x: d,
          y: h,
          innerRadius: 0,
          outerRadius: n ? p : f,
          startAngle: n && s.animateRotate ? c : g,
          endAngle: n && s.animateRotate ? c : m,
          label: B.valueAtIndexOrDefault(u, e, u[e])
        }
      }),
      t.pivot()
    },
    countVisibleElements: function () {
      const t = this.getDataset()
      var e = this.getMeta()
      var n = 0
      return (
        B.each(e.data, function (e, i) {
          isNaN(t.data[i]) || e.hidden || n++
        }),
        n
      )
    },
    setHoverStyle: function (t) {
      const e = t._model
      var n = t._options
      var i = B.getHoverColor
      var a = B.valueOrDefault;
      (t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth
      }),
      (e.backgroundColor = a(n.hoverBackgroundColor, i(n.backgroundColor))),
      (e.borderColor = a(n.hoverBorderColor, i(n.borderColor))),
      (e.borderWidth = a(n.hoverBorderWidth, n.borderWidth))
    },
    _computeAngle: function (t) {
      const e = this
      var n = this.getMeta().count
      var i = e.getDataset()
      var a = e.getMeta()
      if (isNaN(i.data[t]) || a.data[t].hidden) return 0
      const r = {
        chart: e.chart,
        dataIndex: t,
        dataset: i,
        datasetIndex: e.index
      }
      return Zt([e.chart.options.elements.arc.angle, (2 * Math.PI) / n], r, t)
    }
  })
  Y._set('pie', B.clone(Y.doughnut)), Y._set('pie', { cutoutPercentage: 0 })
  const Xt = zt
  let Kt = B.valueOrDefault
  Y._set('radar', {
    spanGaps: !1,
    scale: { type: 'radialLinear' },
    elements: { line: { fill: 'start', tension: 0 } }
  })
  const Jt = at.extend({
    datasetElementType: kt.Line,
    dataElementType: kt.Point,
    linkScales: B.noop,
    _datasetElementOptions: [
      'backgroundColor',
      'borderWidth',
      'borderColor',
      'borderCapStyle',
      'borderDash',
      'borderDashOffset',
      'borderJoinStyle',
      'fill'
    ],
    _dataElementOptions: {
      backgroundColor: 'pointBackgroundColor',
      borderColor: 'pointBorderColor',
      borderWidth: 'pointBorderWidth',
      hitRadius: 'pointHitRadius',
      hoverBackgroundColor: 'pointHoverBackgroundColor',
      hoverBorderColor: 'pointHoverBorderColor',
      hoverBorderWidth: 'pointHoverBorderWidth',
      hoverRadius: 'pointHoverRadius',
      pointStyle: 'pointStyle',
      radius: 'pointRadius',
      rotation: 'pointRotation'
    },
    _getIndexScaleId: function () {
      return this.chart.scale.id
    },
    _getValueScaleId: function () {
      return this.chart.scale.id
    },
    update: function (t) {
      let e
      var n
      var i = this
      var a = i.getMeta()
      var r = a.dataset
      var o = a.data || []
      var s = i.chart.scale
      var l = i._config
      for (
        void 0 !== l.tension &&
          void 0 === l.lineTension &&
          (l.lineTension = l.tension),
        r._scale = s,
        r._datasetIndex = i.index,
        r._children = o,
        r._loop = !0,
        r._model = i._resolveDatasetElementOptions(r),
        r.pivot(),
        e = 0,
        n = o.length;
        e < n;
        ++e
      ) { i.updateElement(o[e], e, t) }
      for (i.updateBezierControlPoints(), e = 0, n = o.length; e < n; ++e) { o[e].pivot() }
    },
    updateElement: function (t, e, n) {
      const i = this
      var a = t.custom || {}
      var r = i.getDataset()
      var o = i.chart.scale
      var s = o.getPointPositionForValue(e, r.data[e])
      var l = i._resolveDataElementOptions(t, e)
      var u = i.getMeta().dataset._model
      var d = n ? o.xCenter : s.x
      var h = n ? o.yCenter : s.y;
      (t._scale = o),
      (t._options = l),
      (t._datasetIndex = i.index),
      (t._index = e),
      (t._model = {
        x: d,
        y: h,
        skip: a.skip || isNaN(d) || isNaN(h),
        radius: l.radius,
        pointStyle: l.pointStyle,
        rotation: l.rotation,
        backgroundColor: l.backgroundColor,
        borderColor: l.borderColor,
        borderWidth: l.borderWidth,
        tension: Kt(a.tension, u ? u.tension : 0),
        hitRadius: l.hitRadius
      })
    },
    _resolveDatasetElementOptions: function () {
      const t = this
      var e = t._config
      var n = t.chart.options
      var i = at.prototype._resolveDatasetElementOptions.apply(t, arguments)
      return (
        (i.spanGaps = Kt(e.spanGaps, n.spanGaps)),
        (i.tension = Kt(e.lineTension, n.elements.line.tension)),
        i
      )
    },
    updateBezierControlPoints: function () {
      let t
      var e
      var n
      var i
      var a = this.getMeta()
      var r = this.chart.chartArea
      var o = a.data || []
      function s (t, e, n) {
        return Math.max(Math.min(t, n), e)
      }
      for (
        a.dataset._model.spanGaps &&
          (o = o.filter(function (t) {
            return !t._model.skip
          })),
        t = 0,
        e = o.length;
        t < e;
        ++t
      ) {
 (n = o[t]._model),
      (i = B.splineCurve(
        B.previousItem(o, t, !0)._model,
        n,
        B.nextItem(o, t, !0)._model,
        n.tension
      )),
      (n.controlPointPreviousX = s(i.previous.x, r.left, r.right)),
      (n.controlPointPreviousY = s(i.previous.y, r.top, r.bottom)),
      (n.controlPointNextX = s(i.next.x, r.left, r.right)),
      (n.controlPointNextY = s(i.next.y, r.top, r.bottom)) }
    },
    setHoverStyle: function (t) {
      const e = t._model
      var n = t._options
      var i = B.getHoverColor;
      (t.$previousStyle = {
        backgroundColor: e.backgroundColor,
        borderColor: e.borderColor,
        borderWidth: e.borderWidth,
        radius: e.radius
      }),
      (e.backgroundColor = Kt(n.hoverBackgroundColor, i(n.backgroundColor))),
      (e.borderColor = Kt(n.hoverBorderColor, i(n.borderColor))),
      (e.borderWidth = Kt(n.hoverBorderWidth, n.borderWidth)),
      (e.radius = Kt(n.hoverRadius, n.radius))
    }
  })
  Y._set('scatter', {
    hover: { mode: 'single' },
    scales: {
      xAxes: [{ id: 'x-axis-1', type: 'linear', position: 'bottom' }],
      yAxes: [{ id: 'y-axis-1', type: 'linear', position: 'left' }]
    },
    tooltips: {
      callbacks: {
        title: function () {
          return ''
        },
        label: function (t) {
          return '(' + t.xLabel + ', ' + t.yLabel + ')'
        }
      }
    }
  }),
  Y._set('global', { datasets: { scatter: { showLine: !1 } } })
  const Qt = {
    bar: At,
    bubble: Lt,
    doughnut: zt,
    horizontalBar: Et,
    line: qt,
    polarArea: $t,
    pie: Xt,
    radar: Jt,
    scatter: qt
  }
  function te (t, e) {
    return t.native ? { x: t.x, y: t.y } : B.getRelativePosition(t, e)
  }
  function ee (t, e) {
    let n
    let i
    let a
    let r
    let o
    let s
    let l = t._getSortedVisibleDatasetMetas()
    for (i = 0, r = l.length; i < r; ++i) {
      for (a = 0, o = (n = l[i].data).length; a < o; ++a) { (s = n[a])._view.skip || e(s) } }
  }
  function ne (t, e) {
    const n = []
    return (
      ee(t, function (t) {
        t.inRange(e.x, e.y) && n.push(t)
      }),
      n
    )
  }
  function ie (t, e, n, i) {
    let a = Number.POSITIVE_INFINITY
    let r = []
    return (
      ee(t, function (t) {
        if (!n || t.inRange(e.x, e.y)) {
          const o = t.getCenterPoint()
          let s = i(e, o)
          s < a ? ((r = [t]), (a = s)) : s === a && r.push(t)
        }
      }),
      r
    )
  }
  function ae (t) {
    const e = t.indexOf('x') !== -1
      const n = t.indexOf('y') !== -1
    return function (t, i) {
      const a = e ? Math.abs(t.x - i.x) : 0
      let r = n ? Math.abs(t.y - i.y) : 0
      return Math.sqrt(Math.pow(a, 2) + Math.pow(r, 2))
    }
  }
  function re (t, e, n) {
    const i = te(e, t)
    n.axis = n.axis || 'x'
    const a = ae(n.axis)
    let r = n.intersect ? ne(t, i) : ie(t, i, !1, a)
    let o = []
    return r.length
      ? (t._getSortedVisibleDatasetMetas().forEach(function (t) {
          const e = t.data[r[0]._index]
          e && !e._view.skip && o.push(e)
        }),
        o)
      : []
  }
  const oe = {
    modes: {
      single: function (t, e) {
        const n = te(e, t)
        var i = []
        return (
          ee(t, function (t) {
            if (t.inRange(n.x, n.y)) return i.push(t), i
          }),
          i.slice(0, 1)
        )
      },
      label: re,
      index: re,
      dataset: function (t, e, n) {
        const i = te(e, t)
        n.axis = n.axis || 'xy'
        let a = ae(n.axis)
        var r = n.intersect ? ne(t, i) : ie(t, i, !1, a)
        return (
          r.length > 0 && (r = t.getDatasetMeta(r[0]._datasetIndex).data), r
        )
      },
      'x-axis': function (t, e) {
        return re(t, e, { intersect: !1 })
      },
      point: function (t, e) {
        return ne(t, te(e, t))
      },
      nearest: function (t, e, n) {
        const i = te(e, t)
        n.axis = n.axis || 'xy'
        let a = ae(n.axis)
        return ie(t, i, n.intersect, a)
      },
      x: function (t, e, n) {
        const i = te(e, t)
        var a = []
        var r = !1
        return (
          ee(t, function (t) {
            t.inXRange(i.x) && a.push(t), t.inRange(i.x, i.y) && (r = !0)
          }),
          n.intersect && !r && (a = []),
          a
        )
      },
      y: function (t, e, n) {
        const i = te(e, t)
        var a = []
        var r = !1
        return (
          ee(t, function (t) {
            t.inYRange(i.y) && a.push(t), t.inRange(i.x, i.y) && (r = !0)
          }),
          n.intersect && !r && (a = []),
          a
        )
      }
    }
  }
  let se = B.extend
  function le (t, e) {
    return B.where(t, function (t) {
      return t.pos === e
    })
  }
  function ue (t, e) {
    return t.sort(function (t, n) {
      const i = e ? n : t
      let a = e ? t : n
      return i.weight === a.weight ? i.index - a.index : i.weight - a.weight
    })
  }
  function de (t, e, n, i) {
    return Math.max(t[n], e[n]) + Math.max(t[i], e[i])
  }
  function he (t, e, n) {
    let i
    let a
    let r = n.box
    let o = t.maxPadding
    if (
      (n.size && (t[n.pos] -= n.size),
      (n.size = n.horizontal ? r.height : r.width),
      (t[n.pos] += n.size),
      r.getPadding)
    ) {
      const s = r.getPadding();
      (o.top = Math.max(o.top, s.top)),
      (o.left = Math.max(o.left, s.left)),
      (o.bottom = Math.max(o.bottom, s.bottom)),
      (o.right = Math.max(o.right, s.right))
    }
    if (
      ((i = e.outerWidth - de(o, t, 'left', 'right')),
      (a = e.outerHeight - de(o, t, 'top', 'bottom')),
      i !== t.w || a !== t.h)
    ) {
      (t.w = i), (t.h = a)
      const l = n.horizontal ? [i, t.w] : [a, t.h]
      return !(l[0] === l[1] || (isNaN(l[0]) && isNaN(l[1])))
    }
  }
  function ce (t, e) {
    const n = e.maxPadding
    function i (t) {
      const i = { left: 0, top: 0, right: 0, bottom: 0 }
      return (
        t.forEach(function (t) {
          i[t] = Math.max(e[t], n[t])
        }),
        i
      )
    }
    return i(t ? ['left', 'right'] : ['top', 'bottom'])
  }
  function fe (t, e, n) {
    let i
    let a
    let r
    let o
    let s
    let l
    let u = []
    for (i = 0, a = t.length; i < a; ++i) {
      (o = (r = t[i]).box).update(
        r.width || e.w,
        r.height || e.h,
        ce(r.horizontal, e)
      ),
      he(e, n, r) && ((l = !0), u.length && (s = !0)),
      o.fullWidth || u.push(r) 
}
    return (s && fe(u, e, n)) || l
  }
  function ge (t, e, n) {
    let i
    let a
    let r
    let o
    let s = n.padding
    let l = e.x
    let u = e.y
    for (i = 0, a = t.length; i < a; ++i) {
      (o = (r = t[i]).box),
      r.horizontal
        ? ((o.left = o.fullWidth ? s.left : e.left),
          (o.right = o.fullWidth ? n.outerWidth - s.right : e.left + e.w),
          (o.top = u),
          (o.bottom = u + o.height),
          (o.width = o.right - o.left),
          (u = o.bottom))
        : ((o.left = l),
          (o.right = l + o.width),
          (o.top = e.top),
          (o.bottom = e.top + e.h),
          (o.height = o.bottom - o.top),
          (l = o.right)) 
}
    (e.x = l), (e.y = u)
  }
  Y._set('global', {
    layout: { padding: { top: 0, right: 0, bottom: 0, left: 0 } }
  })
  let me
  let pe = {
    defaults: {},
    addBox: function (t, e) {
      t.boxes || (t.boxes = []),
      (e.fullWidth = e.fullWidth || !1),
      (e.position = e.position || 'top'),
      (e.weight = e.weight || 0),
      (e._layers =
            e._layers ||
            function () {
              return [
                {
                  z: 0,
                  draw: function () {
                    e.draw.apply(e, arguments)
                  }
                }
              ]
            }),
      t.boxes.push(e)
    },
    removeBox: function (t, e) {
      const n = t.boxes ? t.boxes.indexOf(e) : -1;
      n !== -1 && t.boxes.splice(n, 1)
    },
    configure: function (t, e, n) {
      for (
        var i, a = ['fullWidth', 'position', 'weight'], r = a.length, o = 0;
        o < r;
        ++o
      ) { (i = a[o]), n.hasOwnProperty(i) && (e[i] = n[i]) }
    },
    update: function (t, e, n) {
      if (t) {
        const i = t.options.layout || {}
        var a = B.options.toPadding(i.padding)
        var r = e - a.width
        var o = n - a.height
        var s = (function (t) {
          let e = (function (t) {
            var e
                    var n
                    var i
                    var a = []
            for (e = 0, n = (t || []).length; e < n; ++e)
              (i = t[e]),
              a.push({
                index: e,
                box: i,
                pos: i.position,
                horizontal: i.isHorizontal(),
                weight: i.weight
              })
            return a
          })(t)
                var n = ue(le(e, 'left'), !0)
                var i = ue(le(e, 'right'))
                var a = ue(le(e, 'top'), !0)
                var r = ue(le(e, 'bottom'))
          return {
            leftAndTop: n.concat(a),
            rightAndBottom: i.concat(r),
            chartArea: le(e, 'chartArea'),
            vertical: n.concat(i),
            horizontal: a.concat(r)
          }
        })(t.boxes)
        var l = s.vertical
        var u = s.horizontal
        var d = Object.freeze({
          outerWidth: e,
          outerHeight: n,
          padding: a,
          availableWidth: r,
          vBoxMaxWidth: r / 2 / l.length,
          hBoxMaxHeight: o / 2
        })
        var h = se(
          { maxPadding: se({}, a), w: r, h: o, x: a.left, y: a.top },
          a
        )
        !(function (t, e) {
          let n, i, a
          for (n = 0, i = t.length; n < i; ++n) { ((a = t[n]).width = a.horizontal
            ? a.box.fullWidth && e.availableWidth
            : e.vBoxMaxWidth),
          (a.height = a.horizontal && e.hBoxMaxHeight) }
        })(l.concat(u), d),
        fe(l, h, d),
        fe(u, h, d) && fe(l, h, d),
        (function (t) {
          const e = t.maxPadding
          function n (n) {
            const i = Math.max(e[n] - t[n], 0)
            return (t[n] += i), i
          }
          (t.y += n('top')), (t.x += n('left')), n('right'), n('bottom')
        })(h),
        ge(s.leftAndTop, h, d),
        (h.x += h.w),
        (h.y += h.h),
        ge(s.rightAndBottom, h, d),
        (t.chartArea = {
          left: h.left,
          top: h.top,
          right: h.left + h.w,
          bottom: h.top + h.h
        }),
        B.each(s.chartArea, function (e) {
          const n = e.box
          se(n, t.chartArea), n.update(h.w, h.h)
        })
      }
    }
  }
  let ve =
      ((me = Object.freeze({
        __proto__: null,
        default:
          '@keyframes chartjs-render-animation{from{opacity:.99}to{opacity:1}}.chartjs-render-monitor{animation:chartjs-render-animation 1ms}.chartjs-size-monitor,.chartjs-size-monitor-expand,.chartjs-size-monitor-shrink{position:absolute;direction:ltr;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1}.chartjs-size-monitor-expand>div{position:absolute;width:1000000px;height:1000000px;left:0;top:0}.chartjs-size-monitor-shrink>div{position:absolute;width:200%;height:200%;left:0;top:0}'
      })) &&
        me.default) ||
      me
  let be = '$chartjs'
  let ye = 'chartjs-size-monitor'
  let xe = 'chartjs-render-monitor'
  let _e = 'chartjs-render-animation'
  let we = ['animationstart', 'webkitAnimationStart']
  let ke = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout'
  }
  function Me (t, e) {
    const n = B.getStyle(t, e)
    let i = n && n.match(/^(\d+)(\.\d+)?px$/)
    return i ? Number(i[1]) : void 0
  }
  const Se = !!(function () {
    let t = !1
    try {
      const e = Object.defineProperty({}, 'passive', {
        get: function () {
          t = !0
        }
      })
      window.addEventListener('e', null, e)
    } catch (t) {}
    return t
  })() && { passive: !0 }
  function De (t, e, n) {
    t.addEventListener(e, n, Se)
  }
  function Ce (t, e, n) {
    t.removeEventListener(e, n, Se)
  }
  function Pe (t, e, n, i, a) {
    return {
      type: t,
      chart: e,
      native: a || null,
      x: void 0 !== n ? n : null,
      y: void 0 !== i ? i : null
    }
  }
  function Te (t) {
    const e = document.createElement('div')
    return (e.className = t || ''), e
  }
  function Oe (t, e, n) {
    let i
    let a
    let r
    let o
    let s = t[be] || (t[be] = {})
    let l = (s.resizer = (function (t) {
      const e = Te(ye)
      let n = Te(ye + '-expand')
      let i = Te(ye + '-shrink')
      n.appendChild(Te()),
      i.appendChild(Te()),
      e.appendChild(n),
      e.appendChild(i),
      (e._reset = function () {
        (n.scrollLeft = 1e6),
        (n.scrollTop = 1e6),
        (i.scrollLeft = 1e6),
        (i.scrollTop = 1e6)
      })
      const a = function () {
        e._reset(), t()
      }
      return (
        De(n, 'scroll', a.bind(n, 'expand')),
        De(i, 'scroll', a.bind(i, 'shrink')),
        e
      )
    })(
      ((i = function () {
        if (s.resizer) {
          const i = n.options.maintainAspectRatio && t.parentNode
          let a = i ? i.clientWidth : 0
          e(Pe('resize', n)),
          i && i.clientWidth < a && n.canvas && e(Pe('resize', n))
        }
      }),
      (r = !1),
      (o = []),
      function () {
        (o = Array.prototype.slice.call(arguments)),
        (a = a || this),
        r ||
              ((r = !0),
              B.requestAnimFrame.call(window, function () {
                (r = !1), i.apply(a, o)
              }))
      })
    ))
    !(function (t, e) {
      const n = t[be] || (t[be] = {})
      let i = (n.renderProxy = function (t) {
        t.animationName === _e && e()
      })
      B.each(we, function (e) {
        De(t, e, i)
      }),
      (n.reflow = !!t.offsetParent),
      t.classList.add(xe)
    })(t, function () {
      if (s.resizer) {
        const e = t.parentNode
        e && e !== l.parentNode && e.insertBefore(l, e.firstChild), l._reset()
      }
    })
  }
  function Ae (t) {
    const e = t[be] || {}
    let n = e.resizer
    delete e.resizer,
    (function (t) {
      const e = t[be] || {}
      let n = e.renderProxy
      n &&
          (B.each(we, function (e) {
            Ce(t, e, n)
          }),
          delete e.renderProxy),
      t.classList.remove(xe)
    })(t),
    n && n.parentNode && n.parentNode.removeChild(n)
  }
  const Fe = {
    disableCSSInjection: !1,
    _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',
    _ensureLoaded: function (t) {
      if (!this.disableCSSInjection) {
        const e = t.getRootNode ? t.getRootNode() : document
        !(function (t, e) {
          const n = t[be] || (t[be] = {})
          if (!n.containsStyles) {
            (n.containsStyles = !0), (e = '/* Chart.js */\n' + e)
            const i = document.createElement('style')
            i.setAttribute('type', 'text/css'),
            i.appendChild(document.createTextNode(e)),
            t.appendChild(i)
          }
        })(e.host ? e : document.head, ve)
      }
    },
    acquireContext: function (t, e) {
      typeof t === 'string'
        ? (t = document.getElementById(t))
        : t.length && (t = t[0]),
      t && t.canvas && (t = t.canvas)
      const n = t && t.getContext && t.getContext('2d')
      return n && n.canvas === t
        ? (this._ensureLoaded(t),
          (function (t, e) {
            const n = t.style
            var i = t.getAttribute('height')
            var a = t.getAttribute('width')
            if (
              ((t[be] = {
                initial: {
                  height: i,
                  width: a,
                  style: {
                    display: n.display,
                    height: n.height,
                    width: n.width
                  }
                }
              }),
              (n.display = n.display || 'block'),
              a === null || a === '')
            ) {
              var r = Me(t, 'width')
              void 0 !== r && (t.width = r)
            }
            if (i === null || i === '') {
 if (t.style.height === '')
              {t.height = t.width / (e.options.aspectRatio || 2)}
            else {
              let o = Me(t, 'height')
              void 0 !== r && (t.height = o)
            } }
          })(t, e),
          n)
        : null
    },
    releaseContext: function (t) {
      const e = t.canvas
      if (e[be]) {
        const n = e[be].initial;
        ['height', 'width'].forEach(function (t) {
          const i = n[t]
          B.isNullOrUndef(i) ? e.removeAttribute(t) : e.setAttribute(t, i)
        }),
        B.each(n.style || {}, function (t, n) {
          e.style[n] = t
        }),
        (e.width = e.width),
        delete e[be]
      }
    },
    addEventListener: function (t, e, n) {
      const i = t.canvas
      if (e !== 'resize') {
        const a = n[be] || (n[be] = {})
        De(
          i,
          e,
          ((a.proxies || (a.proxies = {}))[t.id + '_' + e] = function (e) {
            n(
              (function (t, e) {
                const n = ke[t.type] || t.type
                var i = B.getRelativePosition(t, e)
                return Pe(n, e, i.x, i.y, t)
              })(e, t)
            )
          })
        )
      } else Oe(i, n, t)
    },
    removeEventListener: function (t, e, n) {
      const i = t.canvas
      if (e !== 'resize') {
        const a = ((n[be] || {}).proxies || {})[t.id + '_' + e]
        a && Ce(i, e, a)
      } else Ae(i)
    }
  };
  (B.addEvent = De), (B.removeEvent = Ce)
  const Ie = Fe._enabled
    ? Fe
    : {
        acquireContext: function (t) {
          return (
            t && t.canvas && (t = t.canvas), (t && t.getContext('2d')) || null
          )
        }
      }
  let Le = B.extend(
    {
      initialize: function () {},
      acquireContext: function () {},
      releaseContext: function () {},
      addEventListener: function () {},
      removeEventListener: function () {}
    },
    Ie
  )
  Y._set('global', { plugins: {} })
  const Re = {
    _plugins: [],
    _cacheId: 0,
    register: function (t) {
      const e = this._plugins;
      [].concat(t).forEach(function (t) {
        e.indexOf(t) === -1 && e.push(t)
      }),
      this._cacheId++
    },
    unregister: function (t) {
      const e = this._plugins;
      [].concat(t).forEach(function (t) {
        const n = e.indexOf(t)
        n !== -1 && e.splice(n, 1)
      }),
      this._cacheId++
    },
    clear: function () {
      (this._plugins = []), this._cacheId++
    },
    count: function () {
      return this._plugins.length
    },
    getAll: function () {
      return this._plugins
    },
    notify: function (t, e, n) {
      let i
      var a
      var r
      var o
      var s
      var l = this.descriptors(t)
      var u = l.length
      for (i = 0; i < u; ++i) {
 if (
        'function' === typeof (s = (r = (a = l[i]).plugin)[e]) &&
            ((o = [t].concat(n || [])).push(a.options), !1 === s.apply(r, o))
      )
        {return !1}}
      return !0
    },
    descriptors: function (t) {
      const e = t.$plugins || (t.$plugins = {})
      if (e.id === this._cacheId) return e.descriptors
      let n = []
      var i = []
      var a = (t && t.config) || {}
      var r = (a.options && a.options.plugins) || {}
      return (
        this._plugins.concat(a.plugins || []).forEach(function (t) {
          if (n.indexOf(t) === -1) {
            const e = t.id
            var a = r[e]
            !1 !== a &&
                (!0 === a && (a = B.clone(Y.global.plugins[e])),
                n.push(t),
                i.push({ plugin: t, options: a || {} }))
          }
        }),
        (e.descriptors = i),
        (e.id = this._cacheId),
        i
      )
    },
    _invalidate: function (t) {
      delete t.$plugins
    }
  }
  let Ne = {
    constructors: {},
    defaults: {},
    registerScaleType: function (t, e, n) {
      (this.constructors[t] = e), (this.defaults[t] = B.clone(n))
    },
    getScaleConstructor: function (t) {
      return this.constructors.hasOwnProperty(t)
        ? this.constructors[t]
        : void 0
    },
    getScaleDefaults: function (t) {
      return this.defaults.hasOwnProperty(t)
        ? B.merge(Object.create(null), [Y.scale, this.defaults[t]])
        : {}
    },
    updateScaleDefaults: function (t, e) {
      this.defaults.hasOwnProperty(t) &&
          (this.defaults[t] = B.extend(this.defaults[t], e))
    },
    addScalesToLayout: function (t) {
      B.each(t.scales, function (e) {
        (e.fullWidth = e.options.fullWidth),
        (e.position = e.options.position),
        (e.weight = e.options.weight),
        pe.addBox(t, e)
      })
    }
  }
  let We = B.valueOrDefault
  let Ye = B.rtl.getRtlAdapter
  Y._set('global', {
    tooltips: {
      enabled: !0,
      custom: null,
      mode: 'nearest',
      position: 'average',
      intersect: !0,
      backgroundColor: 'rgba(0,0,0,0.8)',
      titleFontStyle: 'bold',
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleFontColor: '#fff',
      titleAlign: 'left',
      bodySpacing: 2,
      bodyFontColor: '#fff',
      bodyAlign: 'left',
      footerFontStyle: 'bold',
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFontColor: '#fff',
      footerAlign: 'left',
      yPadding: 6,
      xPadding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      multiKeyBackground: '#fff',
      displayColors: !0,
      borderColor: 'rgba(0,0,0,0)',
      borderWidth: 0,
      callbacks: {
        beforeTitle: B.noop,
        title: function (t, e) {
          let n = ''
          let i = e.labels
          let a = i ? i.length : 0
          if (t.length > 0) {
            const r = t[0]
            r.label
              ? (n = r.label)
              : r.xLabel
                ? (n = r.xLabel)
                : a > 0 && r.index < a && (n = i[r.index])
          }
          return n
        },
        afterTitle: B.noop,
        beforeBody: B.noop,
        beforeLabel: B.noop,
        label: function (t, e) {
          let n = e.datasets[t.datasetIndex].label || ''
          return (
            n && (n += ': '),
            B.isNullOrUndef(t.value) ? (n += t.yLabel) : (n += t.value),
            n
          )
        },
        labelColor: function (t, e) {
          const n = e.getDatasetMeta(t.datasetIndex).data[t.index]._view
          return {
            borderColor: n.borderColor,
            backgroundColor: n.backgroundColor
          }
        },
        labelTextColor: function () {
          return this._options.bodyFontColor
        },
        afterLabel: B.noop,
        afterBody: B.noop,
        beforeFooter: B.noop,
        footer: B.noop,
        afterFooter: B.noop
      }
    }
  })
  const ze = {
    average: function (t) {
      if (!t.length) return !1
      let e
      var n
      var i = 0
      var a = 0
      var r = 0
      for (e = 0, n = t.length; e < n; ++e) {
        const o = t[e]
        if (o && o.hasValue()) {
          const s = o.tooltipPosition();
          (i += s.x), (a += s.y), ++r
        }
      }
      return { x: i / r, y: a / r }
    },
    nearest: function (t, e) {
      let n
      var i
      var a
      var r = e.x
      var o = e.y
      var s = Number.POSITIVE_INFINITY
      for (n = 0, i = t.length; n < i; ++n) {
        const l = t[n]
        if (l && l.hasValue()) {
          const u = l.getCenterPoint()
          var d = B.distanceBetweenPoints(e, u)
          d < s && ((s = d), (a = l))
        }
      }
      if (a) {
        const h = a.tooltipPosition();
        (r = h.x), (o = h.y)
      }
      return { x: r, y: o }
    }
  }
  function Ee (t, e) {
    return (
      e && (B.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
    )
  }
  function Ve (t) {
    return (typeof t === 'string' || t instanceof String) && t.indexOf('\n') > -1
      ? t.split('\n')
      : t
  }
  function He (t) {
    const e = Y.global
    return {
      xPadding: t.xPadding,
      yPadding: t.yPadding,
      xAlign: t.xAlign,
      yAlign: t.yAlign,
      rtl: t.rtl,
      textDirection: t.textDirection,
      bodyFontColor: t.bodyFontColor,
      _bodyFontFamily: We(t.bodyFontFamily, e.defaultFontFamily),
      _bodyFontStyle: We(t.bodyFontStyle, e.defaultFontStyle),
      _bodyAlign: t.bodyAlign,
      bodyFontSize: We(t.bodyFontSize, e.defaultFontSize),
      bodySpacing: t.bodySpacing,
      titleFontColor: t.titleFontColor,
      _titleFontFamily: We(t.titleFontFamily, e.defaultFontFamily),
      _titleFontStyle: We(t.titleFontStyle, e.defaultFontStyle),
      titleFontSize: We(t.titleFontSize, e.defaultFontSize),
      _titleAlign: t.titleAlign,
      titleSpacing: t.titleSpacing,
      titleMarginBottom: t.titleMarginBottom,
      footerFontColor: t.footerFontColor,
      _footerFontFamily: We(t.footerFontFamily, e.defaultFontFamily),
      _footerFontStyle: We(t.footerFontStyle, e.defaultFontStyle),
      footerFontSize: We(t.footerFontSize, e.defaultFontSize),
      _footerAlign: t.footerAlign,
      footerSpacing: t.footerSpacing,
      footerMarginTop: t.footerMarginTop,
      caretSize: t.caretSize,
      cornerRadius: t.cornerRadius,
      backgroundColor: t.backgroundColor,
      opacity: 0,
      legendColorBackground: t.multiKeyBackground,
      displayColors: t.displayColors,
      borderColor: t.borderColor,
      borderWidth: t.borderWidth
    }
  }
  function Be (t, e) {
    return e === 'center'
      ? t.x + t.width / 2
      : e === 'right'
        ? t.x + t.width - t.xPadding
        : t.x + t.xPadding
  }
  function je (t) {
    return Ee([], Ve(t))
  }
  const Ue = X.extend({
    initialize: function () {
      (this._model = He(this._options)), (this._lastActive = [])
    },
    getTitle: function () {
      const t = this
      var e = t._options
      var n = e.callbacks
      var i = n.beforeTitle.apply(t, arguments)
      var a = n.title.apply(t, arguments)
      var r = n.afterTitle.apply(t, arguments)
      var o = []
      return (o = Ee(o, Ve(i))), (o = Ee(o, Ve(a))), (o = Ee(o, Ve(r)))
    },
    getBeforeBody: function () {
      return je(this._options.callbacks.beforeBody.apply(this, arguments))
    },
    getBody: function (t, e) {
      const n = this
      var i = n._options.callbacks
      var a = []
      return (
        B.each(t, function (t) {
          const r = { before: [], lines: [], after: [] }
          Ee(r.before, Ve(i.beforeLabel.call(n, t, e))),
          Ee(r.lines, i.label.call(n, t, e)),
          Ee(r.after, Ve(i.afterLabel.call(n, t, e))),
          a.push(r)
        }),
        a
      )
    },
    getAfterBody: function () {
      return je(this._options.callbacks.afterBody.apply(this, arguments))
    },
    getFooter: function () {
      const t = this
      var e = t._options.callbacks
      var n = e.beforeFooter.apply(t, arguments)
      var i = e.footer.apply(t, arguments)
      var a = e.afterFooter.apply(t, arguments)
      var r = []
      return (r = Ee(r, Ve(n))), (r = Ee(r, Ve(i))), (r = Ee(r, Ve(a)))
    },
    update: function (t) {
      let e
      var n
      var i
      var a
      var r
      var o
      var s
      var l
      var u
      var d
      var h = this
      var c = h._options
      var f = h._model
      var g = (h._model = He(c))
      var m = h._active
      var p = h._data
      var v = { xAlign: f.xAlign, yAlign: f.yAlign }
      var b = { x: f.x, y: f.y }
      var y = { width: f.width, height: f.height }
      var x = { x: f.caretX, y: f.caretY }
      if (m.length) {
        g.opacity = 1
        let _ = []
        var w = []
        x = ze[c.position].call(h, m, h._eventPosition)
        let k = []
        for (e = 0, n = m.length; e < n; ++e) {
 k.push(
          ((i = m[e]),
          (a = void 0),
          (r = void 0),
          (o = void 0),
          (s = void 0),
          (l = void 0),
          (u = void 0),
          (d = void 0),
          (a = i._xScale),
          (r = i._yScale || i._scale),
          (o = i._index),
          (s = i._datasetIndex),
          (l = i._chart.getDatasetMeta(s).controller),
          (u = l._getIndexScale()),
          (d = l._getValueScale()),
          {
            xLabel: a ? a.getLabelForIndex(o, s) : '',
            yLabel: r ? r.getLabelForIndex(o, s) : '',
            label: u ? '' + u.getLabelForIndex(o, s) : '',
            value: d ? '' + d.getLabelForIndex(o, s) : '',
            index: o,
            datasetIndex: s,
            x: i._model.x,
            y: i._model.y
          })
        ) }
        c.filter &&
            (k = k.filter(function (t) {
              return c.filter(t, p)
            })),
        c.itemSort &&
              (k = k.sort(function (t, e) {
                return c.itemSort(t, e, p)
              })),
        B.each(k, function (t) {
          _.push(c.callbacks.labelColor.call(h, t, h._chart)),
          w.push(c.callbacks.labelTextColor.call(h, t, h._chart))
        }),
        (g.title = h.getTitle(k, p)),
        (g.beforeBody = h.getBeforeBody(k, p)),
        (g.body = h.getBody(k, p)),
        (g.afterBody = h.getAfterBody(k, p)),
        (g.footer = h.getFooter(k, p)),
        (g.x = x.x),
        (g.y = x.y),
        (g.caretPadding = c.caretPadding),
        (g.labelColors = _),
        (g.labelTextColors = w),
        (g.dataPoints = k),
        (y = (function (t, e) {
          let n = t._chart.ctx
          var i = 2 * e.yPadding
          var a = 0
          var r = e.body
          var o = r.reduce(function (t, e) {
            return t + e.before.length + e.lines.length + e.after.length
          }, 0)
          o += e.beforeBody.length + e.afterBody.length
          let s = e.title.length
          var l = e.footer.length
          var u = e.titleFontSize
          var d = e.bodyFontSize
          var h = e.footerFontSize;
          (i += s * u),
          (i += s ? (s - 1) * e.titleSpacing : 0),
          (i += s ? e.titleMarginBottom : 0),
          (i += o * d),
          (i += o ? (o - 1) * e.bodySpacing : 0),
          (i += l ? e.footerMarginTop : 0),
          (i += l * h),
          (i += l ? (l - 1) * e.footerSpacing : 0)
          let c = 0
          var f = function (t) {
            a = Math.max(a, n.measureText(t).width + c)
          }
          return (
            (n.font = B.fontString(
              u,
              e._titleFontStyle,
              e._titleFontFamily
            )),
            B.each(e.title, f),
            (n.font = B.fontString(d, e._bodyFontStyle, e._bodyFontFamily)),
            B.each(e.beforeBody.concat(e.afterBody), f),
            (c = e.displayColors ? d + 2 : 0),
            B.each(r, function (t) {
              B.each(t.before, f), B.each(t.lines, f), B.each(t.after, f)
            }),
            (c = 0),
            (n.font = B.fontString(
              h,
              e._footerFontStyle,
              e._footerFontFamily
            )),
            B.each(e.footer, f),
            { width: (a += 2 * e.xPadding), height: i }
          )
        })(this, g)),
        (b = (function (t, e, n, i) {
          let a = t.x
          var r = t.y
          var o = t.caretSize
          var s = t.caretPadding
          var l = t.cornerRadius
          var u = n.xAlign
          var d = n.yAlign
          var h = o + s
          var c = l + s
          return (
            'right' === u
              ? (a -= e.width)
              : u === 'center' &&
                    ((a -= e.width / 2) + e.width > i.width &&
                      (a = i.width - e.width),
                    a < 0 && (a = 0)),
            'top' === d
              ? (r += h)
              : (r -= d === 'bottom' ? e.height + h : e.height / 2),
            'center' === d
              ? u === 'left'
                ? (a += h)
                : u === 'right' && (a -= h)
              : u === 'left'
                ? (a -= c)
                : u === 'right' && (a += c),
            { x: a, y: r }
          )
        })(
          g,
          y,
          (v = (function (t, e) {
            let n
            var i
            var a
            var r
            var o
            var s = t._model
            var l = t._chart
            var u = t._chart.chartArea
            var d = 'center'
            var h = 'center'
            s.y < e.height
              ? (h = 'top')
              : s.y > l.height - e.height && (h = 'bottom')
            var c = (u.left + u.right) / 2
            var f = (u.top + u.bottom) / 2
            'center' === h
              ? ((n = function (t) {
                  return t <= c
                }),
                (i = function (t) {
                  return t > c
                }))
              : ((n = function (t) {
                  return t <= e.width / 2
                }),
                (i = function (t) {
                  return t >= l.width - e.width / 2
                })),
            (a = function (t) {
              return t + e.width + s.caretSize + s.caretPadding > l.width
            }),
            (r = function (t) {
              return t - e.width - s.caretSize - s.caretPadding < 0
            }),
            (o = function (t) {
              return t <= f ? 'top' : 'bottom'
            }),
            n(s.x)
              ? ((d = 'left'), a(s.x) && ((d = 'center'), (h = o(s.y))))
              : i(s.x) &&
                      ((d = 'right'), r(s.x) && ((d = 'center'), (h = o(s.y))))
            let g = t._options
            return {
              xAlign: g.xAlign ? g.xAlign : d,
              yAlign: g.yAlign ? g.yAlign : h
            }
          })(this, y)),
          h._chart
        ))
      } else g.opacity = 0
      return (
        (g.xAlign = v.xAlign),
        (g.yAlign = v.yAlign),
        (g.x = b.x),
        (g.y = b.y),
        (g.width = y.width),
        (g.height = y.height),
        (g.caretX = x.x),
        (g.caretY = x.y),
        (h._model = g),
        t && c.custom && c.custom.call(h, g),
        h
      )
    },
    drawCaret: function (t, e) {
      const n = this._chart.ctx
      var i = this._view
      var a = this.getCaretPosition(t, e, i)
      n.lineTo(a.x1, a.y1), n.lineTo(a.x2, a.y2), n.lineTo(a.x3, a.y3)
    },
    getCaretPosition: function (t, e, n) {
      let i
      var a
      var r
      var o
      var s
      var l
      var u = n.caretSize
      var d = n.cornerRadius
      var h = n.xAlign
      var c = n.yAlign
      var f = t.x
      var g = t.y
      var m = e.width
      var p = e.height
      if (c === 'center') {
 (s = g + p / 2),
      'left' === h
        ? ((a = (i = f) - u), (r = i), (o = s + u), (l = s - u))
        : ((a = (i = f + m) + u), (r = i), (o = s - u), (l = s + u)) } else if (
        (h === 'left'
          ? ((i = (a = f + d + u) - u), (r = a + u))
          : h === 'right'
            ? ((i = (a = f + m - d - u) - u), (r = a + u))
            : ((i = (a = n.caretX) - u), (r = a + u)),
        c === 'top')
      ) { (s = (o = g) - u), (l = o) } else {
        (s = (o = g + p) + u), (l = o)
        let v = r;
        (r = i), (i = v)
      }
      return { x1: i, x2: a, x3: r, y1: o, y2: s, y3: l }
    },
    drawTitle: function (t, e, n) {
      let i
      var a
      var r
      var o = e.title
      var s = o.length
      if (s) {
        const l = Ye(e.rtl, e.x, e.width)
        for (
          t.x = Be(e, e._titleAlign),
          n.textAlign = l.textAlign(e._titleAlign),
          n.textBaseline = 'middle',
          i = e.titleFontSize,
          a = e.titleSpacing,
          n.fillStyle = e.titleFontColor,
          n.font = B.fontString(i, e._titleFontStyle, e._titleFontFamily),
          r = 0;
          r < s;
          ++r
        ) {
 n.fillText(o[r], l.x(t.x), t.y + i / 2),
        (t.y += i + a),
        r + 1 === s && (t.y += e.titleMarginBottom - a) }
      }
    },
    drawBody: function (t, e, n) {
      let i
      var a
      var r
      var o
      var s
      var l
      var u
      var d
      var h = e.bodyFontSize
      var c = e.bodySpacing
      var f = e._bodyAlign
      var g = e.body
      var m = e.displayColors
      var p = 0
      var v = m ? Be(e, 'left') : 0
      var b = Ye(e.rtl, e.x, e.width)
      var y = function (e) {
        n.fillText(e, b.x(t.x + p), t.y + h / 2), (t.y += h + c)
      };
      let x = b.textAlign(f)
      for (
        n.textAlign = f,
        n.textBaseline = 'middle',
        n.font = B.fontString(h, e._bodyFontStyle, e._bodyFontFamily),
        t.x = Be(e, x),
        n.fillStyle = e.bodyFontColor,
        B.each(e.beforeBody, y),
        p = m && x !== 'right' ? (f === 'center' ? h / 2 + 1 : h + 2) : 0,
        s = 0,
        u = g.length;
        s < u;
        ++s
      ) {
        for (
          i = g[s],
          a = e.labelTextColors[s],
          r = e.labelColors[s],
          n.fillStyle = a,
          B.each(i.before, y),
          l = 0,
          d = (o = i.lines).length;
          l < d;
          ++l
        ) {
          if (m) {
            const _ = b.x(v);
            (n.fillStyle = e.legendColorBackground),
            n.fillRect(b.leftForLtr(_, h), t.y, h, h),
            (n.lineWidth = 1),
            (n.strokeStyle = r.borderColor),
            n.strokeRect(b.leftForLtr(_, h), t.y, h, h),
            (n.fillStyle = r.backgroundColor),
            n.fillRect(
              b.leftForLtr(b.xPlus(_, 1), h - 2),
              t.y + 1,
              h - 2,
              h - 2
            ),
            (n.fillStyle = a)
          }
          y(o[l])
        }
        B.each(i.after, y)
      }
      (p = 0), B.each(e.afterBody, y), (t.y -= c)
    },
    drawFooter: function (t, e, n) {
      let i
      var a
      var r = e.footer
      var o = r.length
      if (o) {
        const s = Ye(e.rtl, e.x, e.width)
        for (
          t.x = Be(e, e._footerAlign),
          t.y += e.footerMarginTop,
          n.textAlign = s.textAlign(e._footerAlign),
          n.textBaseline = 'middle',
          i = e.footerFontSize,
          n.fillStyle = e.footerFontColor,
          n.font = B.fontString(i, e._footerFontStyle, e._footerFontFamily),
          a = 0;
          a < o;
          ++a
        ) {
 n.fillText(r[a], s.x(t.x), t.y + i / 2),
        (t.y += i + e.footerSpacing) }
      }
    },
    drawBackground: function (t, e, n, i) {
      (n.fillStyle = e.backgroundColor),
      (n.strokeStyle = e.borderColor),
      (n.lineWidth = e.borderWidth)
      let a = e.xAlign
      var r = e.yAlign
      var o = t.x
      var s = t.y
      var l = i.width
      var u = i.height
      var d = e.cornerRadius
      n.beginPath(),
      n.moveTo(o + d, s),
      'top' === r && this.drawCaret(t, i),
      n.lineTo(o + l - d, s),
      n.quadraticCurveTo(o + l, s, o + l, s + d),
      'center' === r && a === 'right' && this.drawCaret(t, i),
      n.lineTo(o + l, s + u - d),
      n.quadraticCurveTo(o + l, s + u, o + l - d, s + u),
      'bottom' === r && this.drawCaret(t, i),
      n.lineTo(o + d, s + u),
      n.quadraticCurveTo(o, s + u, o, s + u - d),
      'center' === r && a === 'left' && this.drawCaret(t, i),
      n.lineTo(o, s + d),
      n.quadraticCurveTo(o, s, o + d, s),
      n.closePath(),
      n.fill(),
      e.borderWidth > 0 && n.stroke()
    },
    draw: function () {
      const t = this._chart.ctx
      var e = this._view
      if (e.opacity !== 0) {
        const n = { width: e.width, height: e.height }
        var i = { x: e.x, y: e.y }
        var a = Math.abs(e.opacity < 0.001) ? 0 : e.opacity
        var r =
              e.title.length ||
              e.beforeBody.length ||
              e.body.length ||
              e.afterBody.length ||
              e.footer.length
        this._options.enabled &&
            r &&
            (t.save(),
            (t.globalAlpha = a),
            this.drawBackground(i, e, t, n),
            (i.y += e.yPadding),
            B.rtl.overrideTextDirection(t, e.textDirection),
            this.drawTitle(i, e, t),
            this.drawBody(i, e, t),
            this.drawFooter(i, e, t),
            B.rtl.restoreTextDirection(t, e.textDirection),
            t.restore())
      }
    },
    handleEvent: function (t) {
      let e
      var n = this
      var i = n._options
      return (
        (n._lastActive = n._lastActive || []),
        t.type === 'mouseout'
          ? (n._active = [])
          : ((n._active = n._chart.getElementsAtEventForMode(t, i.mode, i)),
            i.reverse && n._active.reverse()),
        (e = !B.arrayEquals(n._active, n._lastActive)) &&
            ((n._lastActive = n._active),
            (i.enabled || i.custom) &&
              ((n._eventPosition = { x: t.x, y: t.y }),
              n.update(!0),
              n.pivot())),
        e
      )
    }
  })
  let Ge = ze
  let qe = Ue
  qe.positioners = Ge
  const Ze = B.valueOrDefault
  function $e () {
    return B.merge(Object.create(null), [].slice.call(arguments), {
      merger: function (t, e, n, i) {
        if (t === 'xAxes' || t === 'yAxes') {
          let a
          let r
          let o
          let s = n[t].length
          for (e[t] || (e[t] = []), a = 0; a < s; ++a) {
            (o = n[t][a]),
            (r = Ze(o.type, t === 'xAxes' ? 'category' : 'linear')),
            a >= e[t].length && e[t].push({}),
            !e[t][a].type || (o.type && o.type !== e[t][a].type)
              ? B.merge(e[t][a], [Ne.getScaleDefaults(r), o])
              : B.merge(e[t][a], o) 
}
        } else B._merger(t, e, n, i)
      }
    })
  }
  function Xe () {
    return B.merge(Object.create(null), [].slice.call(arguments), {
      merger: function (t, e, n, i) {
        const a = e[t] || Object.create(null)
        let r = n[t]
        t === 'scales'
          ? (e[t] = $e(a, r))
          : t === 'scale'
            ? (e[t] = B.merge(a, [Ne.getScaleDefaults(r.type), r]))
            : B._merger(t, e, n, i)
      }
    })
  }
  function Ke (t) {
    let e = t.options
    B.each(t.scales, function (e) {
      pe.removeBox(t, e)
    }),
    (e = Xe(Y.global, Y[t.config.type], e)),
    (t.options = t.config.options = e),
    t.ensureScalesHaveIDs(),
    t.buildOrUpdateScales(),
    (t.tooltip._options = e.tooltips),
    t.tooltip.initialize()
  }
  function Je (t, e, n) {
    let i
    let a = function (t) {
      return t.id === i
    }
    do {
      i = e + n++
    } while (B.findIndex(t, a) >= 0)
    return i
  }
  function Qe (t) {
    return t === 'top' || t === 'bottom'
  }
  function tn (t, e) {
    return function (n, i) {
      return n[t] === i[t] ? n[e] - i[e] : n[t] - i[t]
    }
  }
  Y._set('global', {
    elements: {},
    events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
    hover: {
      onHover: null,
      mode: 'nearest',
      intersect: !0,
      animationDuration: 400
    },
    onClick: null,
    maintainAspectRatio: !0,
    responsive: !0,
    responsiveAnimationDuration: 0
  })
  const en = function (t, e) {
    return this.construct(t, e), this
  }
  B.extend(en.prototype, {
    construct: function (t, e) {
      const n = this
      e = (function (t) {
        const e = ((t = t || Object.create(null)).data = t.data || {})
        return (
          (e.datasets = e.datasets || []),
          (e.labels = e.labels || []),
          (t.options = Xe(Y.global, Y[t.type], t.options || {})),
          t
        )
      })(e)
      const i = Le.acquireContext(t, e)
      let a = i && i.canvas
      let r = a && a.height
      let o = a && a.width;
      (n.id = B.uid()),
      (n.ctx = i),
      (n.canvas = a),
      (n.config = e),
      (n.width = o),
      (n.height = r),
      (n.aspectRatio = r ? o / r : null),
      (n.options = e.options),
      (n._bufferedRender = !1),
      (n._layers = []),
      (n.chart = n),
      (n.controller = n),
      (en.instances[n.id] = n),
      Object.defineProperty(n, 'data', {
        get: function () {
          return n.config.data
        },
        set: function (t) {
          n.config.data = t
        }
      }),
      i && a
        ? (n.initialize(), n.update())
        : console.error(
          "Failed to create chart: can't acquire context from the given item"
        )
    },
    initialize: function () {
      const t = this
      return (
        Re.notify(t, 'beforeInit'),
        B.retinaScale(t, t.options.devicePixelRatio),
        t.bindEvents(),
        t.options.responsive && t.resize(!0),
        t.initToolTip(),
        Re.notify(t, 'afterInit'),
        t
      )
    },
    clear: function () {
      return B.canvas.clear(this), this
    },
    stop: function () {
      return Q.cancelAnimation(this), this
    },
    resize: function (t) {
      const e = this
      let n = e.options
      let i = e.canvas
      let a = (n.maintainAspectRatio && e.aspectRatio) || null
      let r = Math.max(0, Math.floor(B.getMaximumWidth(i)))
      let o = Math.max(0, Math.floor(a ? r / a : B.getMaximumHeight(i)))
      if (
        (e.width !== r || e.height !== o) &&
        ((i.width = e.width = r),
        (i.height = e.height = o),
        (i.style.width = r + 'px'),
        (i.style.height = o + 'px'),
        B.retinaScale(e, n.devicePixelRatio),
        !t)
      ) {
        const s = { width: r, height: o }
        Re.notify(e, 'resize', [s]),
        n.onResize && n.onResize(e, s),
        e.stop(),
        e.update({ duration: n.responsiveAnimationDuration })
      }
    },
    ensureScalesHaveIDs: function () {
      const t = this.options
      let e = t.scales || {}
      let n = t.scale
      B.each(e.xAxes, function (t, n) {
        t.id || (t.id = Je(e.xAxes, 'x-axis-', n))
      }),
      B.each(e.yAxes, function (t, n) {
        t.id || (t.id = Je(e.yAxes, 'y-axis-', n))
      }),
      n && (n.id = n.id || 'scale')
    },
    buildOrUpdateScales: function () {
      const t = this
      let e = t.options
      let n = t.scales || {}
      let i = []
      let a = Object.keys(n).reduce(function (t, e) {
        return (t[e] = !1), t
      }, {})
      e.scales &&
        (i = i.concat(
          (e.scales.xAxes || []).map(function (t) {
            return { options: t, dtype: 'category', dposition: 'bottom' }
          }),
          (e.scales.yAxes || []).map(function (t) {
            return { options: t, dtype: 'linear', dposition: 'left' }
          })
        )),
      e.scale &&
          i.push({
            options: e.scale,
            dtype: 'radialLinear',
            isDefault: !0,
            dposition: 'chartArea'
          }),
      B.each(i, function (e) {
        const i = e.options
        let r = i.id
        let o = Ze(i.type, e.dtype)
        Qe(i.position) !== Qe(e.dposition) && (i.position = e.dposition),
        (a[r] = !0)
        let s = null
        if (r in n && n[r].type === o) { ((s = n[r]).options = i), (s.ctx = t.ctx), (s.chart = t) } else {
          const l = Ne.getScaleConstructor(o)
          if (!l) return;
          (s = new l({ id: r, type: o, options: i, ctx: t.ctx, chart: t })),
          (n[s.id] = s)
        }
        s.mergeTicksOptions(), e.isDefault && (t.scale = s)
      }),
      B.each(a, function (t, e) {
        t || delete n[e]
      }),
      (t.scales = n),
      Ne.addScalesToLayout(this)
    },
    buildOrUpdateControllers: function () {
      let t
      let e
      let n = this
      let i = []
      let a = n.data.datasets
      for (t = 0, e = a.length; t < e; t++) {
        const r = a[t]
        let o = n.getDatasetMeta(t)
        let s = r.type || n.config.type
        if (
          (o.type &&
            o.type !== s &&
            (n.destroyDatasetMeta(t), (o = n.getDatasetMeta(t))),
          (o.type = s),
          (o.order = r.order || 0),
          (o.index = t),
          o.controller)
        ) { o.controller.updateIndex(t), o.controller.linkScales() } else {
          const l = Qt[o.type]
          if (void 0 === l) { throw new Error('"' + o.type + '" is not a chart type.') }
          (o.controller = new l(n, t)), i.push(o.controller)
        }
      }
      return i
    },
    resetElements: function () {
      const t = this
      B.each(
        t.data.datasets,
        function (e, n) {
          t.getDatasetMeta(n).controller.reset()
        },
        t
      )
    },
    reset: function () {
      this.resetElements(), this.tooltip.initialize()
    },
    update: function (t) {
      let e
      let n
      let i = this
      if (
        ((t && typeof t === 'object') ||
          (t = { duration: t, lazy: arguments[1] }),
        Ke(i),
        Re._invalidate(i),
        !1 !== Re.notify(i, 'beforeUpdate'))
      ) {
        i.tooltip._data = i.data
        const a = i.buildOrUpdateControllers()
        for (e = 0, n = i.data.datasets.length; e < n; e++) { i.getDatasetMeta(e).controller.buildOrUpdateElements() }
        i.updateLayout(),
        i.options.animation &&
            i.options.animation.duration &&
            B.each(a, function (t) {
              t.reset()
            }),
        i.updateDatasets(),
        i.tooltip.initialize(),
        (i.lastActive = []),
        Re.notify(i, 'afterUpdate'),
        i._layers.sort(tn('z', '_idx')),
        i._bufferedRender
          ? (i._bufferedRequest = {
              duration: t.duration,
              easing: t.easing,
              lazy: t.lazy
            })
          : i.render(t)
      }
    },
    updateLayout: function () {
      const t = this
      !1 !== Re.notify(t, 'beforeLayout') &&
        (pe.update(this, this.width, this.height),
        (t._layers = []),
        B.each(
          t.boxes,
          function (e) {
            e._configure && e._configure(),
            t._layers.push.apply(t._layers, e._layers())
          },
          t
        ),
        t._layers.forEach(function (t, e) {
          t._idx = e
        }),
        Re.notify(t, 'afterScaleUpdate'),
        Re.notify(t, 'afterLayout'))
    },
    updateDatasets: function () {
      if (!1 !== Re.notify(this, 'beforeDatasetsUpdate')) {
        for (let t = 0, e = this.data.datasets.length; t < e; ++t) { this.updateDataset(t) }
        Re.notify(this, 'afterDatasetsUpdate')
      }
    },
    updateDataset: function (t) {
      const e = this.getDatasetMeta(t)
      let n = { meta: e, index: t }
      !1 !== Re.notify(this, 'beforeDatasetUpdate', [n]) &&
        (e.controller._update(), Re.notify(this, 'afterDatasetUpdate', [n]))
    },
    render: function (t) {
      const e = this;
      (t && typeof t === 'object') || (t = { duration: t, lazy: arguments[1] })
      const n = e.options.animation
      let i = Ze(t.duration, n && n.duration)
      let a = t.lazy
      if (!1 !== Re.notify(e, 'beforeRender')) {
        const r = function (t) {
          Re.notify(e, 'afterRender'), B.callback(n && n.onComplete, [t], e)
        }
        if (n && i) {
          const o = new J({
            numSteps: i / 16.66,
            easing: t.easing || n.easing,
            render: function (t, e) {
              const n = B.easing.effects[e.easing]
              var i = e.currentStep
              var a = i / e.numSteps
              t.draw(n(a), a, i)
            },
            onAnimationProgress: n.onProgress,
            onAnimationComplete: r
          })
          Q.addAnimation(e, o, i, a)
        } else e.draw(), r(new J({ numSteps: 0, chart: e }))
        return e
      }
    },
    draw: function (t) {
      let e
      let n
      let i = this
      if (
        (i.clear(),
        B.isNullOrUndef(t) && (t = 1),
        i.transition(t),
        !(i.width <= 0 || i.height <= 0) &&
          !1 !== Re.notify(i, 'beforeDraw', [t]))
      ) {
        for (n = i._layers, e = 0; e < n.length && n[e].z <= 0; ++e) { n[e].draw(i.chartArea) }
        for (i.drawDatasets(t); e < n.length; ++e) n[e].draw(i.chartArea)
        i._drawTooltip(t), Re.notify(i, 'afterDraw', [t])
      }
    },
    transition: function (t) {
      for (let e = 0, n = (this.data.datasets || []).length; e < n; ++e) {
        this.isDatasetVisible(e) &&
          this.getDatasetMeta(e).controller.transition(t) 
}
      this.tooltip.transition(t)
    },
    _getSortedDatasetMetas: function (t) {
      let e
      let n
      let i = []
      for (e = 0, n = (this.data.datasets || []).length; e < n; ++e) { (t && !this.isDatasetVisible(e)) || i.push(this.getDatasetMeta(e)) }
      return i.sort(tn('order', 'index')), i
    },
    _getSortedVisibleDatasetMetas: function () {
      return this._getSortedDatasetMetas(!0)
    },
    drawDatasets: function (t) {
      let e, n
      if (!1 !== Re.notify(this, 'beforeDatasetsDraw', [t])) {
        for (
          n = (e = this._getSortedVisibleDatasetMetas()).length - 1;
          n >= 0;
          --n
        ) { this.drawDataset(e[n], t) }
        Re.notify(this, 'afterDatasetsDraw', [t])
      }
    },
    drawDataset: function (t, e) {
      const n = { meta: t, index: t.index, easingValue: e }
      !1 !== Re.notify(this, 'beforeDatasetDraw', [n]) &&
        (t.controller.draw(e), Re.notify(this, 'afterDatasetDraw', [n]))
    },
    _drawTooltip: function (t) {
      const e = this.tooltip
      let n = { tooltip: e, easingValue: t }
      !1 !== Re.notify(this, 'beforeTooltipDraw', [n]) &&
        (e.draw(), Re.notify(this, 'afterTooltipDraw', [n]))
    },
    getElementAtEvent: function (t) {
      return oe.modes.single(this, t)
    },
    getElementsAtEvent: function (t) {
      return oe.modes.label(this, t, { intersect: !0 })
    },
    getElementsAtXAxis: function (t) {
      return oe.modes['x-axis'](this, t, { intersect: !0 })
    },
    getElementsAtEventForMode: function (t, e, n) {
      const i = oe.modes[e]
      return typeof i === 'function' ? i(this, t, n) : []
    },
    getDatasetAtEvent: function (t) {
      return oe.modes.dataset(this, t, { intersect: !0 })
    },
    getDatasetMeta: function (t) {
      const e = this.data.datasets[t]
      e._meta || (e._meta = {})
      let n = e._meta[this.id]
      return (
        n ||
          (n = e._meta[this.id] =
            {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              xAxisID: null,
              yAxisID: null,
              order: e.order || 0,
              index: t
            }),
        n
      )
    },
    getVisibleDatasetCount: function () {
      for (var t = 0, e = 0, n = this.data.datasets.length; e < n; ++e) { this.isDatasetVisible(e) && t++ }
      return t
    },
    isDatasetVisible: function (t) {
      const e = this.getDatasetMeta(t)
      return typeof e.hidden === 'boolean'
        ? !e.hidden
        : !this.data.datasets[t].hidden
    },
    generateLegend: function () {
      return this.options.legendCallback(this)
    },
    destroyDatasetMeta: function (t) {
      const e = this.id
      let n = this.data.datasets[t]
      let i = n._meta && n._meta[e]
      i && (i.controller.destroy(), delete n._meta[e])
    },
    destroy: function () {
      let t
      let e
      let n = this
      let i = n.canvas
      for (n.stop(), t = 0, e = n.data.datasets.length; t < e; ++t) { n.destroyDatasetMeta(t) }
      i &&
        (n.unbindEvents(),
        B.canvas.clear(n),
        Le.releaseContext(n.ctx),
        (n.canvas = null),
        (n.ctx = null)),
      Re.notify(n, 'destroy'),
      delete en.instances[n.id]
    },
    toBase64Image: function () {
      return this.canvas.toDataURL.apply(this.canvas, arguments)
    },
    initToolTip: function () {
      const t = this
      t.tooltip = new qe(
        {
          _chart: t,
          _chartInstance: t,
          _data: t.data,
          _options: t.options.tooltips
        },
        t
      )
    },
    bindEvents: function () {
      const t = this
      let e = (t._listeners = {})
      let n = function () {
        t.eventHandler.apply(t, arguments)
      }
      B.each(t.options.events, function (i) {
        Le.addEventListener(t, i, n), (e[i] = n)
      }),
      t.options.responsive &&
          ((n = function () {
            t.resize()
          }),
          Le.addEventListener(t, 'resize', n),
          (e.resize = n))
    },
    unbindEvents: function () {
      const t = this
      let e = t._listeners
      e &&
        (delete t._listeners,
        B.each(e, function (e, n) {
          Le.removeEventListener(t, n, e)
        }))
    },
    updateHoverStyle: function (t, e, n) {
      let i
      let a
      let r
      let o = n ? 'set' : 'remove'
      for (a = 0, r = t.length; a < r; ++a) {
        (i = t[a]) &&
          this.getDatasetMeta(i._datasetIndex).controller[o + 'HoverStyle'](i) 
}
      e === 'dataset' &&
        this.getDatasetMeta(t[0]._datasetIndex).controller[
          '_' + o + 'DatasetHoverStyle'
        ]()
    },
    eventHandler: function (t) {
      const e = this
      let n = e.tooltip
      if (!1 !== Re.notify(e, 'beforeEvent', [t])) {
        (e._bufferedRender = !0), (e._bufferedRequest = null)
        let i = e.handleEvent(t)
        n && (i = n._start ? n.handleEvent(t) : i | n.handleEvent(t)),
        Re.notify(e, 'afterEvent', [t])
        const a = e._bufferedRequest
        return (
          a
            ? e.render(a)
            : i &&
              !e.animating &&
              (e.stop(),
              e.render({
                duration: e.options.hover.animationDuration,
                lazy: !0
              })),
          (e._bufferedRender = !1),
          (e._bufferedRequest = null),
          e
        )
      }
    },
    handleEvent: function (t) {
      let e
      let n = this
      let i = n.options || {}
      let a = i.hover
      return (
        (n.lastActive = n.lastActive || []),
        t.type === 'mouseout'
          ? (n.active = [])
          : (n.active = n.getElementsAtEventForMode(t, a.mode, a)),
        B.callback(i.onHover || i.hover.onHover, [t.native, n.active], n),
        (t.type !== 'mouseup' && t.type !== 'click') ||
          (i.onClick && i.onClick.call(n, t.native, n.active)),
        n.lastActive.length && n.updateHoverStyle(n.lastActive, a.mode, !1),
        n.active.length && a.mode && n.updateHoverStyle(n.active, a.mode, !0),
        (e = !B.arrayEquals(n.active, n.lastActive)),
        (n.lastActive = n.active),
        e
      )
    }
  }),
  (en.instances = {})
  const nn = en;
  (en.Controller = en),
  (en.types = {}),
  (B.configMerge = Xe),
  (B.scaleMerge = $e)
  function an () {
    throw new Error(
      'This method is not implemented: either no adapter can be found or an incomplete integration was provided.'
    )
  }
  function rn (t) {
    this.options = t || {}
  }
  B.extend(rn.prototype, {
    formats: an,
    parse: an,
    format: an,
    add: an,
    diff: an,
    startOf: an,
    endOf: an,
    _create: function (t) {
      return t
    }
  }),
  (rn.override = function (t) {
    B.extend(rn.prototype, t)
  })
  const on = { _date: rn }
  let sn = {
    formatters: {
      values: function (t) {
        return B.isArray(t) ? t : '' + t
      },
      linear: function (t, e, n) {
        let i = n.length > 3 ? n[2] - n[1] : n[1] - n[0]
        Math.abs(i) > 1 && t !== Math.floor(t) && (i = t - Math.floor(t))
        let a = B.log10(Math.abs(i))
        var r = ''
        if (t !== 0) { if (Math.max(Math.abs(n[0]), Math.abs(n[n.length - 1])) < 1e-4) {
          var o = B.log10(Math.abs(t))
                var s = Math.floor(o) - Math.floor(a);
          (s = Math.max(Math.min(s, 20), 0)), (r = t.toExponential(s))
        } else {
          var l = -1 * Math.floor(a);
          (l = Math.max(Math.min(l, 20), 0)), (r = t.toFixed(l))
        } } else r = '0'
        return r
      },
      logarithmic: function (t, e, n) {
        const i = t / Math.pow(10, Math.floor(B.log10(t)))
        return t === 0
          ? '0'
          : i === 1 || i === 2 || i === 5 || e === 0 || e === n.length - 1
            ? t.toExponential()
            : ''
      }
    }
  }
  let ln = B.isArray
  let un = B.isNullOrUndef
  let dn = B.valueOrDefault
  let hn = B.valueAtIndexOrDefault
  function cn (t, e, n) {
    let i
    let a = t.getTicks().length
    let r = Math.min(e, a - 1)
    let o = t.getPixelForTick(r)
    let s = t._startPixel
    let l = t._endPixel
    if (
      !(
        n &&
        ((i =
          a === 1
            ? Math.max(o - s, l - o)
            : e === 0
              ? (t.getPixelForTick(1) - o) / 2
              : (o - t.getPixelForTick(r - 1)) / 2),
        (o += r < e ? i : -i) < s - 1e-6 || o > l + 1e-6)
      )
    ) { return o }
  }
  function fn (t, e, n, i) {
    let a
    let r
    let o
    let s
    let l
    let u
    let d
    let h
    let c
    let f
    let g
    let m
    let p
    let v = n.length
    let b = []
    let y = []
    let x = []
    let _ = 0
    let w = 0
    for (a = 0; a < v; ++a) {
      if (
        ((s = n[a].label),
        (l = n[a].major ? e.major : e.minor),
        (t.font = u = l.string),
        (d = i[u] = i[u] || { data: {}, gc: [] }),
        (h = l.lineHeight),
        (c = f = 0),
        un(s) || ln(s))
      ) {
        if (ln(s)) {
          for (r = 0, o = s.length; r < o; ++r) { (g = s[r]),
          un(g) ||
                ln(g) ||
                ((c = B.measureText(t, d.data, d.gc, c, g)), (f += h)) } }
      } else (c = B.measureText(t, d.data, d.gc, c, s)), (f = h)
      b.push(c),
      y.push(f),
      x.push(h / 2),
      (_ = Math.max(c, _)),
      (w = Math.max(f, w))
    }
    function k (t) {
      return { width: b[t] || 0, height: y[t] || 0, offset: x[t] || 0 }
    }
    return (
      (function (t, e) {
        B.each(t, function (t) {
          let n
          let i = t.gc
          let a = i.length / 2
          if (a > e) {
            for (n = 0; n < a; ++n) delete t.data[i[n]]
            i.splice(0, a)
          }
        })
      })(i, v),
      (m = b.indexOf(_)),
      (p = y.indexOf(w)),
      { first: k(0), last: k(v - 1), widest: k(m), highest: k(p) }
    )
  }
  function gn (t) {
    return t.drawTicks ? t.tickMarkLength : 0
  }
  function mn (t) {
    let e, n
    return t.display
      ? ((e = B.options._parseFont(t)),
        (n = B.options.toPadding(t.padding)),
        e.lineHeight + n.height)
      : 0
  }
  function pn (t, e) {
    return B.extend(
      B.options._parseFont({
        fontFamily: dn(e.fontFamily, t.fontFamily),
        fontSize: dn(e.fontSize, t.fontSize),
        fontStyle: dn(e.fontStyle, t.fontStyle),
        lineHeight: dn(e.lineHeight, t.lineHeight)
      }),
      {
        color: B.options.resolve([
          e.fontColor,
          t.fontColor,
          Y.global.defaultFontColor
        ])
      }
    )
  }
  function vn (t) {
    const e = pn(t, t.minor)
    return { minor: e, major: t.major.enabled ? pn(t, t.major) : e }
  }
  function bn (t) {
    let e
    let n
    let i
    let a = []
    for (n = 0, i = t.length; n < i; ++n) { void 0 !== (e = t[n])._index && a.push(e) }
    return a
  }
  function yn (t, e, n, i) {
    let a
    let r
    let o
    let s
    let l = dn(n, 0)
    let u = Math.min(dn(i, t.length), t.length)
    let d = 0
    for (
      e = Math.ceil(e), i && (e = (a = i - n) / Math.floor(a / e)), s = l;
      s < 0;

    ) { d++, (s = Math.round(l + d * e)) }
    for (r = Math.max(l, 0); r < u; r++) {
      (o = t[r]),
      r === s
        ? ((o._index = r), d++, (s = Math.round(l + d * e)))
        : delete o.label 
}
  }
  Y._set('scale', {
    display: !0,
    position: 'left',
    offset: !1,
    gridLines: {
      display: !0,
      color: 'rgba(0,0,0,0.1)',
      lineWidth: 1,
      drawBorder: !0,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickMarkLength: 10,
      zeroLineWidth: 1,
      zeroLineColor: 'rgba(0,0,0,0.25)',
      zeroLineBorderDash: [],
      zeroLineBorderDashOffset: 0,
      offsetGridLines: !1,
      borderDash: [],
      borderDashOffset: 0
    },
    scaleLabel: {
      display: !1,
      labelString: '',
      padding: { top: 4, bottom: 4 }
    },
    ticks: {
      beginAtZero: !1,
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      padding: 0,
      reverse: !1,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 0,
      labelOffset: 0,
      callback: sn.formatters.values,
      minor: {},
      major: {}
    }
  })
  const xn = X.extend({
    zeroLineIndex: 0,
    getPadding: function () {
      return {
        left: this.paddingLeft || 0,
        top: this.paddingTop || 0,
        right: this.paddingRight || 0,
        bottom: this.paddingBottom || 0
      }
    },
    getTicks: function () {
      return this._ticks
    },
    _getLabels: function () {
      const t = this.chart.data
      return (
        this.options.labels ||
        (this.isHorizontal() ? t.xLabels : t.yLabels) ||
        t.labels ||
        []
      )
    },
    mergeTicksOptions: function () {},
    beforeUpdate: function () {
      B.callback(this.options.beforeUpdate, [this])
    },
    update: function (t, e, n) {
      let i
      var a
      var r
      var o
      var s
      var l = this
      var u = l.options.ticks
      var d = u.sampleSize
      if (
        (l.beforeUpdate(),
        (l.maxWidth = t),
        (l.maxHeight = e),
        (l.margins = B.extend({ left: 0, right: 0, top: 0, bottom: 0 }, n)),
        (l._ticks = null),
        (l.ticks = null),
        (l._labelSizes = null),
        (l._maxLabelLines = 0),
        (l.longestLabelWidth = 0),
        (l.longestTextCache = l.longestTextCache || {}),
        (l._gridLineItems = null),
        (l._labelItems = null),
        l.beforeSetDimensions(),
        l.setDimensions(),
        l.afterSetDimensions(),
        l.beforeDataLimits(),
        l.determineDataLimits(),
        l.afterDataLimits(),
        l.beforeBuildTicks(),
        (o = l.buildTicks() || []),
        (!(o = l.afterBuildTicks(o) || o) || !o.length) && l.ticks)
      ) {
 for (o = [], i = 0, a = l.ticks.length; i < a; ++i)
        {o.push({ value: l.ticks[i], major: !1 })}}
      return (
        (l._ticks = o),
        (s = d < o.length),
        (r = l._convertTicksToLabels(
          s
            ? (function (t, e) {
                for (
                  var n = [], i = t.length / e, a = 0, r = t.length;
                  a < r;
                  a += i
                ) { n.push(t[Math.floor(a)]) }
                return n
              })(o, d)
            : o
        )),
        l._configure(),
        l.beforeCalculateTickRotation(),
        l.calculateTickRotation(),
        l.afterCalculateTickRotation(),
        l.beforeFit(),
        l.fit(),
        l.afterFit(),
        (l._ticksToDraw =
          u.display && (u.autoSkip || u.source === 'auto')
            ? l._autoSkip(o)
            : o),
        s && (r = l._convertTicksToLabels(l._ticksToDraw)),
        (l.ticks = r),
        l.afterUpdate(),
        l.minSize
      )
    },
    _configure: function () {
      let t
      var e
      var n = this
      var i = n.options.ticks.reverse
      n.isHorizontal()
        ? ((t = n.left), (e = n.right))
        : ((t = n.top), (e = n.bottom), (i = !i)),
      (n._startPixel = t),
      (n._endPixel = e),
      (n._reversePixels = i),
      (n._length = e - t)
    },
    afterUpdate: function () {
      B.callback(this.options.afterUpdate, [this])
    },
    beforeSetDimensions: function () {
      B.callback(this.options.beforeSetDimensions, [this])
    },
    setDimensions: function () {
      const t = this
      t.isHorizontal()
        ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
        : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
      (t.paddingLeft = 0),
      (t.paddingTop = 0),
      (t.paddingRight = 0),
      (t.paddingBottom = 0)
    },
    afterSetDimensions: function () {
      B.callback(this.options.afterSetDimensions, [this])
    },
    beforeDataLimits: function () {
      B.callback(this.options.beforeDataLimits, [this])
    },
    determineDataLimits: B.noop,
    afterDataLimits: function () {
      B.callback(this.options.afterDataLimits, [this])
    },
    beforeBuildTicks: function () {
      B.callback(this.options.beforeBuildTicks, [this])
    },
    buildTicks: B.noop,
    afterBuildTicks: function (t) {
      const e = this
      return ln(t) && t.length
        ? B.callback(e.options.afterBuildTicks, [e, t])
        : ((e.ticks =
            B.callback(e.options.afterBuildTicks, [e, e.ticks]) || e.ticks),
          t)
    },
    beforeTickToLabelConversion: function () {
      B.callback(this.options.beforeTickToLabelConversion, [this])
    },
    convertTicksToLabels: function () {
      const t = this.options.ticks
      this.ticks = this.ticks.map(t.userCallback || t.callback, this)
    },
    afterTickToLabelConversion: function () {
      B.callback(this.options.afterTickToLabelConversion, [this])
    },
    beforeCalculateTickRotation: function () {
      B.callback(this.options.beforeCalculateTickRotation, [this])
    },
    calculateTickRotation: function () {
      let t
      var e
      var n
      var i
      var a
      var r
      var o
      var s = this
      var l = s.options
      var u = l.ticks
      var d = s.getTicks().length
      var h = u.minRotation || 0
      var c = u.maxRotation
      var f = h
      !s._isVisible() || !u.display || h >= c || d <= 1 || !s.isHorizontal()
        ? (s.labelRotation = h)
        : ((e = (t = s._getLabelSizes()).widest.width),
          (n = t.highest.height - t.highest.offset),
          (i = Math.min(s.maxWidth, s.chart.width - e)),
          e + 6 > (a = l.offset ? s.maxWidth / d : i / (d - 1)) &&
            ((a = i / (d - (l.offset ? 0.5 : 1))),
            (r = s.maxHeight - gn(l.gridLines) - u.padding - mn(l.scaleLabel)),
            (o = Math.sqrt(e * e + n * n)),
            (f = B.toDegrees(
              Math.min(
                Math.asin(Math.min((t.highest.height + 6) / a, 1)),
                Math.asin(Math.min(r / o, 1)) - Math.asin(n / o)
              )
            )),
            (f = Math.max(h, Math.min(c, f)))),
          (s.labelRotation = f))
    },
    afterCalculateTickRotation: function () {
      B.callback(this.options.afterCalculateTickRotation, [this])
    },
    beforeFit: function () {
      B.callback(this.options.beforeFit, [this])
    },
    fit: function () {
      const t = this
      var e = (t.minSize = { width: 0, height: 0 })
      var n = t.chart
      var i = t.options
      var a = i.ticks
      var r = i.scaleLabel
      var o = i.gridLines
      var s = t._isVisible()
      var l = i.position === 'bottom'
      var u = t.isHorizontal()
      if (
        (u ? (e.width = t.maxWidth) : s && (e.width = gn(o) + mn(r)),
        u ? s && (e.height = gn(o) + mn(r)) : (e.height = t.maxHeight),
        a.display && s)
      ) {
        const d = vn(a)
        var h = t._getLabelSizes()
        var c = h.first
        var f = h.last
        var g = h.widest
        var m = h.highest
        var p = 0.4 * d.minor.lineHeight
        var v = a.padding
        if (u) {
          const b = t.labelRotation !== 0;
            const y = B.toRadians(t.labelRotation);
            const x = Math.cos(y);
            const _ = Math.sin(y);
            const w = _ * g.width + x * (m.height - (b ? m.offset : 0)) + (b ? 0 : p)
          e.height = Math.min(t.maxHeight, e.height + w + v)
          let k
          var M
          var S = t.getPixelForTick(0) - t.left
          var D = t.right - t.getPixelForTick(t.getTicks().length - 1)
          b
            ? ((k = l ? x * c.width + _ * c.offset : _ * (c.height - c.offset)),
              (M = l ? _ * (f.height - f.offset) : x * f.width + _ * f.offset))
            : ((k = c.width / 2), (M = f.width / 2)),
          (t.paddingLeft =
              Math.max(((k - S) * t.width) / (t.width - S), 0) + 3),
          (t.paddingRight =
              Math.max(((M - D) * t.width) / (t.width - D), 0) + 3)
        } else {
          const C = a.mirror ? 0 : g.width + v + p;
          (e.width = Math.min(t.maxWidth, e.width + C)),
          (t.paddingTop = c.height / 2),
          (t.paddingBottom = f.height / 2)
        }
      }
      t.handleMargins(),
      u
        ? ((t.width = t._length = n.width - t.margins.left - t.margins.right),
          (t.height = e.height))
        : ((t.width = e.width),
          (t.height = t._length =
              n.height - t.margins.top - t.margins.bottom))
    },
    handleMargins: function () {
      const t = this
      t.margins &&
        ((t.margins.left = Math.max(t.paddingLeft, t.margins.left)),
        (t.margins.top = Math.max(t.paddingTop, t.margins.top)),
        (t.margins.right = Math.max(t.paddingRight, t.margins.right)),
        (t.margins.bottom = Math.max(t.paddingBottom, t.margins.bottom)))
    },
    afterFit: function () {
      B.callback(this.options.afterFit, [this])
    },
    isHorizontal: function () {
      const t = this.options.position
      return t === 'top' || t === 'bottom'
    },
    isFullWidth: function () {
      return this.options.fullWidth
    },
    getRightValue: function (t) {
      if (un(t)) return NaN
      if ((typeof t === 'number' || t instanceof Number) && !isFinite(t)) { return NaN }
      if (t) {
 if (this.isHorizontal()) {
        if (void 0 !== t.x) return this.getRightValue(t.x)
      } else if (void 0 !== t.y) return this.getRightValue(t.y) }
      return t
    },
    _convertTicksToLabels: function (t) {
      let e
      var n
      var i
      var a = this
      for (
        a.ticks = t.map(function (t) {
          return t.value
        }),
        a.beforeTickToLabelConversion(),
        e = a.convertTicksToLabels(t) || a.ticks,
        a.afterTickToLabelConversion(),
        n = 0,
        i = t.length;
        n < i;
        ++n
      ) { t[n].label = e[n] }
      return e
    },
    _getLabelSizes: function () {
      const t = this
      var e = t._labelSizes
      return (
        e ||
          ((t._labelSizes = e =
            fn(t.ctx, vn(t.options.ticks), t.getTicks(), t.longestTextCache)),
          (t.longestLabelWidth = e.widest.width)),
        e
      )
    },
    _parseValue: function (t) {
      let e, n, i, a
      return (
        ln(t)
          ? ((e = +this.getRightValue(t[0])),
            (n = +this.getRightValue(t[1])),
            (i = Math.min(e, n)),
            (a = Math.max(e, n)))
          : ((e = void 0), (n = t = +this.getRightValue(t)), (i = t), (a = t)),
        { min: i, max: a, start: e, end: n }
      )
    },
    _getScaleLabel: function (t) {
      const e = this._parseValue(t)
      return void 0 !== e.start
        ? '[' + e.start + ', ' + e.end + ']'
        : +this.getRightValue(t)
    },
    getLabelForIndex: B.noop,
    getPixelForValue: B.noop,
    getValueForPixel: B.noop,
    getPixelForTick: function (t) {
      const e = this.options.offset
      var n = this._ticks.length
      var i = 1 / Math.max(n - (e ? 0 : 1), 1)
      return t < 0 || t > n - 1
        ? null
        : this.getPixelForDecimal(t * i + (e ? i / 2 : 0))
    },
    getPixelForDecimal: function (t) {
      return (
        this._reversePixels && (t = 1 - t), this._startPixel + t * this._length
      )
    },
    getDecimalForPixel: function (t) {
      const e = (t - this._startPixel) / this._length
      return this._reversePixels ? 1 - e : e
    },
    getBasePixel: function () {
      return this.getPixelForValue(this.getBaseValue())
    },
    getBaseValue: function () {
      const t = this.min
      var e = this.max
      return this.beginAtZero ? 0 : t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0
    },
    _autoSkip: function (t) {
      let e
      var n
      var i
      var a
      var r = this.options.ticks
      var o = this._length
      var s = r.maxTicksLimit || o / this._tickSize() + 1
      var l = r.major.enabled
        ? (function (t) {
            let e
                var n
                var i = []
            for (e = 0, n = t.length; e < n; e++) t[e].major && i.push(e)
            return i
          })(t)
        : []
      var u = l.length
      var d = l[0]
      var h = l[u - 1]
      if (u > s) {
 return (
        (function (t, e, n) {
          let i
              var a
              var r = 0
              var o = e[0]
          for (n = Math.ceil(n), i = 0; i < t.length; i++)
            {(a = t[i]),
            i === o ? ((a._index = i), (o = e[++r * n])) : delete a.label}
        })(t, l, u / s),
        bn(t)
      ) }
      if (
        ((i = (function (t, e, n, i) {
          let a
          var r
          var o
          var s
          var l = (function (t) {
            let e
                var n
                var i = t.length
            if (i < 2) return !1
            for (n = t[0], e = 1; e < i; ++e)
              {if (t[e] - t[e - 1] !== n) return !1}
            return n
          })(t)
          var u = (e.length - 1) / i
          if (!l) return Math.max(u, 1)
          for (o = 0, s = (a = B.math._factorize(l)).length - 1; o < s; o++) { if ((r = a[o]) > u) return r }
          return Math.max(u, 1)
        })(l, t, 0, s)),
        u > 0)
      ) {
        for (e = 0, n = u - 1; e < n; e++) yn(t, i, l[e], l[e + 1])
        return (
          (a = u > 1 ? (h - d) / (u - 1) : null),
          yn(t, i, B.isNullOrUndef(a) ? 0 : d - a, d),
          yn(t, i, h, B.isNullOrUndef(a) ? t.length : h + a),
          bn(t)
        )
      }
      return yn(t, i), bn(t)
    },
    _tickSize: function () {
      const t = this.options.ticks
      var e = B.toRadians(this.labelRotation)
      var n = Math.abs(Math.cos(e))
      var i = Math.abs(Math.sin(e))
      var a = this._getLabelSizes()
      var r = t.autoSkipPadding || 0
      var o = a ? a.widest.width + r : 0
      var s = a ? a.highest.height + r : 0
      return this.isHorizontal()
        ? s * n > o * i
          ? o / n
          : s / i
        : s * i < o * n
          ? s / n
          : o / i
    },
    _isVisible: function () {
      let t
      var e
      var n
      var i = this.chart
      var a = this.options.display
      if (a !== 'auto') return !!a
      for (t = 0, e = i.data.datasets.length; t < e; ++t) {
 if (
        i.isDatasetVisible(t) &&
          ((n = i.getDatasetMeta(t)).xAxisID === this.id ||
            n.yAxisID === this.id)
      )
        {return !0}}
      return !1
    },
    _computeGridLineItems: function (t) {
      let e
      var n
      var i
      var a
      var r
      var o
      var s
      var l
      var u
      var d
      var h
      var c
      var f
      var g
      var m
      var p
      var v
      var b = this
      var y = b.chart
      var x = b.options
      var _ = x.gridLines
      var w = x.position
      var k = _.offsetGridLines
      var M = b.isHorizontal()
      var S = b._ticksToDraw
      var D = S.length + (k ? 1 : 0)
      var C = gn(_)
      var P = []
      var T = _.drawBorder ? hn(_.lineWidth, 0, 0) : 0
      var O = T / 2
      var A = B._alignPixel
      var F = function (t) {
        return A(y, t, T)
      }
      for (
        w === 'top'
          ? ((e = F(b.bottom)),
            (s = b.bottom - C),
            (u = e - O),
            (h = F(t.top) + O),
            (f = t.bottom))
          : w === 'bottom'
            ? ((e = F(b.top)),
              (h = t.top),
              (f = F(t.bottom) - O),
              (s = e + O),
              (u = b.top + C))
            : w === 'left'
              ? ((e = F(b.right)),
                (o = b.right - C),
                (l = e - O),
                (d = F(t.left) + O),
                (c = t.right))
              : ((e = F(b.left)),
                (d = t.left),
                (c = F(t.right) - O),
                (o = e + O),
                (l = b.left + C)),
        n = 0;
        n < D;
        ++n
      ) {
 (i = S[n] || {}),
      (un(i.label) && n < S.length) ||
            (n === b.zeroLineIndex && x.offset === k
              ? ((g = _.zeroLineWidth),
                (m = _.zeroLineColor),
                (p = _.zeroLineBorderDash || []),
                (v = _.zeroLineBorderDashOffset || 0))
              : ((g = hn(_.lineWidth, n, 1)),
                (m = hn(_.color, n, 'rgba(0,0,0,0.1)')),
                (p = _.borderDash || []),
                (v = _.borderDashOffset || 0)),
            void 0 !== (a = cn(b, i._index || n, k)) &&
              ((r = A(y, a, g)),
              M ? (o = l = d = c = r) : (s = u = h = f = r),
              P.push({
                tx1: o,
                ty1: s,
                tx2: l,
                ty2: u,
                x1: d,
                y1: h,
                x2: c,
                y2: f,
                width: g,
                color: m,
                borderDash: p,
                borderDashOffset: v
              }))) }
      return (P.ticksLength = D), (P.borderValue = e), P
    },
    _computeLabelItems: function () {
      let t
      var e
      var n
      var i
      var a
      var r
      var o
      var s
      var l
      var u
      var d
      var h
      var c = this
      var f = c.options
      var g = f.ticks
      var m = f.position
      var p = g.mirror
      var v = c.isHorizontal()
      var b = c._ticksToDraw
      var y = vn(g)
      var x = g.padding
      var _ = gn(f.gridLines)
      var w = -B.toRadians(c.labelRotation)
      var k = []
      for (
        m === 'top'
          ? ((r = c.bottom - _ - x), (o = w ? 'left' : 'center'))
          : m === 'bottom'
            ? ((r = c.top + _ + x), (o = w ? 'right' : 'center'))
            : m === 'left'
              ? ((a = c.right - (p ? 0 : _) - x), (o = p ? 'left' : 'right'))
              : ((a = c.left + (p ? 0 : _) + x), (o = p ? 'right' : 'left')),
        t = 0,
        e = b.length;
        t < e;
        ++t
      ) {
 (i = (n = b[t]).label),
      un(i) ||
            ((s = c.getPixelForTick(n._index || t) + g.labelOffset),
            (u = (l = n.major ? y.major : y.minor).lineHeight),
            (d = ln(i) ? i.length : 1),
            v
              ? ((a = s),
                (h = m === 'top' ? ((w ? 1 : 0.5) - d) * u : (w ? 0 : 0.5) * u))
              : ((r = s), (h = ((1 - d) * u) / 2)),
            k.push({
              x: a,
              y: r,
              rotation: w,
              label: i,
              font: l,
              textOffset: h,
              textAlign: o
            })) }
      return k
    },
    _drawGrid: function (t) {
      const e = this
      var n = e.options.gridLines
      if (n.display) {
        let i
        var a
        var r
        var o
        var s
        var l = e.ctx
        var u = e.chart
        var d = B._alignPixel
        var h = n.drawBorder ? hn(n.lineWidth, 0, 0) : 0
        var c =
            e._gridLineItems || (e._gridLineItems = e._computeGridLineItems(t))
        for (r = 0, o = c.length; r < o; ++r) {
 (i = (s = c[r]).width),
        (a = s.color),
        i &&
              a &&
              (l.save(),
              (l.lineWidth = i),
              (l.strokeStyle = a),
              l.setLineDash &&
                (l.setLineDash(s.borderDash),
                (l.lineDashOffset = s.borderDashOffset)),
              l.beginPath(),
              n.drawTicks && (l.moveTo(s.tx1, s.ty1), l.lineTo(s.tx2, s.ty2)),
              n.drawOnChartArea && (l.moveTo(s.x1, s.y1), l.lineTo(s.x2, s.y2)),
              l.stroke(),
              l.restore()) }
        if (h) {
          let f
          var g
          var m
          var p
          var v = h
          var b = hn(n.lineWidth, c.ticksLength - 1, 1)
          var y = c.borderValue
          e.isHorizontal()
            ? ((f = d(u, e.left, v) - v / 2),
              (g = d(u, e.right, b) + b / 2),
              (m = p = y))
            : ((m = d(u, e.top, v) - v / 2),
              (p = d(u, e.bottom, b) + b / 2),
              (f = g = y)),
          (l.lineWidth = h),
          (l.strokeStyle = hn(n.color, 0)),
          l.beginPath(),
          l.moveTo(f, m),
          l.lineTo(g, p),
          l.stroke()
        }
      }
    },
    _drawLabels: function () {
      const t = this
      if (t.options.ticks.display) {
        let e
        var n
        var i
        var a
        var r
        var o
        var s
        var l
        var u = t.ctx
        var d = t._labelItems || (t._labelItems = t._computeLabelItems())
        for (e = 0, i = d.length; e < i; ++e) {
          if (
            ((o = (r = d[e]).font),
            u.save(),
            u.translate(r.x, r.y),
            u.rotate(r.rotation),
            (u.font = o.string),
            (u.fillStyle = o.color),
            (u.textBaseline = 'middle'),
            (u.textAlign = r.textAlign),
            (s = r.label),
            (l = r.textOffset),
            ln(s))
          ) {
 for (n = 0, a = s.length; n < a; ++n)
            {u.fillText('' + s[n], 0, l), (l += o.lineHeight)}} else u.fillText(s, 0, l)
          u.restore()
        }
      }
    },
    _drawTitle: function () {
      const t = this
      var e = t.ctx
      var n = t.options
      var i = n.scaleLabel
      if (i.display) {
        let a
        var r
        var o = dn(i.fontColor, Y.global.defaultFontColor)
        var s = B.options._parseFont(i)
        var l = B.options.toPadding(i.padding)
        var u = s.lineHeight / 2
        var d = n.position
        var h = 0
        if (t.isHorizontal()) {
 (a = t.left + t.width / 2),
        (r = d === 'bottom' ? t.bottom - u - l.bottom : t.top + u + l.top) } else {
          const c = d === 'left';
          (a = c ? t.left + u + l.top : t.right - u - l.top),
          (r = t.top + t.height / 2),
          (h = c ? -0.5 * Math.PI : 0.5 * Math.PI)
        }
        e.save(),
        e.translate(a, r),
        e.rotate(h),
        (e.textAlign = 'center'),
        (e.textBaseline = 'middle'),
        (e.fillStyle = o),
        (e.font = s.string),
        e.fillText(i.labelString, 0, 0),
        e.restore()
      }
    },
    draw: function (t) {
      this._isVisible() &&
        (this._drawGrid(t), this._drawTitle(), this._drawLabels())
    },
    _layers: function () {
      const t = this
      var e = t.options
      var n = (e.ticks && e.ticks.z) || 0
      var i = (e.gridLines && e.gridLines.z) || 0
      return t._isVisible() && n !== i && t.draw === t._draw
        ? [
            {
              z: i,
              draw: function () {
                t._drawGrid.apply(t, arguments),
                t._drawTitle.apply(t, arguments)
              }
            },
            {
              z: n,
              draw: function () {
                t._drawLabels.apply(t, arguments)
              }
            }
          ]
        : [
            {
              z: n,
              draw: function () {
                t.draw.apply(t, arguments)
              }
            }
          ]
    },
    _getMatchingVisibleMetas: function (t) {
      const e = this
      var n = e.isHorizontal()
      return e.chart._getSortedVisibleDatasetMetas().filter(function (i) {
        return (
          (!t || i.type === t) && (n ? i.xAxisID === e.id : i.yAxisID === e.id)
        )
      })
    }
  })
  xn.prototype._draw = xn.prototype.draw
  const _n = xn
  let wn = B.isNullOrUndef
  let kn = _n.extend({
    determineDataLimits: function () {
      let t
      var e = this
      var n = e._getLabels()
      var i = e.options.ticks
      var a = i.min
      var r = i.max
      var o = 0
      var s = n.length - 1
      void 0 !== a && (t = n.indexOf(a)) >= 0 && (o = t),
      void 0 !== r && (t = n.indexOf(r)) >= 0 && (s = t),
      (e.minIndex = o),
      (e.maxIndex = s),
      (e.min = n[o]),
      (e.max = n[s])
    },
    buildTicks: function () {
      const t = this._getLabels()
      var e = this.minIndex
      var n = this.maxIndex
      this.ticks = e === 0 && n === t.length - 1 ? t : t.slice(e, n + 1)
    },
    getLabelForIndex: function (t, e) {
      const n = this.chart
      return n.getDatasetMeta(e).controller._getValueScaleId() === this.id
        ? this.getRightValue(n.data.datasets[e].data[t])
        : this._getLabels()[t]
    },
    _configure: function () {
      const t = this
      var e = t.options.offset
      var n = t.ticks
      _n.prototype._configure.call(t),
      t.isHorizontal() || (t._reversePixels = !t._reversePixels),
      n &&
            ((t._startValue = t.minIndex - (e ? 0.5 : 0)),
            (t._valueRange = Math.max(n.length - (e ? 0 : 1), 1)))
    },
    getPixelForValue: function (t, e, n) {
      let i
      var a
      var r
      var o = this
      return (
        wn(e) || wn(n) || (t = o.chart.data.datasets[n].data[e]),
        wn(t) || (i = o.isHorizontal() ? t.x : t.y),
        (void 0 !== i || (void 0 !== t && isNaN(e))) &&
            ((a = o._getLabels()),
            (t = B.valueOrDefault(i, t)),
            (e = (r = a.indexOf(t)) !== -1 ? r : e),
            isNaN(e) && (e = t)),
        o.getPixelForDecimal((e - o._startValue) / o._valueRange)
      )
    },
    getPixelForTick: function (t) {
      const e = this.ticks
      return t < 0 || t > e.length - 1
        ? null
        : this.getPixelForValue(e[t], t + this.minIndex)
    },
    getValueForPixel: function (t) {
      const e = Math.round(
        this._startValue + this.getDecimalForPixel(t) * this._valueRange
      )
      return Math.min(Math.max(e, 0), this.ticks.length - 1)
    },
    getBasePixel: function () {
      return this.bottom
    }
  })
  let Mn = { position: 'bottom' }
  kn._defaults = Mn
  const Sn = B.noop
  let Dn = B.isNullOrUndef
  const Cn = _n.extend({
    getRightValue: function (t) {
      return typeof t === 'string'
        ? +t
        : _n.prototype.getRightValue.call(this, t)
    },
    handleTickRangeOptions: function () {
      const t = this
      var e = t.options.ticks
      if (e.beginAtZero) {
        const n = B.sign(t.min)
        var i = B.sign(t.max)
        n < 0 && i < 0 ? (t.max = 0) : n > 0 && i > 0 && (t.min = 0)
      }
      const a = void 0 !== e.min || void 0 !== e.suggestedMin
      var r = void 0 !== e.max || void 0 !== e.suggestedMax
      void 0 !== e.min
        ? (t.min = e.min)
        : void 0 !== e.suggestedMin &&
            (t.min === null
              ? (t.min = e.suggestedMin)
              : (t.min = Math.min(t.min, e.suggestedMin))),
      void 0 !== e.max
        ? (t.max = e.max)
        : void 0 !== e.suggestedMax &&
              (t.max === null
                ? (t.max = e.suggestedMax)
                : (t.max = Math.max(t.max, e.suggestedMax))),
      a !== r &&
            t.min >= t.max &&
            (a ? (t.max = t.min + 1) : (t.min = t.max - 1)),
      t.min === t.max && (t.max++, e.beginAtZero || t.min--)
    },
    getTickLimit: function () {
      let t
      var e = this.options.ticks
      var n = e.stepSize
      var i = e.maxTicksLimit
      return (
        n
          ? (t = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1)
          : ((t = this._computeTickLimit()), (i = i || 11)),
        i && (t = Math.min(i, t)),
        t
      )
    },
    _computeTickLimit: function () {
      return Number.POSITIVE_INFINITY
    },
    handleDirectionalChanges: Sn,
    buildTicks: function () {
      const t = this
      var e = t.options.ticks
      var n = t.getTickLimit()
      var i = {
        maxTicks: (n = Math.max(2, n)),
        min: e.min,
        max: e.max,
        precision: e.precision,
        stepSize: B.valueOrDefault(e.fixedStepSize, e.stepSize)
      }
      var a = (t.ticks = (function (t, e) {
        let n
        var i
        var a
        var r
        var o = []
        var s = t.stepSize
        var l = s || 1
        var u = t.maxTicks - 1
        var d = t.min
        var h = t.max
        var c = t.precision
        var f = e.min
        var g = e.max
        var m = B.niceNum((g - f) / u / l) * l
        if (m < 1e-14 && Dn(d) && Dn(h)) return [f, g];
        (r = Math.ceil(g / m) - Math.floor(f / m)) > u &&
              (m = B.niceNum((r * m) / u / l) * l),
        s || Dn(c)
          ? (n = Math.pow(10, B._decimalPlaces(m)))
          : ((n = Math.pow(10, c)), (m = Math.ceil(m * n) / n)),
        (i = Math.floor(f / m) * m),
        (a = Math.ceil(g / m) * m),
        s &&
                (!Dn(d) && B.almostWhole(d / m, m / 1e3) && (i = d),
                !Dn(h) && B.almostWhole(h / m, m / 1e3) && (a = h)),
        (r = (a - i) / m),
        (r = B.almostEquals(r, Math.round(r), m / 1e3)
          ? Math.round(r)
          : Math.ceil(r)),
        (i = Math.round(i * n) / n),
        (a = Math.round(a * n) / n),
        o.push(Dn(d) ? i : d)
        for (let p = 1; p < r; ++p) o.push(Math.round((i + p * m) * n) / n)
        return o.push(Dn(h) ? a : h), o
      })(i, t))
      t.handleDirectionalChanges(),
      (t.max = B.max(a)),
      (t.min = B.min(a)),
      e.reverse
        ? (a.reverse(), (t.start = t.max), (t.end = t.min))
        : ((t.start = t.min), (t.end = t.max))
    },
    convertTicksToLabels: function () {
      const t = this;
      (t.ticksAsNumbers = t.ticks.slice()),
      (t.zeroLineIndex = t.ticks.indexOf(0)),
      _n.prototype.convertTicksToLabels.call(t)
    },
    _configure: function () {
      let t
      var e = this
      var n = e.getTicks()
      var i = e.min
      var a = e.max
      _n.prototype._configure.call(e),
      e.options.offset &&
            n.length &&
            ((i -= t = (a - i) / Math.max(n.length - 1, 1) / 2), (a += t)),
      (e._startValue = i),
      (e._endValue = a),
      (e._valueRange = a - i)
    }
  })
  let Pn = { position: 'left', ticks: { callback: sn.formatters.linear } }
  function Tn (t, e, n, i) {
    let a
    let r
    let o = t.options
    let s = (function (t, e, n) {
      const i = [
        n.type,
        void 0 === e && void 0 === n.stack ? n.index : '',
        n.stack
      ].join('.')
      return void 0 === t[i] && (t[i] = { pos: [], neg: [] }), t[i]
    })(e, o.stacked, n)
    let l = s.pos
    let u = s.neg
    let d = i.length
    for (a = 0; a < d; ++a) {
      (r = t._parseValue(i[a])),
      isNaN(r.min) ||
          isNaN(r.max) ||
          n.data[a].hidden ||
          ((l[a] = l[a] || 0),
          (u[a] = u[a] || 0),
          o.relativePoints
            ? (l[a] = 100)
            : r.min < 0 || r.max < 0
              ? (u[a] += r.min)
              : (l[a] += r.max)) 
}
  }
  function On (t, e, n) {
    let i
    let a
    let r = n.length
    for (i = 0; i < r; ++i) {
      (a = t._parseValue(n[i])),
      isNaN(a.min) ||
          isNaN(a.max) ||
          e.data[i].hidden ||
          ((t.min = Math.min(t.min, a.min)), (t.max = Math.max(t.max, a.max))) 
}
  }
  const An = Cn.extend({
    determineDataLimits: function () {
      let t
      var e
      var n
      var i
      var a = this
      var r = a.options
      var o = a.chart.data.datasets
      var s = a._getMatchingVisibleMetas()
      var l = r.stacked
      var u = {}
      var d = s.length
      if (
        ((a.min = Number.POSITIVE_INFINITY),
        (a.max = Number.NEGATIVE_INFINITY),
        void 0 === l)
      ) { for (t = 0; !l && t < d; ++t) l = void 0 !== (e = s[t]).stack }
      for (t = 0; t < d; ++t) { (n = o[(e = s[t]).index].data), l ? Tn(a, u, e, n) : On(a, e, n) }
      B.each(u, function (t) {
        (i = t.pos.concat(t.neg)),
        (a.min = Math.min(a.min, B.min(i))),
        (a.max = Math.max(a.max, B.max(i)))
      }),
      (a.min = B.isFinite(a.min) && !isNaN(a.min) ? a.min : 0),
      (a.max = B.isFinite(a.max) && !isNaN(a.max) ? a.max : 1),
      a.handleTickRangeOptions()
    },
    _computeTickLimit: function () {
      let t
      return this.isHorizontal()
        ? Math.ceil(this.width / 40)
        : ((t = B.options._parseFont(this.options.ticks)),
          Math.ceil(this.height / t.lineHeight))
    },
    handleDirectionalChanges: function () {
      this.isHorizontal() || this.ticks.reverse()
    },
    getLabelForIndex: function (t, e) {
      return this._getScaleLabel(this.chart.data.datasets[e].data[t])
    },
    getPixelForValue: function (t) {
      return this.getPixelForDecimal(
        (+this.getRightValue(t) - this._startValue) / this._valueRange
      )
    },
    getValueForPixel: function (t) {
      return this._startValue + this.getDecimalForPixel(t) * this._valueRange
    },
    getPixelForTick: function (t) {
      const e = this.ticksAsNumbers
      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t])
    }
  })
  let Fn = Pn
  An._defaults = Fn
  const In = B.valueOrDefault
  let Ln = B.math.log10
  const Rn = { position: 'left', ticks: { callback: sn.formatters.logarithmic } }
  function Nn (t, e) {
    return B.isFinite(t) && t >= 0 ? t : e
  }
  const Wn = _n.extend({
    determineDataLimits: function () {
      let t
      var e
      var n
      var i
      var a
      var r
      var o = this
      var s = o.options
      var l = o.chart
      var u = l.data.datasets
      var d = o.isHorizontal()
      function h (t) {
        return d ? t.xAxisID === o.id : t.yAxisID === o.id
      }
      (o.min = Number.POSITIVE_INFINITY),
      (o.max = Number.NEGATIVE_INFINITY),
      (o.minNotZero = Number.POSITIVE_INFINITY)
      let c = s.stacked
      if (void 0 === c) {
 for (t = 0; t < u.length; t++)
        {if (
          ((e = l.getDatasetMeta(t)),
          l.isDatasetVisible(t) && h(e) && void 0 !== e.stack)
        ) {
          c = !0
              break;
        }} 
}
      if (s.stacked || c) {
        const f = {}
        for (t = 0; t < u.length; t++) {
          const g = [
            (e = l.getDatasetMeta(t)).type,
            void 0 === s.stacked && void 0 === e.stack ? t : '',
            e.stack
          ].join('.')
          if (l.isDatasetVisible(t) && h(e)) {
 for (
            void 0 === f[g] && (f[g] = []),
            a = 0,
            r = (i = u[t].data).length;
            a < r;
            a++
          ) {
            let m = f[g];
            (n = o._parseValue(i[a])),
            isNaN(n.min) ||
                    isNaN(n.max) ||
                    e.data[a].hidden ||
                    n.min < 0 ||
                    n.max < 0 ||
                    ((m[a] = m[a] || 0), (m[a] += n.max))
          } }
        }
        B.each(f, function (t) {
          if (t.length > 0) {
            const e = B.min(t)
            var n = B.max(t);
            (o.min = Math.min(o.min, e)), (o.max = Math.max(o.max, n))
          }
        })
      } else {
 for (t = 0; t < u.length; t++)
        {if (((e = l.getDatasetMeta(t)), l.isDatasetVisible(t) && h(e)))
          for (a = 0, r = (i = u[t].data).length; a < r; a++)
            (n = o._parseValue(i[a])),
            isNaN(n.min) ||
                    isNaN(n.max) ||
                    e.data[a].hidden ||
                    n.min < 0 ||
                    n.max < 0 ||
                    ((o.min = Math.min(n.min, o.min)),
                    (o.max = Math.max(n.max, o.max)),
                    n.min !== 0 &&
                      (o.minNotZero = Math.min(n.min, o.minNotZero)))}}
      (o.min = B.isFinite(o.min) ? o.min : null),
      (o.max = B.isFinite(o.max) ? o.max : null),
      (o.minNotZero = B.isFinite(o.minNotZero) ? o.minNotZero : null),
      this.handleTickRangeOptions()
    },
    handleTickRangeOptions: function () {
      const t = this
      var e = t.options.ticks;
      (t.min = Nn(e.min, t.min)),
      (t.max = Nn(e.max, t.max)),
      t.min === t.max &&
            (t.min !== 0 && t.min !== null
              ? ((t.min = Math.pow(10, Math.floor(Ln(t.min)) - 1)),
                (t.max = Math.pow(10, Math.floor(Ln(t.max)) + 1)))
              : ((t.min = 1), (t.max = 10))),
      t.min === null && (t.min = Math.pow(10, Math.floor(Ln(t.max)) - 1)),
      t.max === null &&
            (t.max =
              t.min !== 0 ? Math.pow(10, Math.floor(Ln(t.min)) + 1) : 10),
      t.minNotZero === null &&
            (t.min > 0
              ? (t.minNotZero = t.min)
              : t.max < 1
                ? (t.minNotZero = Math.pow(10, Math.floor(Ln(t.max))))
                : (t.minNotZero = 1))
    },
    buildTicks: function () {
      const t = this
      var e = t.options.ticks
      var n = !t.isHorizontal()
      var i = { min: Nn(e.min), max: Nn(e.max) }
      var a = (t.ticks = (function (t, e) {
        let n
        var i
        var a = []
        var r = In(t.min, Math.pow(10, Math.floor(Ln(e.min))))
        var o = Math.floor(Ln(e.max))
        var s = Math.ceil(e.max / Math.pow(10, o))
        r === 0
          ? ((n = Math.floor(Ln(e.minNotZero))),
            (i = Math.floor(e.minNotZero / Math.pow(10, n))),
            a.push(r),
            (r = i * Math.pow(10, n)))
          : ((n = Math.floor(Ln(r))),
            (i = Math.floor(r / Math.pow(10, n))))
        let l = n < 0 ? Math.pow(10, Math.abs(n)) : 1
        do {
          a.push(r),
          ++i === 10 && ((i = 1), (l = ++n >= 0 ? 1 : l)),
          (r = Math.round(i * Math.pow(10, n) * l) / l)
        } while (n < o || (n === o && i < s))
        let u = In(t.max, r)
        return a.push(u), a
      })(i, t));
      (t.max = B.max(a)),
      (t.min = B.min(a)),
      e.reverse
        ? ((n = !n), (t.start = t.max), (t.end = t.min))
        : ((t.start = t.min), (t.end = t.max)),
      n && a.reverse()
    },
    convertTicksToLabels: function () {
      (this.tickValues = this.ticks.slice()),
      _n.prototype.convertTicksToLabels.call(this)
    },
    getLabelForIndex: function (t, e) {
      return this._getScaleLabel(this.chart.data.datasets[e].data[t])
    },
    getPixelForTick: function (t) {
      const e = this.tickValues
      return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t])
    },
    _getFirstTickValue: function (t) {
      const e = Math.floor(Ln(t))
      return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e)
    },
    _configure: function () {
      const t = this
      var e = t.min
      var n = 0
      _n.prototype._configure.call(t),
      e === 0 &&
            ((e = t._getFirstTickValue(t.minNotZero)),
            (n =
              In(t.options.ticks.fontSize, Y.global.defaultFontSize) /
              t._length)),
      (t._startValue = Ln(e)),
      (t._valueOffset = n),
      (t._valueRange = (Ln(t.max) - Ln(e)) / (1 - n))
    },
    getPixelForValue: function (t) {
      const e = this
      var n = 0
      return (
        (t = +e.getRightValue(t)) > e.min &&
            t > 0 &&
            (n = (Ln(t) - e._startValue) / e._valueRange + e._valueOffset),
        e.getPixelForDecimal(n)
      )
    },
    getValueForPixel: function (t) {
      const e = this
      var n = e.getDecimalForPixel(t)
      return n === 0 && e.min === 0
        ? 0
        : Math.pow(10, e._startValue + (n - e._valueOffset) * e._valueRange)
    }
  })
  let Yn = Rn
  Wn._defaults = Yn
  const zn = B.valueOrDefault
  let En = B.valueAtIndexOrDefault
  let Vn = B.options.resolve
  let Hn = {
    display: !0,
    animate: !0,
    position: 'chartArea',
    angleLines: {
      display: !0,
      color: 'rgba(0,0,0,0.1)',
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0
    },
    gridLines: { circular: !1 },
    ticks: {
      showLabelBackdrop: !0,
      backdropColor: 'rgba(255,255,255,0.75)',
      backdropPaddingY: 2,
      backdropPaddingX: 2,
      callback: sn.formatters.linear
    },
    pointLabels: {
      display: !0,
      fontSize: 10,
      callback: function (t) {
        return t
      }
    }
  }
  function Bn (t) {
    const e = t.ticks
    return e.display && t.display
      ? zn(e.fontSize, Y.global.defaultFontSize) + 2 * e.backdropPaddingY
      : 0
  }
  function jn (t, e, n, i, a) {
    return t === i || t === a
      ? { start: e - n / 2, end: e + n / 2 }
      : t < i || t > a
        ? { start: e - n, end: e }
        : { start: e, end: e + n }
  }
  function Un (t) {
    return t === 0 || t === 180 ? 'center' : t < 180 ? 'left' : 'right'
  }
  function Gn (t, e, n, i) {
    let a
    let r
    let o = n.y + i / 2
    if (B.isArray(e)) { for (a = 0, r = e.length; a < r; ++a) t.fillText(e[a], n.x, o), (o += i) } else t.fillText(e, n.x, o)
  }
  function qn (t, e, n) {
    t === 90 || t === 270
      ? (n.y -= e.h / 2)
      : (t > 270 || t < 90) && (n.y -= e.h)
  }
  function Zn (t) {
    return B.isNumber(t) ? t : 0
  }
  const $n = Cn.extend({
    setDimensions: function () {
      const t = this;
      (t.width = t.maxWidth),
      (t.height = t.maxHeight),
      (t.paddingTop = Bn(t.options) / 2),
      (t.xCenter = Math.floor(t.width / 2)),
      (t.yCenter = Math.floor((t.height - t.paddingTop) / 2)),
      (t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2)
    },
    determineDataLimits: function () {
      const t = this
      var e = t.chart
      var n = Number.POSITIVE_INFINITY
      var i = Number.NEGATIVE_INFINITY
      B.each(e.data.datasets, function (a, r) {
        if (e.isDatasetVisible(r)) {
          const o = e.getDatasetMeta(r)
          B.each(a.data, function (e, a) {
            const r = +t.getRightValue(e)
            isNaN(r) ||
                o.data[a].hidden ||
                ((n = Math.min(r, n)), (i = Math.max(r, i)))
          })
        }
      }),
      (t.min = n === Number.POSITIVE_INFINITY ? 0 : n),
      (t.max = i === Number.NEGATIVE_INFINITY ? 0 : i),
      t.handleTickRangeOptions()
    },
    _computeTickLimit: function () {
      return Math.ceil(this.drawingArea / Bn(this.options))
    },
    convertTicksToLabels: function () {
      const t = this
      Cn.prototype.convertTicksToLabels.call(t),
      (t.pointLabels = t.chart.data.labels.map(function () {
        let e = B.callback(t.options.pointLabels.callback, arguments, t)
        return e || e === 0 ? e : ''
      }))
    },
    getLabelForIndex: function (t, e) {
      return +this.getRightValue(this.chart.data.datasets[e].data[t])
    },
    fit: function () {
      const t = this.options
      t.display && t.pointLabels.display
        ? (function (t) {
            let e
            var n
            var i
            var a = B.options._parseFont(t.options.pointLabels)
            var r = { l: 0, r: t.width, t: 0, b: t.height - t.paddingTop }
            var o = {};
            (t.ctx.font = a.string), (t._pointLabelSizes = [])
            let s
            var l
            var u
            var d = t.chart.data.labels.length
            for (e = 0; e < d; e++) {
              (i = t.getPointPosition(e, t.drawingArea + 5)),
              (s = t.ctx),
              (l = a.lineHeight),
              (u = t.pointLabels[e]),
              (n = B.isArray(u)
                ? { w: B.longestText(s, s.font, u), h: u.length * l }
                : { w: s.measureText(u).width, h: l }),
              (t._pointLabelSizes[e] = n)
              let h = t.getIndexAngle(e)
              var c = B.toDegrees(h) % 360
              var f = jn(c, i.x, n.w, 0, 180)
              var g = jn(c, i.y, n.h, 90, 270)
              f.start < r.l && ((r.l = f.start), (o.l = h)),
              f.end > r.r && ((r.r = f.end), (o.r = h)),
              g.start < r.t && ((r.t = g.start), (o.t = h)),
              g.end > r.b && ((r.b = g.end), (o.b = h))
            }
            t.setReductions(t.drawingArea, r, o)
          })(this)
        : this.setCenterPoint(0, 0, 0, 0)
    },
    setReductions: function (t, e, n) {
      const i = this
      var a = e.l / Math.sin(n.l)
      var r = Math.max(e.r - i.width, 0) / Math.sin(n.r)
      var o = -e.t / Math.cos(n.t)
      var s = -Math.max(e.b - (i.height - i.paddingTop), 0) / Math.cos(n.b);
      (a = Zn(a)),
      (r = Zn(r)),
      (o = Zn(o)),
      (s = Zn(s)),
      (i.drawingArea = Math.min(
        Math.floor(t - (a + r) / 2),
        Math.floor(t - (o + s) / 2)
      )),
      i.setCenterPoint(a, r, o, s)
    },
    setCenterPoint: function (t, e, n, i) {
      const a = this
      var r = a.width - e - a.drawingArea
      var o = t + a.drawingArea
      var s = n + a.drawingArea
      var l = a.height - a.paddingTop - i - a.drawingArea;
      (a.xCenter = Math.floor((o + r) / 2 + a.left)),
      (a.yCenter = Math.floor((s + l) / 2 + a.top + a.paddingTop))
    },
    getIndexAngle: function (t) {
      const e = this.chart
      var n =
            (t * (360 / e.data.labels.length) +
              ((e.options || {}).startAngle || 0)) %
            360
      return ((n < 0 ? n + 360 : n) * Math.PI * 2) / 360
    },
    getDistanceFromCenterForValue: function (t) {
      const e = this
      if (B.isNullOrUndef(t)) return NaN
      let n = e.drawingArea / (e.max - e.min)
      return e.options.ticks.reverse ? (e.max - t) * n : (t - e.min) * n
    },
    getPointPosition: function (t, e) {
      const n = this.getIndexAngle(t) - Math.PI / 2
      return {
        x: Math.cos(n) * e + this.xCenter,
        y: Math.sin(n) * e + this.yCenter
      }
    },
    getPointPositionForValue: function (t, e) {
      return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
    },
    getBasePosition: function (t) {
      const e = this.min
      var n = this.max
      return this.getPointPositionForValue(
        t || 0,
        this.beginAtZero ? 0 : e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0
      )
    },
    _drawGrid: function () {
      let t
      var e
      var n
      var i = this
      var a = i.ctx
      var r = i.options
      var o = r.gridLines
      var s = r.angleLines
      var l = zn(s.lineWidth, o.lineWidth)
      var u = zn(s.color, o.color)
      if (
        (r.pointLabels.display &&
            (function (t) {
              const e = t.ctx
              var n = t.options
              var i = n.pointLabels
              var a = Bn(n)
              var r = t.getDistanceFromCenterForValue(
                n.ticks.reverse ? t.min : t.max
              )
              var o = B.options._parseFont(i)
              e.save(), (e.font = o.string), (e.textBaseline = 'middle')
              for (let s = t.chart.data.labels.length - 1; s >= 0; s--) {
                const l = s === 0 ? a / 2 : 0
                var u = t.getPointPosition(s, r + l + 5)
                var d = En(i.fontColor, s, Y.global.defaultFontColor)
                e.fillStyle = d
                const h = t.getIndexAngle(s)
                var c = B.toDegrees(h);
                (e.textAlign = Un(c)),
                qn(c, t._pointLabelSizes[s], u),
                Gn(e, t.pointLabels[s], u, o.lineHeight)
              }
              e.restore()
            })(i),
        o.display &&
            B.each(i.ticks, function (t, n) {
              n !== 0 &&
                ((e = i.getDistanceFromCenterForValue(i.ticksAsNumbers[n])),
                (function (t, e, n, i) {
                  let a
                  var r = t.ctx
                  var o = e.circular
                  var s = t.chart.data.labels.length
                  var l = En(e.color, i - 1)
                  var u = En(e.lineWidth, i - 1)
                  if ((o || s) && l && u) {
                    if (
                      (r.save(),
                      (r.strokeStyle = l),
                      (r.lineWidth = u),
                      r.setLineDash &&
                        (r.setLineDash(e.borderDash || []),
                        (r.lineDashOffset = e.borderDashOffset || 0)),
                      r.beginPath(),
                      o)
                    ) { r.arc(t.xCenter, t.yCenter, n, 0, 2 * Math.PI) } else {
                      (a = t.getPointPosition(0, n)), r.moveTo(a.x, a.y)
                      for (let d = 1; d < s; d++) { (a = t.getPointPosition(d, n)), r.lineTo(a.x, a.y) }
                    }
                    r.closePath(), r.stroke(), r.restore()
                  }
                })(i, o, e, n))
            }),
        s.display && l && u)
      ) {
        for (
          a.save(),
          a.lineWidth = l,
          a.strokeStyle = u,
          a.setLineDash &&
                (a.setLineDash(Vn([s.borderDash, o.borderDash, []])),
                (a.lineDashOffset = Vn([
                  s.borderDashOffset,
                  o.borderDashOffset,
                  0
                ]))),
          t = i.chart.data.labels.length - 1;
          t >= 0;
          t--
        ) {
 (e = i.getDistanceFromCenterForValue(
          r.ticks.reverse ? i.min : i.max
        )),
        (n = i.getPointPosition(t, e)),
        a.beginPath(),
        a.moveTo(i.xCenter, i.yCenter),
        a.lineTo(n.x, n.y),
        a.stroke() }
        a.restore()
      }
    },
    _drawLabels: function () {
      const t = this
      var e = t.ctx
      var n = t.options.ticks
      if (n.display) {
        let i
        var a
        var r = t.getIndexAngle(0)
        var o = B.options._parseFont(n)
        var s = zn(n.fontColor, Y.global.defaultFontColor)
        e.save(),
        (e.font = o.string),
        e.translate(t.xCenter, t.yCenter),
        e.rotate(r),
        (e.textAlign = 'center'),
        (e.textBaseline = 'middle'),
        B.each(t.ticks, function (r, l) {
          (l !== 0 || n.reverse) &&
                ((i = t.getDistanceFromCenterForValue(t.ticksAsNumbers[l])),
                n.showLabelBackdrop &&
                  ((a = e.measureText(r).width),
                  (e.fillStyle = n.backdropColor),
                  e.fillRect(
                    -a / 2 - n.backdropPaddingX,
                    -i - o.size / 2 - n.backdropPaddingY,
                    a + 2 * n.backdropPaddingX,
                    o.size + 2 * n.backdropPaddingY
                  )),
                (e.fillStyle = s),
                e.fillText(r, 0, -i))
        }),
        e.restore()
      }
    },
    _drawTitle: B.noop
  })
  let Xn = Hn
  $n._defaults = Xn
  const Kn = B._deprecated
  let Jn = B.options.resolve
  let Qn = B.valueOrDefault
  let ti = Number.MIN_SAFE_INTEGER || -9007199254740991
  let ei = Number.MAX_SAFE_INTEGER || 9007199254740991
  let ni = {
    millisecond: { common: !0, size: 1, steps: 1e3 },
    second: { common: !0, size: 1e3, steps: 60 },
    minute: { common: !0, size: 6e4, steps: 60 },
    hour: { common: !0, size: 36e5, steps: 24 },
    day: { common: !0, size: 864e5, steps: 30 },
    week: { common: !1, size: 6048e5, steps: 4 },
    month: { common: !0, size: 2628e6, steps: 12 },
    quarter: { common: !1, size: 7884e6, steps: 4 },
    year: { common: !0, size: 3154e7 }
  }
  let ii = Object.keys(ni)
  function ai (t, e) {
    return t - e
  }
  function ri (t) {
    return B.valueOrDefault(t.time.min, t.ticks.min)
  }
  function oi (t) {
    return B.valueOrDefault(t.time.max, t.ticks.max)
  }
  function si (t, e, n, i) {
    const a = (function (t, e, n) {
      for (var i, a, r, o = 0, s = t.length - 1; o >= 0 && o <= s;) {
        if (((a = t[(i = (o + s) >> 1) - 1] || null), (r = t[i]), !a)) { return { lo: null, hi: r } }
        if (r[e] < n) o = i + 1
        else {
          if (!(a[e] > n)) return { lo: a, hi: r }
          s = i - 1
        }
      }
      return { lo: r, hi: null }
    })(t, e, n)
    let r = a.lo ? (a.hi ? a.lo : t[t.length - 2]) : t[0]
    let o = a.lo ? (a.hi ? a.hi : t[t.length - 1]) : t[1]
    let s = o[e] - r[e]
    let l = s ? (n - r[e]) / s : 0
    let u = (o[i] - r[i]) * l
    return r[i] + u
  }
  function li (t, e) {
    const n = t._adapter
    let i = t.options.time
    let a = i.parser
    let r = a || i.format
    let o = e
    return (
      typeof a === 'function' && (o = a(o)),
      B.isFinite(o) || (o = typeof r === 'string' ? n.parse(o, r) : n.parse(o)),
      o !== null
        ? +o
        : (a ||
            typeof r !== 'function' ||
            ((o = r(e)), B.isFinite(o) || (o = n.parse(o))),
          o)
    )
  }
  function ui (t, e) {
    if (B.isNullOrUndef(e)) return null
    const n = t.options.time
    let i = li(t, t.getRightValue(e))
    return i === null
      ? i
      : (n.round && (i = +t._adapter.startOf(i, n.round)), i)
  }
  function di (t, e, n, i) {
    let a
    let r
    let o
    let s = ii.length
    for (a = ii.indexOf(t); a < s - 1; ++a) {
      if (
        ((o = (r = ni[ii[a]]).steps ? r.steps : ei),
        r.common && Math.ceil((n - e) / (o * r.size)) <= i)
      ) { return ii[a] } }
    return ii[s - 1]
  }
  function hi (t, e, n) {
    let i
    let a
    let r = []
    let o = {}
    let s = e.length
    for (i = 0; i < s; ++i) { (o[(a = e[i])] = i), r.push({ value: a, major: !1 }) }
    return s !== 0 && n
      ? (function (t, e, n, i) {
          let a
          let r
          let o = t._adapter
          let s = +o.startOf(e[0].value, i)
          let l = e[e.length - 1].value
          for (a = s; a <= l; a = +o.add(a, 1, i)) { (r = n[a]) >= 0 && (e[r].major = !0) }
          return e
        })(t, r, o, n)
      : r
  }
  const ci = _n.extend({
    initialize: function () {
      this.mergeTicksOptions(), _n.prototype.initialize.call(this)
    },
    update: function () {
      const t = this
      var e = t.options
      var n = e.time || (e.time = {})
      var i = (t._adapter = new on._date(e.adapters.date))
      return (
        Kn('time scale', n.format, 'time.format', 'time.parser'),
        Kn('time scale', n.min, 'time.min', 'ticks.min'),
        Kn('time scale', n.max, 'time.max', 'ticks.max'),
        B.mergeIf(n.displayFormats, i.formats()),
        _n.prototype.update.apply(t, arguments)
      )
    },
    getRightValue: function (t) {
      return (
        t && void 0 !== t.t && (t = t.t),
        _n.prototype.getRightValue.call(this, t)
      )
    },
    determineDataLimits: function () {
      let t
      var e
      var n
      var i
      var a
      var r
      var o
      var s = this
      var l = s.chart
      var u = s._adapter
      var d = s.options
      var h = d.time.unit || 'day'
      var c = ei
      var f = ti
      var g = []
      var m = []
      var p = []
      var v = s._getLabels()
      for (t = 0, n = v.length; t < n; ++t) p.push(ui(s, v[t]))
      for (t = 0, n = (l.data.datasets || []).length; t < n; ++t) {
 if (l.isDatasetVisible(t))
        {if (((a = l.data.datasets[t].data), B.isObject(a[0])))
          for (m[t] = [], e = 0, i = a.length; e < i; ++e)
            (r = ui(s, a[e])), g.push(r), (m[t][e] = r)
            else (m[t] = p.slice(0)), o || ((g = g.concat(p)), (o = !0))}
      else m[t] = [] }
      p.length &&
          ((c = Math.min(c, p[0])), (f = Math.max(f, p[p.length - 1]))),
      g.length &&
            ((g =
              n > 1
                ? (function (t) {
                    let e
                    var n
                    var i
                    var a = {}
                    var r = []
                    for (e = 0, n = t.length; e < n; ++e) { a[(i = t[e])] || ((a[i] = !0), r.push(i)) }
                    return r
                  })(g).sort(ai)
                : g.sort(ai)),
            (c = Math.min(c, g[0])),
            (f = Math.max(f, g[g.length - 1]))),
      (c = ui(s, ri(d)) || c),
      (f = ui(s, oi(d)) || f),
      (c = c === ei ? +u.startOf(Date.now(), h) : c),
      (f = f === ti ? +u.endOf(Date.now(), h) + 1 : f),
      (s.min = Math.min(c, f)),
      (s.max = Math.max(c + 1, f)),
      (s._table = []),
      (s._timestamps = { data: g, datasets: m, labels: p })
    },
    buildTicks: function () {
      let t
      var e
      var n
      var i = this
      var a = i.min
      var r = i.max
      var o = i.options
      var s = o.ticks
      var l = o.time
      var u = i._timestamps
      var d = []
      var h = i.getLabelCapacity(a)
      var c = s.source
      var f = o.distribution
      for (
        u =
            c === 'data' || (c === 'auto' && f === 'series')
              ? u.data
              : c === 'labels'
                ? u.labels
                : (function (t, e, n, i) {
                    let a
                    let r = t._adapter
                    let o = t.options
                    let s = o.time
                    let l = s.unit || di(s.minUnit, e, n, i)
                    let u = Jn([s.stepSize, s.unitStepSize, 1])
                    let d = l === 'week' && s.isoWeekday
                    let h = e
                    let c = []
                    if (
                      (d && (h = +r.startOf(h, 'isoWeek', d)),
                      (h = +r.startOf(h, d ? 'day' : l)),
                      r.diff(n, e, l) > 1e5 * u)
                    ) { throw (
                      e +
                      ' and ' +
                      n +
                      ' are too far apart with stepSize of ' +
                      u +
                      ' ' +
                      l
                    ); }
                    for (a = h; a < n; a = +r.add(a, u, l)) c.push(a)
                    return (a !== n && o.bounds !== 'ticks') || c.push(a), c
                  })(i, a, r, h),
        'ticks' === o.bounds &&
              u.length &&
              ((a = u[0]), (r = u[u.length - 1])),
        a = ui(i, ri(o)) || a,
        r = ui(i, oi(o)) || r,
        t = 0,
        e = u.length;
        t < e;
        ++t
      ) { (n = u[t]) >= a && n <= r && d.push(n) }
      return (
        (i.min = a),
        (i.max = r),
        (i._unit =
            l.unit ||
            (s.autoSkip
              ? di(l.minUnit, i.min, i.max, h)
              : (function (t, e, n, i, a) {
                  let r, o
                  for (r = ii.length - 1; r >= ii.indexOf(n); r--) {
 if (
                    ((o = ii[r]),
                    ni[o].common && t._adapter.diff(a, i, o) >= e - 1)
                  )
                    {return o}}
                  return ii[n ? ii.indexOf(n) : 0]
                })(i, d.length, l.minUnit, i.min, i.max))),
        (i._majorUnit =
            s.major.enabled && i._unit !== 'year'
              ? (function (t) {
                  for (let e = ii.indexOf(t) + 1, n = ii.length; e < n; ++e) { if (ni[ii[e]].common) return ii[e] }
                })(i._unit)
              : void 0),
        (i._table = (function (t, e, n, i) {
          if (i === 'linear' || !t.length) {
 return [
            { time: e, pos: 0 },
            { time: n, pos: 1 }
          ] }
          let a
          var r
          var o
          var s
          var l
          var u = []
          var d = [e]
          for (a = 0, r = t.length; a < r; ++a) { (s = t[a]) > e && s < n && d.push(s) }
          for (d.push(n), a = 0, r = d.length; a < r; ++a) {
 (l = d[a + 1]),
          (o = d[a - 1]),
          (s = d[a]),
          (void 0 !== o &&
                  void 0 !== l &&
                  Math.round((l + o) / 2) === s) ||
                  u.push({ time: s, pos: a / (r - 1) }) }
          return u
        })(i._timestamps.data, a, r, f)),
        (i._offsets = (function (t, e, n, i, a) {
          let r
          var o
          var s = 0
          var l = 0
          return (
            a.offset &&
                e.length &&
                ((r = si(t, 'time', e[0], 'pos')),
                (s =
                  e.length === 1
                    ? 1 - r
                    : (si(t, 'time', e[1], 'pos') - r) / 2),
                (o = si(t, 'time', e[e.length - 1], 'pos')),
                (l =
                  e.length === 1
                    ? o
                    : (o - si(t, 'time', e[e.length - 2], 'pos')) / 2)),
            { start: s, end: l, factor: 1 / (s + 1 + l) }
          )
        })(i._table, d, 0, 0, o)),
        s.reverse && d.reverse(),
        hi(i, d, i._majorUnit)
      )
    },
    getLabelForIndex: function (t, e) {
      const n = this
      var i = n._adapter
      var a = n.chart.data
      var r = n.options.time
      var o = a.labels && t < a.labels.length ? a.labels[t] : ''
      var s = a.datasets[e].data[t]
      return (
        B.isObject(s) && (o = n.getRightValue(s)),
        r.tooltipFormat
          ? i.format(li(n, o), r.tooltipFormat)
          : typeof o === 'string'
            ? o
            : i.format(li(n, o), r.displayFormats.datetime)
      )
    },
    tickFormatFunction: function (t, e, n, i) {
      const a = this._adapter
      var r = this.options
      var o = r.time.displayFormats
      var s = o[this._unit]
      var l = this._majorUnit
      var u = o[l]
      var d = n[e]
      var h = r.ticks
      var c = l && u && d && d.major
      var f = a.format(t, i || (c ? u : s))
      var g = c ? h.major : h.minor
      var m = Jn([g.callback, g.userCallback, h.callback, h.userCallback])
      return m ? m(f, e, n) : f
    },
    convertTicksToLabels: function (t) {
      let e
      var n
      var i = []
      for (e = 0, n = t.length; e < n; ++e) { i.push(this.tickFormatFunction(t[e].value, e, t)) }
      return i
    },
    getPixelForOffset: function (t) {
      const e = this._offsets
      var n = si(this._table, 'time', t, 'pos')
      return this.getPixelForDecimal((e.start + n) * e.factor)
    },
    getPixelForValue: function (t, e, n) {
      let i = null
      if (
        (void 0 !== e &&
            void 0 !== n &&
            (i = this._timestamps.datasets[n][e]),
        i === null && (i = ui(this, t)),
        i !== null)
      ) { return this.getPixelForOffset(i) }
    },
    getPixelForTick: function (t) {
      const e = this.getTicks()
      return t >= 0 && t < e.length
        ? this.getPixelForOffset(e[t].value)
        : null
    },
    getValueForPixel: function (t) {
      const e = this._offsets
      var n = this.getDecimalForPixel(t) / e.factor - e.end
      var i = si(this._table, 'pos', n, 'time')
      return this._adapter._create(i)
    },
    _getLabelSize: function (t) {
      const e = this.options.ticks
      var n = this.ctx.measureText(t).width
      var i = B.toRadians(this.isHorizontal() ? e.maxRotation : e.minRotation)
      var a = Math.cos(i)
      var r = Math.sin(i)
      var o = Qn(e.fontSize, Y.global.defaultFontSize)
      return { w: n * a + o * r, h: n * r + o * a }
    },
    getLabelWidth: function (t) {
      return this._getLabelSize(t).w
    },
    getLabelCapacity: function (t) {
      const e = this
      var n = e.options.time
      var i = n.displayFormats
      var a = i[n.unit] || i.millisecond
      var r = e.tickFormatFunction(t, 0, hi(e, [t], e._majorUnit), a)
      var o = e._getLabelSize(r)
      var s = Math.floor(e.isHorizontal() ? e.width / o.w : e.height / o.h)
      return e.options.offset && s--, s > 0 ? s : 1
    }
  })
  let fi = {
    position: 'bottom',
    distribution: 'linear',
    bounds: 'data',
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      displayFormat: !1,
      isoWeekday: !1,
      minUnit: 'millisecond',
      displayFormats: {}
    },
    ticks: { autoSkip: !1, source: 'auto', major: { enabled: !1 } }
  }
  ci._defaults = fi
  const gi = {
    category: kn,
    linear: An,
    logarithmic: Wn,
    radialLinear: $n,
    time: ci
  }
  let mi = e(function (e, n) {
    e.exports = (function () {
      let n, i
      function a () {
        return n.apply(null, arguments)
      }
      function r (t) {
        return (
          t instanceof Array ||
            Object.prototype.toString.call(t) === '[object Array]'
        )
      }
      function o (t) {
        return (
          t != null && Object.prototype.toString.call(t) === '[object Object]'
        )
      }
      function s (t) {
        return void 0 === t
      }
      function l (t) {
        return (
          typeof t === 'number' ||
            Object.prototype.toString.call(t) === '[object Number]'
        )
      }
      function u (t) {
        return (
          t instanceof Date ||
            Object.prototype.toString.call(t) === '[object Date]'
        )
      }
      function d (t, e) {
        let n
        var i = []
        for (n = 0; n < t.length; ++n) i.push(e(t[n], n))
        return i
      }
      function h (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
      }
      function c (t, e) {
        for (const n in e) h(e, n) && (t[n] = e[n])
        return (
          h(e, 'toString') && (t.toString = e.toString),
          h(e, 'valueOf') && (t.valueOf = e.valueOf),
          t
        )
      }
      function f (t, e, n, i) {
        return Ie(t, e, n, i, !0).utc()
      }
      function g (t) {
        return (
          t._pf == null &&
              (t._pf = {
                empty: !1,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: !1,
                invalidMonth: null,
                invalidFormat: !1,
                userInvalidated: !1,
                iso: !1,
                parsedDateParts: [],
                meridiem: null,
                rfc2822: !1,
                weekdayMismatch: !1
              }),
          t._pf
        )
      }
      function m (t) {
        if (t._isValid == null) {
          const e = g(t)
          var n = i.call(e.parsedDateParts, function (t) {
            return t != null
          })
          var a =
                !isNaN(t._d.getTime()) &&
                e.overflow < 0 &&
                !e.empty &&
                !e.invalidMonth &&
                !e.invalidWeekday &&
                !e.weekdayMismatch &&
                !e.nullInput &&
                !e.invalidFormat &&
                !e.userInvalidated &&
                (!e.meridiem || (e.meridiem && n))
          if (
            (t._strict &&
                (a =
                  a &&
                  e.charsLeftOver === 0 &&
                  e.unusedTokens.length === 0 &&
                  void 0 === e.bigHour),
            Object.isFrozen != null && Object.isFrozen(t))
          ) { return a }
          t._isValid = a
        }
        return t._isValid
      }
      function p (t) {
        const e = f(NaN)
        return t != null ? c(g(e), t) : (g(e).userInvalidated = !0), e
      }
      i = Array.prototype.some
        ? Array.prototype.some
        : function (t) {
          for (let e = Object(this), n = e.length >>> 0, i = 0; i < n; i++) { if (i in e && t.call(this, e[i], i, e)) return !0 }
          return !1
        }
      let v = (a.momentProperties = [])
      function b (t, e) {
        let n, i, a
        if (
          (s(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject),
          s(e._i) || (t._i = e._i),
          s(e._f) || (t._f = e._f),
          s(e._l) || (t._l = e._l),
          s(e._strict) || (t._strict = e._strict),
          s(e._tzm) || (t._tzm = e._tzm),
          s(e._isUTC) || (t._isUTC = e._isUTC),
          s(e._offset) || (t._offset = e._offset),
          s(e._pf) || (t._pf = g(e)),
          s(e._locale) || (t._locale = e._locale),
          v.length > 0)
        ) { for (n = 0; n < v.length; n++) s((a = e[(i = v[n])])) || (t[i] = a) }
        return t
      }
      let y = !1
      function x (t) {
        b(this, t),
        (this._d = new Date(t._d != null ? t._d.getTime() : NaN)),
        this.isValid() || (this._d = new Date(NaN)),
        !1 === y && ((y = !0), a.updateOffset(this), (y = !1))
      }
      function _ (t) {
        return t instanceof x || (t != null && t._isAMomentObject != null)
      }
      function w (t) {
        return t < 0 ? Math.ceil(t) || 0 : Math.floor(t)
      }
      function k (t) {
        const e = +t
        var n = 0
        return e !== 0 && isFinite(e) && (n = w(e)), n
      }
      function M (t, e, n) {
        let i
        var a = Math.min(t.length, e.length)
        var r = Math.abs(t.length - e.length)
        var o = 0
        for (i = 0; i < a; i++) { ((n && t[i] !== e[i]) || (!n && k(t[i]) !== k(e[i]))) && o++ }
        return o + r
      }
      function S (t) {
        !1 === a.suppressDeprecationWarnings &&
            typeof console !== 'undefined' &&
            console.warn &&
            console.warn('Deprecation warning: ' + t)
      }
      function D (t, e) {
        let n = !0
        return c(function () {
          if (
            (a.deprecationHandler != null && a.deprecationHandler(null, t), n)
          ) {
            for (var i, r = [], o = 0; o < arguments.length; o++) {
              if (((i = ''), typeof arguments[o] === 'object')) {
                for (const s in ((i += '\n[' + o + '] '), arguments[0])) { i += s + ': ' + arguments[0][s] + ', '}
                i = i.slice(0, -2)
              } else i = arguments[o]
              r.push(i)
            }
            S(
              t +
                  '\nArguments: ' +
                  Array.prototype.slice.call(r).join('') +
                  '\n' +
                  new Error().stack
            ),
            (n = !1)
          }
          return e.apply(this, arguments)
        }, e)
      }
      let C
      var P = {}
      function T (t, e) {
        a.deprecationHandler != null && a.deprecationHandler(t, e),
        P[t] || (S(e), (P[t] = !0))
      }
      function O (t) {
        return (
          t instanceof Function ||
            Object.prototype.toString.call(t) === '[object Function]'
        )
      }
      function A (t, e) {
        let n
        var i = c({}, t)
        for (n in e) { h(e, n) &&
              (o(t[n]) && o(e[n])
                ? ((i[n] = {}), c(i[n], t[n]), c(i[n], e[n]))
                : e[n] != null
                  ? (i[n] = e[n])
                  : delete i[n]) }
        for (n in t) h(t, n) && !h(e, n) && o(t[n]) && (i[n] = c({}, i[n]))
        return i
      }
      function F (t) {
        t != null && this.set(t)
      }
      (a.suppressDeprecationWarnings = !1),
      (a.deprecationHandler = null),
      (C = Object.keys
        ? Object.keys
        : function (t) {
          let e
          var n = []
          for (e in t) h(t, e) && n.push(e)
          return n
        })
      let I = {}
      function L (t, e) {
        const n = t.toLowerCase()
        I[n] = I[n + 's'] = I[e] = t
      }
      function R (t) {
        return typeof t === 'string' ? I[t] || I[t.toLowerCase()] : void 0
      }
      function N (t) {
        let e
        var n
        var i = {}
        for (n in t) h(t, n) && (e = R(n)) && (i[e] = t[n])
        return i
      }
      const W = {}
      function Y (t, e) {
        W[t] = e
      }
      function z (t, e, n) {
        const i = '' + Math.abs(t)
        var a = e - i.length
        return (
          (t >= 0 ? (n ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, a)).toString().substr(1) +
            i
        )
      }
      const E =
            /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g
      var V = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g
      var H = {}
      var B = {}
      function j (t, e, n, i) {
        let a = i
        'string' === typeof i &&
            (a = function () {
              return this[i]()
            }),
        t && (B[t] = a),
        e &&
              (B[e[0]] = function () {
                return z(a.apply(this, arguments), e[1], e[2])
              }),
        n &&
              (B[n] = function () {
                return this.localeData().ordinal(a.apply(this, arguments), t)
              })
      }
      function U (t, e) {
        return t.isValid()
          ? ((e = G(e, t.localeData())),
            (H[e] =
                H[e] ||
                (function (t) {
                  let e
                  var n
                  var i
                  var a = t.match(E)
                  for (e = 0, n = a.length; e < n; e++) {
 B[a[e]]
                    ? (a[e] = B[a[e]])
                    : (a[e] = (i = a[e]).match(/\[[\s\S]/)
                        ? i.replace(/^\[|\]$/g, '')
                        : i.replace(/\\/g, '')) }
                  return function (e) {
                    let i
                    var r = ''
                    for (i = 0; i < n; i++) { r += O(a[i]) ? a[i].call(e, t) : a[i] }
                    return r
                  }
                })(e)),
            H[e](t))
          : t.localeData().invalidDate()
      }
      function G (t, e) {
        let n = 5
        function i (t) {
          return e.longDateFormat(t) || t
        }
        for (V.lastIndex = 0; n >= 0 && V.test(t);) { (t = t.replace(V, i)), (V.lastIndex = 0), (n -= 1) }
        return t
      }
      const q = /\d/
      var Z = /\d\d/
      var $ = /\d{3}/
      var X = /\d{4}/
      var K = /[+-]?\d{6}/
      var J = /\d\d?/
      var Q = /\d\d\d\d?/
      var tt = /\d\d\d\d\d\d?/
      var et = /\d{1,3}/
      var nt = /\d{1,4}/
      var it = /[+-]?\d{1,6}/
      var at = /\d+/
      var rt = /[+-]?\d+/
      var ot = /Z|[+-]\d\d:?\d\d/gi
      var st = /Z|[+-]\d\d(?::?\d\d)?/gi
      var lt =
            /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i
      var ut = {}
      function dt (t, e, n) {
        ut[t] = O(e)
          ? e
          : function (t, i) {
            return t && n ? n : e
          }
      }
      function ht (t, e) {
        return h(ut, t)
          ? ut[t](e._strict, e._locale)
          : new RegExp(
            ct(
              t
                .replace('\\', '')
                .replace(
                  /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
                  function (t, e, n, i, a) {
                    return e || n || i || a
                  }
                )
            )
          )
      }
      function ct (t) {
        return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')
      }
      const ft = {}
      function gt (t, e) {
        let n
        var i = e
        for (
          typeof t === 'string' && (t = [t]),
          l(e) &&
                (i = function (t, n) {
                  n[e] = k(t)
                }),
          n = 0;
          n < t.length;
          n++
        ) { ft[t[n]] = i }
      }
      function mt (t, e) {
        gt(t, function (t, n, i, a) {
          (i._w = i._w || {}), e(t, i._w, i, a)
        })
      }
      function pt (t, e, n) {
        e != null && h(ft, t) && ft[t](e, n._a, n, t)
      }
      const vt = 0
      var bt = 1
      var yt = 2
      var xt = 3
      var _t = 4
      var wt = 5
      var kt = 6
      var Mt = 7
      var St = 8
      function Dt (t) {
        return Ct(t) ? 366 : 365
      }
      function Ct (t) {
        return (t % 4 == 0 && t % 100 != 0) || t % 400 == 0
      }
      j('Y', 0, 0, function () {
        const t = this.year()
        return t <= 9999 ? '' + t : '+' + t
      }),
      j(0, ['YY', 2], 0, function () {
        return this.year() % 100
      }),
      j(0, ['YYYY', 4], 0, 'year'),
      j(0, ['YYYYY', 5], 0, 'year'),
      j(0, ['YYYYYY', 6, !0], 0, 'year'),
      L('year', 'y'),
      Y('year', 1),
      dt('Y', rt),
      dt('YY', J, Z),
      dt('YYYY', nt, X),
      dt('YYYYY', it, K),
      dt('YYYYYY', it, K),
      gt(['YYYYY', 'YYYYYY'], vt),
      gt('YYYY', function (t, e) {
        e[vt] = t.length === 2 ? a.parseTwoDigitYear(t) : k(t)
      }),
      gt('YY', function (t, e) {
        e[vt] = a.parseTwoDigitYear(t)
      }),
      gt('Y', function (t, e) {
        e[vt] = parseInt(t, 10)
      }),
      (a.parseTwoDigitYear = function (t) {
        return k(t) + (k(t) > 68 ? 1900 : 2e3)
      })
      let Pt
      var Tt = Ot('FullYear', !0)
      function Ot (t, e) {
        return function (n) {
          return n != null
            ? (Ft(this, t, n), a.updateOffset(this, e), this)
            : At(this, t)
        }
      }
      function At (t, e) {
        return t.isValid()
          ? t._d['get' + (t._isUTC ? 'UTC' : '') + e]()
          : NaN
      }
      function Ft (t, e, n) {
        t.isValid() &&
            !isNaN(n) &&
            (e === 'FullYear' &&
            Ct(t.year()) &&
            t.month() === 1 &&
            t.date() === 29
              ? t._d['set' + (t._isUTC ? 'UTC' : '') + e](
                n,
                t.month(),
                It(n, t.month())
              )
              : t._d['set' + (t._isUTC ? 'UTC' : '') + e](n))
      }
      function It (t, e) {
        if (isNaN(t) || isNaN(e)) return NaN
        let n = (function (t, e) {
          return ((t % e) + e) % e
        })(e, 12)
        return (
          (t += (e - n) / 12),
          n === 1 ? (Ct(t) ? 29 : 28) : 31 - ((n % 7) % 2)
        )
      }
      (Pt = Array.prototype.indexOf
        ? Array.prototype.indexOf
        : function (t) {
          let e
          for (e = 0; e < this.length; ++e) if (this[e] === t) return e
          return -1
        }),
      j('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1
      }),
      j('MMM', 0, 0, function (t) {
        return this.localeData().monthsShort(this, t)
      }),
      j('MMMM', 0, 0, function (t) {
        return this.localeData().months(this, t)
      }),
      L('month', 'M'),
      Y('month', 8),
      dt('M', J),
      dt('MM', J, Z),
      dt('MMM', function (t, e) {
        return e.monthsShortRegex(t)
      }),
      dt('MMMM', function (t, e) {
        return e.monthsRegex(t)
      }),
      gt(['M', 'MM'], function (t, e) {
        e[bt] = k(t) - 1
      }),
      gt(['MMM', 'MMMM'], function (t, e, n, i) {
        const a = n._locale.monthsParse(t, i, n._strict)
        a != null ? (e[bt] = a) : (g(n).invalidMonth = t)
      })
      let Lt = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/
      var Rt =
            'January_February_March_April_May_June_July_August_September_October_November_December'.split(
              '_'
            )
      var Nt = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_')
      function Wt (t, e, n) {
        let i
        var a
        var r
        var o = t.toLocaleLowerCase()
        if (!this._monthsParse) { for (
          this._monthsParse = [],
          this._longMonthsParse = [],
          this._shortMonthsParse = [],
          i = 0;
          i < 12;
          ++i
        )
          (r = f([2e3, i])),
          (this._shortMonthsParse[i] = this.monthsShort(
            r,
            ""
          ).toLocaleLowerCase()),
          (this._longMonthsParse[i] = this.months(
            r,
            ""
          ).toLocaleLowerCase()) }
        return n
          ? e === 'MMM'
            ? (a = Pt.call(this._shortMonthsParse, o)) !== -1
                ? a
                : null
            : (a = Pt.call(this._longMonthsParse, o)) !== -1
                ? a
                : null
          : e === 'MMM'
            ? (a = Pt.call(this._shortMonthsParse, o)) !== -1
                ? a
                : (a = Pt.call(this._longMonthsParse, o)) !== -1
                    ? a
                    : null
            : (a = Pt.call(this._longMonthsParse, o)) !== -1
                ? a
                : (a = Pt.call(this._shortMonthsParse, o)) !== -1
                    ? a
                    : null
      }
      function Yt (t, e) {
        let n
        if (!t.isValid()) return t
        if (typeof e === 'string') { if (/^\d+$/.test(e)) e = k(e)
        else if (!l((e = t.localeData().monthsParse(e)))) return t }
        return (
          (n = Math.min(t.date(), It(t.year(), e))),
          t._d['set' + (t._isUTC ? 'UTC' : '') + 'Month'](e, n),
          t
        )
      }
      function zt (t) {
        return t != null
          ? (Yt(this, t), a.updateOffset(this, !0), this)
          : At(this, 'Month')
      }
      const Et = lt
      var Vt = lt
      function Ht () {
        function t (t, e) {
          return e.length - t.length
        }
        let e
        var n
        var i = []
        var a = []
        var r = []
        for (e = 0; e < 12; e++) { (n = f([2e3, e])),
        i.push(this.monthsShort(n, '')),
        a.push(this.months(n, '')),
        r.push(this.months(n, '')),
        r.push(this.monthsShort(n, '')) }
        for (i.sort(t), a.sort(t), r.sort(t), e = 0; e < 12; e++) { (i[e] = ct(i[e])), (a[e] = ct(a[e])) }
        for (e = 0; e < 24; e++) r[e] = ct(r[e]);
        (this._monthsRegex = new RegExp('^(' + r.join('|') + ')', 'i')),
        (this._monthsShortRegex = this._monthsRegex),
        (this._monthsStrictRegex = new RegExp(
          '^(' + a.join('|') + ')',
          'i'
        )),
        (this._monthsShortStrictRegex = new RegExp(
          '^(' + i.join('|') + ')',
          'i'
        ))
      }
      function Bt (t, e, n, i, a, r, o) {
        let s
        return (
          t < 100 && t >= 0
            ? ((s = new Date(t + 400, e, n, i, a, r, o)),
              isFinite(s.getFullYear()) && s.setFullYear(t))
            : (s = new Date(t, e, n, i, a, r, o)),
          s
        )
      }
      function jt (t) {
        let e
        if (t < 100 && t >= 0) {
          const n = Array.prototype.slice.call(arguments);
          (n[0] = t + 400),
          (e = new Date(Date.UTC.apply(null, n))),
          isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t)
        } else e = new Date(Date.UTC.apply(null, arguments))
        return e
      }
      function Ut (t, e, n) {
        const i = 7 + e - n
        return (-(7 + jt(t, 0, i).getUTCDay() - e) % 7) + i - 1
      }
      function Gt (t, e, n, i, a) {
        let r
        var o
        var s = 1 + 7 * (e - 1) + ((7 + n - i) % 7) + Ut(t, i, a)
        return (
          s <= 0
            ? (o = Dt((r = t - 1)) + s)
            : s > Dt(t)
              ? ((r = t + 1), (o = s - Dt(t)))
              : ((r = t), (o = s)),
          { year: r, dayOfYear: o }
        )
      }
      function qt (t, e, n) {
        let i
        var a
        var r = Ut(t.year(), e, n)
        var o = Math.floor((t.dayOfYear() - r - 1) / 7) + 1
        return (
          o < 1
            ? (i = o + Zt((a = t.year() - 1), e, n))
            : o > Zt(t.year(), e, n)
              ? ((i = o - Zt(t.year(), e, n)), (a = t.year() + 1))
              : ((a = t.year()), (i = o)),
          { week: i, year: a }
        )
      }
      function Zt (t, e, n) {
        const i = Ut(t, e, n)
        var a = Ut(t + 1, e, n)
        return (Dt(t) - i + a) / 7
      }
      function $t (t, e) {
        return t.slice(e, 7).concat(t.slice(0, e))
      }
      j('w', ['ww', 2], 'wo', 'week'),
      j('W', ['WW', 2], 'Wo', 'isoWeek'),
      L('week', 'w'),
      L('isoWeek', 'W'),
      Y('week', 5),
      Y('isoWeek', 5),
      dt('w', J),
      dt('ww', J, Z),
      dt('W', J),
      dt('WW', J, Z),
      mt(['w', 'ww', 'W', 'WW'], function (t, e, n, i) {
        e[i.substr(0, 1)] = k(t)
      }),
      j('d', 0, 'do', 'day'),
      j('dd', 0, 0, function (t) {
        return this.localeData().weekdaysMin(this, t)
      }),
      j('ddd', 0, 0, function (t) {
        return this.localeData().weekdaysShort(this, t)
      }),
      j('dddd', 0, 0, function (t) {
        return this.localeData().weekdays(this, t)
      }),
      j('e', 0, 0, 'weekday'),
      j('E', 0, 0, 'isoWeekday'),
      L('day', 'd'),
      L('weekday', 'e'),
      L('isoWeekday', 'E'),
      Y('day', 11),
      Y('weekday', 11),
      Y('isoWeekday', 11),
      dt('d', J),
      dt('e', J),
      dt('E', J),
      dt('dd', function (t, e) {
        return e.weekdaysMinRegex(t)
      }),
      dt('ddd', function (t, e) {
        return e.weekdaysShortRegex(t)
      }),
      dt('dddd', function (t, e) {
        return e.weekdaysRegex(t)
      }),
      mt(['dd', 'ddd', 'dddd'], function (t, e, n, i) {
        const a = n._locale.weekdaysParse(t, i, n._strict)
        a != null ? (e.d = a) : (g(n).invalidWeekday = t)
      }),
      mt(['d', 'e', 'E'], function (t, e, n, i) {
        e[i] = k(t)
      })
      let Xt =
            'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
              '_'
            )
      var Kt = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_')
      var Jt = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_')
      function Qt (t, e, n) {
        let i
        var a
        var r
        var o = t.toLocaleLowerCase()
        if (!this._weekdaysParse) { for (
          this._weekdaysParse = [],
          this._shortWeekdaysParse = [],
          this._minWeekdaysParse = [],
          i = 0;
          i < 7;
          ++i
        )
          (r = f([2e3, 1]).day(i)),
          (this._minWeekdaysParse[i] = this.weekdaysMin(
            r,
            ""
          ).toLocaleLowerCase()),
          (this._shortWeekdaysParse[i] = this.weekdaysShort(
            r,
            ""
          ).toLocaleLowerCase()),
          (this._weekdaysParse[i] = this.weekdays(
            r,
            ""
          ).toLocaleLowerCase()) }
        return n
          ? e === 'dddd'
            ? (a = Pt.call(this._weekdaysParse, o)) !== -1
                ? a
                : null
            : e === 'ddd'
              ? (a = Pt.call(this._shortWeekdaysParse, o)) !== -1
                  ? a
                  : null
              : (a = Pt.call(this._minWeekdaysParse, o)) !== -1
                  ? a
                  : null
          : e === 'dddd'
            ? (a = Pt.call(this._weekdaysParse, o)) !== -1
                ? a
                : (a = Pt.call(this._shortWeekdaysParse, o)) !== -1
                    ? a
                    : (a = Pt.call(this._minWeekdaysParse, o)) !== -1
                        ? a
                        : null
            : e === 'ddd'
              ? (a = Pt.call(this._shortWeekdaysParse, o)) !== -1
                  ? a
                  : (a = Pt.call(this._weekdaysParse, o)) !== -1
                      ? a
                      : (a = Pt.call(this._minWeekdaysParse, o)) !== -1
                          ? a
                          : null
              : (a = Pt.call(this._minWeekdaysParse, o)) !== -1
                  ? a
                  : (a = Pt.call(this._weekdaysParse, o)) !== -1
                      ? a
                      : (a = Pt.call(this._shortWeekdaysParse, o)) !== -1
                          ? a
                          : null
      }
      const te = lt
      var ee = lt
      var ne = lt
      function ie () {
        function t (t, e) {
          return e.length - t.length
        }
        let e
        var n
        var i
        var a
        var r
        var o = []
        var s = []
        var l = []
        var u = []
        for (e = 0; e < 7; e++) { (n = f([2e3, 1]).day(e)),
        (i = this.weekdaysMin(n, '')),
        (a = this.weekdaysShort(n, '')),
        (r = this.weekdays(n, '')),
        o.push(i),
        s.push(a),
        l.push(r),
        u.push(i),
        u.push(a),
        u.push(r) }
        for (o.sort(t), s.sort(t), l.sort(t), u.sort(t), e = 0; e < 7; e++) { (s[e] = ct(s[e])), (l[e] = ct(l[e])), (u[e] = ct(u[e]))}
        (this._weekdaysRegex = new RegExp('^(' + u.join('|') + ')', 'i')),
        (this._weekdaysShortRegex = this._weekdaysRegex),
        (this._weekdaysMinRegex = this._weekdaysRegex),
        (this._weekdaysStrictRegex = new RegExp(
          '^(' + l.join('|') + ')',
          'i'
        )),
        (this._weekdaysShortStrictRegex = new RegExp(
          '^(' + s.join('|') + ')',
          'i'
        )),
        (this._weekdaysMinStrictRegex = new RegExp(
          '^(' + o.join('|') + ')',
          'i'
        ))
      }
      function ae () {
        return this.hours() % 12 || 12
      }
      function re (t, e) {
        j(t, 0, 0, function () {
          return this.localeData().meridiem(this.hours(), this.minutes(), e)
        })
      }
      function oe (t, e) {
        return e._meridiemParse
      }
      j('H', ['HH', 2], 0, 'hour'),
      j('h', ['hh', 2], 0, ae),
      j('k', ['kk', 2], 0, function () {
        return this.hours() || 24
      }),
      j('hmm', 0, 0, function () {
        return '' + ae.apply(this) + z(this.minutes(), 2)
      }),
      j('hmmss', 0, 0, function () {
        return (
          '' + ae.apply(this) + z(this.minutes(), 2) + z(this.seconds(), 2)
        )
      }),
      j('Hmm', 0, 0, function () {
        return '' + this.hours() + z(this.minutes(), 2)
      }),
      j('Hmmss', 0, 0, function () {
        return (
          '' + this.hours() + z(this.minutes(), 2) + z(this.seconds(), 2)
        )
      }),
      re('a', !0),
      re('A', !1),
      L('hour', 'h'),
      Y('hour', 13),
      dt('a', oe),
      dt('A', oe),
      dt('H', J),
      dt('h', J),
      dt('k', J),
      dt('HH', J, Z),
      dt('hh', J, Z),
      dt('kk', J, Z),
      dt('hmm', Q),
      dt('hmmss', tt),
      dt('Hmm', Q),
      dt('Hmmss', tt),
      gt(['H', 'HH'], xt),
      gt(['k', 'kk'], function (t, e, n) {
        const i = k(t)
        e[xt] = i === 24 ? 0 : i
      }),
      gt(['a', 'A'], function (t, e, n) {
        (n._isPm = n._locale.isPM(t)), (n._meridiem = t)
      }),
      gt(['h', 'hh'], function (t, e, n) {
        (e[xt] = k(t)), (g(n).bigHour = !0)
      }),
      gt('hmm', function (t, e, n) {
        const i = t.length - 2;
        (e[xt] = k(t.substr(0, i))),
        (e[_t] = k(t.substr(i))),
        (g(n).bigHour = !0)
      }),
      gt('hmmss', function (t, e, n) {
        const i = t.length - 4
        var a = t.length - 2;
        (e[xt] = k(t.substr(0, i))),
        (e[_t] = k(t.substr(i, 2))),
        (e[wt] = k(t.substr(a))),
        (g(n).bigHour = !0)
      }),
      gt('Hmm', function (t, e, n) {
        const i = t.length - 2;
        (e[xt] = k(t.substr(0, i))), (e[_t] = k(t.substr(i)))
      }),
      gt('Hmmss', function (t, e, n) {
        const i = t.length - 4
        var a = t.length - 2;
        (e[xt] = k(t.substr(0, i))),
        (e[_t] = k(t.substr(i, 2))),
        (e[wt] = k(t.substr(a)))
      })
      let se
      var le = Ot('Hours', !0)
      var ue = {
        calendar: {
          sameDay: '[Today at] LT',
          nextDay: '[Tomorrow at] LT',
          nextWeek: 'dddd [at] LT',
          lastDay: '[Yesterday at] LT',
          lastWeek: '[Last] dddd [at] LT',
          sameElse: 'L'
        },
        longDateFormat: {
          LTS: 'h:mm:ss A',
          LT: 'h:mm A',
          L: 'MM/DD/YYYY',
          LL: 'MMMM D, YYYY',
          LLL: 'MMMM D, YYYY h:mm A',
          LLLL: 'dddd, MMMM D, YYYY h:mm A'
        },
        invalidDate: 'Invalid date',
        ordinal: '%d',
        dayOfMonthOrdinalParse: /\d{1,2}/,
        relativeTime: {
          future: 'in %s',
          past: '%s ago',
          s: 'a few seconds',
          ss: '%d seconds',
          m: 'a minute',
          mm: '%d minutes',
          h: 'an hour',
          hh: '%d hours',
          d: 'a day',
          dd: '%d days',
          M: 'a month',
          MM: '%d months',
          y: 'a year',
          yy: '%d years'
        },
        months: Rt,
        monthsShort: Nt,
        week: { dow: 0, doy: 6 },
        weekdays: Xt,
        weekdaysMin: Jt,
        weekdaysShort: Kt,
        meridiemParse: /[ap]\.?m?\.?/i
      }
      var de = {}
      var he = {}
      function ce (t) {
        return t ? t.toLowerCase().replace('_', '-') : t
      }
      function fe (n) {
        let i = null
        if (!de[n] && e && e.exports) { try {
          (i = se._abbr), t(), ge(i)
        } catch (t) {} }
        return de[n]
      }
      function ge (t, e) {
        let n
        return (
          t &&
              ((n = s(e) ? pe(t) : me(t, e))
                ? (se = n)
                : typeof console !== 'undefined' &&
                  console.warn &&
                  console.warn(
                    'Locale ' + t + ' not found. Did you forget to load it?'
                  )),
          se._abbr
        )
      }
      function me (t, e) {
        if (e !== null) {
          let n
          var i = ue
          if (((e.abbr = t), de[t] != null)) { T(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          ),
          (i = de[t]._config) } else if (e.parentLocale != null) { if (de[e.parentLocale] != null) i = de[e.parentLocale]._config
          else {
            if ((n = fe(e.parentLocale)) == null)
              return (
                he[e.parentLocale] || (he[e.parentLocale] = []),
                he[e.parentLocale].push({ name: t, config: e }),
                null
              );
            i = n._config
          } }
          return (
            (de[t] = new F(A(i, e))),
            he[t] &&
                he[t].forEach(function (t) {
                  me(t.name, t.config)
                }),
            ge(t),
            de[t]
          )
        }
        return delete de[t], null
      }
      function pe (t) {
        let e
        if ((t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t)) { return se }
        if (!r(t)) {
          if ((e = fe(t))) return e
          t = [t]
        }
        return (function (t) {
          for (var e, n, i, a, r = 0; r < t.length;) {
            for (
              e = (a = ce(t[r]).split('-')).length,
              n = (n = ce(t[r + 1])) ? n.split('-') : null;
              e > 0;

            ) {
              if ((i = fe(a.slice(0, e).join('-')))) return i
              if (n && n.length >= e && M(a, n, !0) >= e - 1) break
              e--
            }
            r++
          }
          return se
        })(t)
      }
      function ve (t) {
        let e
        var n = t._a
        return (
          n &&
              g(t).overflow === -2 &&
              ((e =
                n[bt] < 0 || n[bt] > 11
                  ? bt
                  : n[yt] < 1 || n[yt] > It(n[vt], n[bt])
                    ? yt
                    : n[xt] < 0 ||
                    n[xt] > 24 ||
                    (n[xt] === 24 &&
                      (n[_t] !== 0 || n[wt] !== 0 || n[kt] !== 0))
                      ? xt
                      : n[_t] < 0 || n[_t] > 59
                        ? _t
                        : n[wt] < 0 || n[wt] > 59
                          ? wt
                          : n[kt] < 0 || n[kt] > 999
                            ? kt
                            : -1),
              g(t)._overflowDayOfYear && (e < vt || e > yt) && (e = yt),
              g(t)._overflowWeeks && e === -1 && (e = Mt),
              g(t)._overflowWeekday && e === -1 && (e = St),
              (g(t).overflow = e)),
          t
        )
      }
      function be (t, e, n) {
        return t != null ? t : e != null ? e : n
      }
      function ye (t) {
        let e
        var n
        var i
        var r
        var o
        var s = []
        if (!t._d) {
          for (
            i = (function (t) {
              const e = new Date(a.now())
              return t._useUTC
                ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()]
                : [e.getFullYear(), e.getMonth(), e.getDate()]
            })(t),
            t._w &&
                  t._a[yt] == null &&
                  t._a[bt] == null &&
                  (function (t) {
                    let e, n, i, a, r, o, s, l
                    if ((e = t._w).GG != null || e.W != null || e.E != null) {
 (r = 1),
                    (o = 4),
                    (n = be(e.GG, t._a[vt], qt(Le(), 1, 4).year)),
                    (i = be(e.W, 1)),
                    ((a = be(e.E, 1)) < 1 || a > 7) && (l = !0) } else {
                      (r = t._locale._week.dow), (o = t._locale._week.doy)
                      const u = qt(Le(), r, o);
                      (n = be(e.gg, t._a[vt], u.year)),
                      (i = be(e.w, u.week)),
                      e.d != null
                        ? ((a = e.d) < 0 || a > 6) && (l = !0)
                        : e.e != null
                          ? ((a = e.e + r), (e.e < 0 || e.e > 6) && (l = !0))
                          : (a = r)
                    }
                    i < 1 || i > Zt(n, r, o)
                      ? (g(t)._overflowWeeks = !0)
                      : l != null
                        ? (g(t)._overflowWeekday = !0)
                        : ((s = Gt(n, i, a, r, o)),
                          (t._a[vt] = s.year),
                          (t._dayOfYear = s.dayOfYear))
                  })(t),
            t._dayOfYear != null &&
                  ((o = be(t._a[vt], i[vt])),
                  (t._dayOfYear > Dt(o) || t._dayOfYear === 0) &&
                    (g(t)._overflowDayOfYear = !0),
                  (n = jt(o, 0, t._dayOfYear)),
                  (t._a[bt] = n.getUTCMonth()),
                  (t._a[yt] = n.getUTCDate())),
            e = 0;
            e < 3 && t._a[e] == null;
            ++e
          ) { t._a[e] = s[e] = i[e] }
          for (; e < 7; e++) { t._a[e] = s[e] = t._a[e] == null ? (e === 2 ? 1 : 0) : t._a[e] }
          t._a[xt] === 24 &&
              t._a[_t] === 0 &&
              t._a[wt] === 0 &&
              t._a[kt] === 0 &&
              ((t._nextDay = !0), (t._a[xt] = 0)),
          (t._d = (t._useUTC ? jt : Bt).apply(null, s)),
          (r = t._useUTC ? t._d.getUTCDay() : t._d.getDay()),
          t._tzm != null &&
                t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm),
          t._nextDay && (t._a[xt] = 24),
          t._w &&
                void 0 !== t._w.d &&
                t._w.d !== r &&
                (g(t).weekdayMismatch = !0)
        }
      }
      const xe =
            /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/
      var _e =
            /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/
      var we = /Z|[+-]\d\d(?::?\d\d)?/
      var ke = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, !1],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, !1],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, !1],
        ['YYYYDDD', /\d{7}/]
      ]
      var Me = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
      ]
      var Se = /^\/?Date\((\-?\d+)/i
      function De (t) {
        let e
        var n
        var i
        var a
        var r
        var o
        var s = t._i
        var l = xe.exec(s) || _e.exec(s)
        if (l) {
          for (g(t).iso = !0, e = 0, n = ke.length; e < n; e++) { if (ke[e][1].exec(l[1])) {
            (a = ke[e][0]), (i = !1 !== ke[e][2])
            break;
          } }
          if (a == null) return void (t._isValid = !1)
          if (l[3]) {
            for (e = 0, n = Me.length; e < n; e++) { if (Me[e][1].exec(l[3])) {
              r = (l[2] || ' ') + Me[e][0]
              break;
            } }
            if (r == null) return void (t._isValid = !1)
          }
          if (!i && r != null) return void (t._isValid = !1)
          if (l[4]) {
            if (!we.exec(l[4])) return void (t._isValid = !1)
            o = 'Z'
          }
          (t._f = a + (r || '') + (o || '')), Ae(t)
        } else t._isValid = !1
      }
      const Ce =
          /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/
      function Pe (t) {
        const e = parseInt(t, 10)
        return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e
      }
      const Te = {
        UT: 0,
        GMT: 0,
        EDT: -240,
        EST: -300,
        CDT: -300,
        CST: -360,
        MDT: -360,
        MST: -420,
        PDT: -420,
        PST: -480
      }
      function Oe (t) {
        let e
        var n
        var i
        var a
        var r
        var o
        var s
        var l = Ce.exec(
          t._i
            .replace(/\([^)]*\)|[\n\t]/g, ' ')
            .replace(/(\s\s+)/g, ' ')
            .replace(/^\s\s*/, '')
            .replace(/\s\s*$/, '')
        )
        if (l) {
          const u =
              ((e = l[4]),
              (n = l[3]),
              (i = l[2]),
              (a = l[5]),
              (r = l[6]),
              (o = l[7]),
              (s = [
                Pe(e),
                Nt.indexOf(n),
                parseInt(i, 10),
                parseInt(a, 10),
                parseInt(r, 10)
              ]),
              o && s.push(parseInt(o, 10)),
              s)
          if (
            !(function (t, e, n) {
              return (
                !t ||
                  Kt.indexOf(t) === new Date(e[0], e[1], e[2]).getDay() ||
                  ((g(n).weekdayMismatch = !0), (n._isValid = !1), !1)
              )
            })(l[1], u, t)
          ) { return; }
          (t._a = u),
          (t._tzm = (function (t, e, n) {
            if (t) return Te[t]
            if (e) return 0
            let i = parseInt(n, 10)
            var a = i % 100
            return ((i - a) / 100) * 60 + a
          })(l[8], l[9], l[10])),
          (t._d = jt.apply(null, t._a)),
          t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm),
          (g(t).rfc2822 = !0)
        } else t._isValid = !1
      }
      function Ae (t) {
        if (t._f !== a.ISO_8601) { if (t._f !== a.RFC_2822) {
          (t._a = []), (g(t).empty = !0)
          var e
                var n
                var i
                var r
                var o
                var s = '' + t._i
                var l = s.length
                var u = 0
          for (
            i = G(t._f, t._locale).match(E) || [], e = 0;
            e < i.length;
            e++
          )
            (r = i[e]),
            (n = (s.match(ht(r, t)) || [])[0]) &&
                    ((o = s.substr(0, s.indexOf(n))).length > 0 &&
                      g(t).unusedInput.push(o),
                    (s = s.slice(s.indexOf(n) + n.length)),
                    (u += n.length)),
            B[r]
              ? (n ? (g(t).empty = !1) : g(t).unusedTokens.push(r),
                pt(r, n, t))
              : t._strict && !n && g(t).unusedTokens.push(r);
          (g(t).charsLeftOver = l - u),
          s.length > 0 && g(t).unusedInput.push(s),
          t._a[xt] <= 12 &&
                  !0 === g(t).bigHour &&
                  t._a[xt] > 0 &&
                  (g(t).bigHour = void 0),
          (g(t).parsedDateParts = t._a.slice(0)),
          (g(t).meridiem = t._meridiem),
          (t._a[xt] = (function (t, e, n) {
            var i
            return n == null
              ? e
              : t.meridiemHour != null
                ? t.meridiemHour(e, n)
                : t.isPM != null
                  ? ((i = t.isPM(n)) && e < 12 && (e += 12),
                    i || e !== 12 || (e = 0),
                    e)
                  : e
          })(t._locale, t._a[xt], t._meridiem)),
          ye(t),
          ve(t)
        } else Oe(t) } else De(t)
      }
      function Fe (t) {
        let e = t._i
        var n = t._f
        return (
          (t._locale = t._locale || pe(t._l)),
          e === null || (void 0 === n && e === '')
            ? p({ nullInput: !0 })
            : (typeof e === 'string' && (t._i = e = t._locale.preparse(e)),
              _(e)
                ? new x(ve(e))
                : (u(e)
                    ? (t._d = e)
                    : r(n)
                      ? (function (t) {
                          let e, n, i, a, r
                          if (t._f.length === 0) {
 return (
                            (g(t).invalidFormat = !0),
                            void (t._d = new Date(NaN))
                          ) }
                          for (a = 0; a < t._f.length; a++) {
 (r = 0),
                          (e = b({}, t)),
                          t._useUTC != null && (e._useUTC = t._useUTC),
                          (e._f = t._f[a]),
                          Ae(e),
                          m(e) &&
                                ((r += g(e).charsLeftOver),
                                (r += 10 * g(e).unusedTokens.length),
                                (g(e).score = r),
                                (i == null || r < i) && ((i = r), (n = e))) }
                          c(t, n || e)
                        })(t)
                      : n
                        ? Ae(t)
                        : (function (t) {
                            const e = t._i
                            s(e)
                              ? (t._d = new Date(a.now()))
                              : u(e)
                                ? (t._d = new Date(e.valueOf()))
                                : typeof e === 'string'
                                  ? (function (t) {
                                      const e = Se.exec(t._i)
                                      e === null
                                        ? (De(t),
                                          !1 === t._isValid &&
                                      (delete t._isValid,
                                      Oe(t),
                                      !1 === t._isValid &&
                                        (delete t._isValid,
                                        a.createFromInputFallback(t))))
                                        : (t._d = new Date(+e[1]))
                                    })(t)
                                  : r(e)
                                    ? ((t._a = d(e.slice(0), function (t) {
                                        return parseInt(t, 10)
                                      })),
                                      ye(t))
                                    : o(e)
                                      ? (function (t) {
                                          if (!t._d) {
                                            const e = N(t._i);
                                            (t._a = d(
                                              [
                                                e.year,
                                                e.month,
                                                e.day || e.date,
                                                e.hour,
                                                e.minute,
                                                e.second,
                                                e.millisecond
                                              ],
                                              function (t) {
                                                return t && parseInt(t, 10)
                                              }
                                            )),
                                            ye(t)
                                          }
                                        })(t)
                                      : l(e)
                                        ? (t._d = new Date(e))
                                        : a.createFromInputFallback(t)
                          })(t),
                  m(t) || (t._d = null),
                  t))
        )
      }
      function Ie (t, e, n, i, a) {
        let s
        var l = {}
        return (
          (!0 !== n && !1 !== n) || ((i = n), (n = void 0)),
          ((o(t) &&
              (function (t) {
                if (Object.getOwnPropertyNames) { return Object.getOwnPropertyNames(t).length === 0 }
                let e
                for (e in t) if (t.hasOwnProperty(e)) return !1
                return !0
              })(t)) ||
              (r(t) && t.length === 0)) &&
              (t = void 0),
          (l._isAMomentObject = !0),
          (l._useUTC = l._isUTC = a),
          (l._l = n),
          (l._i = t),
          (l._f = e),
          (l._strict = i),
          (s = new x(ve(Fe(l))))._nextDay &&
              (s.add(1, 'd'), (s._nextDay = void 0)),
          s
        )
      }
      function Le (t, e, n, i) {
        return Ie(t, e, n, i, !1)
      }
      (a.createFromInputFallback = D(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (t) {
          t._d = new Date(t._i + (t._useUTC ? ' UTC' : ''))
        }
      )),
      (a.ISO_8601 = function () {}),
      (a.RFC_2822 = function () {})
      let Re = D(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
          let t = Le.apply(null, arguments)
          return this.isValid() && t.isValid()
            ? t < this
              ? this
              : t
            : p()
        }
      )
      var Ne = D(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
          let t = Le.apply(null, arguments)
          return this.isValid() && t.isValid()
            ? t > this
              ? this
              : t
            : p()
        }
      )
      function We (t, e) {
        let n, i
        if ((e.length === 1 && r(e[0]) && (e = e[0]), !e.length)) return Le()
        for (n = e[0], i = 1; i < e.length; ++i) { (e[i].isValid() && !e[i][t](n)) || (n = e[i]) }
        return n
      }
      const Ye = [
        'year',
        'quarter',
        'month',
        'week',
        'day',
        'hour',
        'minute',
        'second',
        'millisecond'
      ]
      function ze (t) {
        const e = N(t)
        var n = e.year || 0
        var i = e.quarter || 0
        var a = e.month || 0
        var r = e.week || e.isoWeek || 0
        var o = e.day || 0
        var s = e.hour || 0
        var l = e.minute || 0
        var u = e.second || 0
        var d = e.millisecond || 0;
        (this._isValid = (function (t) {
          for (const e in t) { if (Pt.call(Ye, e) === -1 || (t[e] != null && isNaN(t[e])))
            return !1 }
          for (let n = !1, i = 0; i < Ye.length; ++i) { if (t[Ye[i]]) {
            if (n) return !1
            parseFloat(t[Ye[i]]) !== k(t[Ye[i]]) && (n = !0)
          } }
          return !0
        })(e)),
        (this._milliseconds = +d + 1e3 * u + 6e4 * l + 1e3 * s * 60 * 60),
        (this._days = +o + 7 * r),
        (this._months = +a + 3 * i + 12 * n),
        (this._data = {}),
        (this._locale = pe()),
        this._bubble()
      }
      function Ee (t) {
        return t instanceof ze
      }
      function Ve (t) {
        return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t)
      }
      function He (t, e) {
        j(t, 0, 0, function () {
          let t = this.utcOffset()
          var n = '+'
          return (
            t < 0 && ((t = -t), (n = '-')),
            n + z(~~(t / 60), 2) + e + z(~~t % 60, 2)
          )
        })
      }
      He('Z', ':'),
      He('ZZ', ''),
      dt('Z', st),
      dt('ZZ', st),
      gt(['Z', 'ZZ'], function (t, e, n) {
        (n._useUTC = !0), (n._tzm = je(st, t))
      })
      let Be = /([\+\-]|\d\d)/gi
      function je (t, e) {
        const n = (e || '').match(t)
        if (n === null) return null
        let i = ((n[n.length - 1] || []) + '').match(Be) || ['-', 0, 0]
        var a = 60 * i[1] + k(i[2])
        return a === 0 ? 0 : i[0] === '+' ? a : -a
      }
      function Ue (t, e) {
        let n, i
        return e._isUTC
          ? ((n = e.clone()),
            (i =
                (_(t) || u(t) ? t.valueOf() : Le(t).valueOf()) - n.valueOf()),
            n._d.setTime(n._d.valueOf() + i),
            a.updateOffset(n, !1),
            n)
          : Le(t).local()
      }
      function Ge (t) {
        return 15 * -Math.round(t._d.getTimezoneOffset() / 15)
      }
      function qe () {
        return !!this.isValid() && this._isUTC && this._offset === 0
      }
      a.updateOffset = function () {}
      let Ze = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/
      var $e =
            /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/
      function Xe (t, e) {
        let n
        var i
        var a
        var r
        var o
        var s
        var u = t
        var d = null
        return (
          Ee(t)
            ? (u = { ms: t._milliseconds, d: t._days, M: t._months })
            : l(t)
              ? ((u = {}), e ? (u[e] = t) : (u.milliseconds = t))
              : (d = Ze.exec(t))
                  ? ((n = d[1] === '-' ? -1 : 1),
                    (u = {
                      y: 0,
                      d: k(d[yt]) * n,
                      h: k(d[xt]) * n,
                      m: k(d[_t]) * n,
                      s: k(d[wt]) * n,
                      ms: k(Ve(1e3 * d[kt])) * n
                    }))
                  : (d = $e.exec(t))
                      ? ((n = d[1] === '-' ? -1 : 1),
                        (u = {
                          y: Ke(d[2], n),
                          M: Ke(d[3], n),
                          w: Ke(d[4], n),
                          d: Ke(d[5], n),
                          h: Ke(d[6], n),
                          m: Ke(d[7], n),
                          s: Ke(d[8], n)
                        }))
                      : u == null
                        ? (u = {})
                        : typeof u === 'object' &&
                ('from' in u || 'to' in u) &&
                ((r = Le(u.from)),
                (o = Le(u.to)),
                (a =
                  r.isValid() && o.isValid()
                    ? ((o = Ue(o, r)),
                      r.isBefore(o)
                        ? (s = Je(r, o))
                        : (((s = Je(o, r)).milliseconds = -s.milliseconds),
                          (s.months = -s.months)),
                      s)
                    : { milliseconds: 0, months: 0 }),
                ((u = {}).ms = a.milliseconds),
                (u.M = a.months)),
          (i = new ze(u)),
          Ee(t) && h(t, '_locale') && (i._locale = t._locale),
          i
        )
      }
      function Ke (t, e) {
        const n = t && parseFloat(t.replace(',', '.'))
        return (isNaN(n) ? 0 : n) * e
      }
      function Je (t, e) {
        const n = {}
        return (
          (n.months = e.month() - t.month() + 12 * (e.year() - t.year())),
          t.clone().add(n.months, 'M').isAfter(e) && --n.months,
          (n.milliseconds = +e - +t.clone().add(n.months, 'M')),
          n
        )
      }
      function Qe (t, e) {
        return function (n, i) {
          let a
          return (
            i === null ||
                isNaN(+i) ||
                (T(
                  e,
                  'moment().' +
                    e +
                    '(period, number) is deprecated. Please use moment().' +
                    e +
                    '(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                ),
                (a = n),
                (n = i),
                (i = a)),
            tn(this, Xe((n = typeof n === 'string' ? +n : n), i), t),
            this
          )
        }
      }
      function tn (t, e, n, i) {
        const r = e._milliseconds
        var o = Ve(e._days)
        var s = Ve(e._months)
        t.isValid() &&
            ((i = i == null || i),
            s && Yt(t, At(t, 'Month') + s * n),
            o && Ft(t, 'Date', At(t, 'Date') + o * n),
            r && t._d.setTime(t._d.valueOf() + r * n),
            i && a.updateOffset(t, o || s))
      }
      (Xe.fn = ze.prototype),
      (Xe.invalid = function () {
        return Xe(NaN)
      })
      let en = Qe(1, 'add')
      var nn = Qe(-1, 'subtract')
      function an (t, e) {
        const n = 12 * (e.year() - t.year()) + (e.month() - t.month())
        var i = t.clone().add(n, 'months')
        return (
          -(
            n +
              (e - i < 0
                ? (e - i) / (i - t.clone().add(n - 1, 'months'))
                : (e - i) / (t.clone().add(n + 1, 'months') - i))
          ) || 0
        )
      }
      function rn (t) {
        let e
        return void 0 === t
          ? this._locale._abbr
          : ((e = pe(t)) != null && (this._locale = e), this)
      }
      (a.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ'),
      (a.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]')
      let on = D(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (t) {
          return void 0 === t ? this.localeData() : this.locale(t)
        }
      )
      function sn () {
        return this._locale
      }
      const ln = 1e3
      var un = 60 * ln
      var dn = 60 * un
      var hn = 3506328 * dn
      function cn (t, e) {
        return ((t % e) + e) % e
      }
      function fn (t, e, n) {
        return t < 100 && t >= 0
          ? new Date(t + 400, e, n) - hn
          : new Date(t, e, n).valueOf()
      }
      function gn (t, e, n) {
        return t < 100 && t >= 0
          ? Date.UTC(t + 400, e, n) - hn
          : Date.UTC(t, e, n)
      }
      function mn (t, e) {
        j(0, [t, t.length], 0, e)
      }
      function pn (t, e, n, i, a) {
        let r
        return t == null
          ? qt(this, i, a).year
          : (e > (r = Zt(t, i, a)) && (e = r), vn.call(this, t, e, n, i, a))
      }
      function vn (t, e, n, i, a) {
        const r = Gt(t, e, n, i, a)
        var o = jt(r.year, 0, r.dayOfYear)
        return (
          this.year(o.getUTCFullYear()),
          this.month(o.getUTCMonth()),
          this.date(o.getUTCDate()),
          this
        )
      }
      j(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100
      }),
      j(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100
      }),
      mn('gggg', 'weekYear'),
      mn('ggggg', 'weekYear'),
      mn('GGGG', 'isoWeekYear'),
      mn('GGGGG', 'isoWeekYear'),
      L('weekYear', 'gg'),
      L('isoWeekYear', 'GG'),
      Y('weekYear', 1),
      Y('isoWeekYear', 1),
      dt('G', rt),
      dt('g', rt),
      dt('GG', J, Z),
      dt('gg', J, Z),
      dt('GGGG', nt, X),
      dt('gggg', nt, X),
      dt('GGGGG', it, K),
      dt('ggggg', it, K),
      mt(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (t, e, n, i) {
        e[i.substr(0, 2)] = k(t)
      }),
      mt(['gg', 'GG'], function (t, e, n, i) {
        e[i] = a.parseTwoDigitYear(t)
      }),
      j('Q', 0, 'Qo', 'quarter'),
      L('quarter', 'Q'),
      Y('quarter', 7),
      dt('Q', q),
      gt('Q', function (t, e) {
        e[bt] = 3 * (k(t) - 1)
      }),
      j('D', ['DD', 2], 'Do', 'date'),
      L('date', 'D'),
      Y('date', 9),
      dt('D', J),
      dt('DD', J, Z),
      dt('Do', function (t, e) {
        return t
          ? e._dayOfMonthOrdinalParse || e._ordinalParse
          : e._dayOfMonthOrdinalParseLenient
      }),
      gt(['D', 'DD'], yt),
      gt('Do', function (t, e) {
        e[yt] = k(t.match(J)[0])
      })
      let bn = Ot('Date', !0)
      j('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'),
      L('dayOfYear', 'DDD'),
      Y('dayOfYear', 4),
      dt('DDD', et),
      dt('DDDD', $),
      gt(['DDD', 'DDDD'], function (t, e, n) {
        n._dayOfYear = k(t)
      }),
      j('m', ['mm', 2], 0, 'minute'),
      L('minute', 'm'),
      Y('minute', 14),
      dt('m', J),
      dt('mm', J, Z),
      gt(['m', 'mm'], _t)
      let yn = Ot('Minutes', !1)
      j('s', ['ss', 2], 0, 'second'),
      L('second', 's'),
      Y('second', 15),
      dt('s', J),
      dt('ss', J, Z),
      gt(['s', 'ss'], wt)
      let xn
      var _n = Ot('Seconds', !1)
      for (
        j('S', 0, 0, function () {
          return ~~(this.millisecond() / 100)
        }),
        j(0, ['SS', 2], 0, function () {
          return ~~(this.millisecond() / 10)
        }),
        j(0, ['SSS', 3], 0, 'millisecond'),
        j(0, ['SSSS', 4], 0, function () {
          return 10 * this.millisecond()
        }),
        j(0, ['SSSSS', 5], 0, function () {
          return 100 * this.millisecond()
        }),
        j(0, ['SSSSSS', 6], 0, function () {
          return 1e3 * this.millisecond()
        }),
        j(0, ['SSSSSSS', 7], 0, function () {
          return 1e4 * this.millisecond()
        }),
        j(0, ['SSSSSSSS', 8], 0, function () {
          return 1e5 * this.millisecond()
        }),
        j(0, ['SSSSSSSSS', 9], 0, function () {
          return 1e6 * this.millisecond()
        }),
        L('millisecond', 'ms'),
        Y('millisecond', 16),
        dt('S', et, q),
        dt('SS', et, Z),
        dt('SSS', et, $),
        xn = 'SSSS';
        xn.length <= 9;
        xn += 'S'
      ) { dt(xn, at) }
      function wn (t, e) {
        e[kt] = k(1e3 * ('0.' + t))
      }
      for (xn = 'S'; xn.length <= 9; xn += 'S') gt(xn, wn)
      let kn = Ot('Milliseconds', !1)
      j('z', 0, 0, 'zoneAbbr'), j('zz', 0, 0, 'zoneName')
      let Mn = x.prototype
      function Sn (t) {
        return t
      }
      (Mn.add = en),
      (Mn.calendar = function (t, e) {
        const n = t || Le()
        var i = Ue(n, this).startOf('day')
        var r = a.calendarFormat(this, i) || 'sameElse'
        var o = e && (O(e[r]) ? e[r].call(this, n) : e[r])
        return this.format(o || this.localeData().calendar(r, this, Le(n)))
      }),
      (Mn.clone = function () {
        return new x(this)
      }),
      (Mn.diff = function (t, e, n) {
        let i, a, r
        if (!this.isValid()) return NaN
        if (!(i = Ue(t, this)).isValid()) return NaN
        switch (
          ((a = 6e4 * (i.utcOffset() - this.utcOffset())), (e = R(e)))
        ) {
          case 'year':
            r = an(this, i) / 12
            break
          case 'month':
            r = an(this, i)
            break
          case 'quarter':
            r = an(this, i) / 3
            break
          case 'second':
            r = (this - i) / 1e3
            break
          case 'minute':
            r = (this - i) / 6e4
            break
          case 'hour':
            r = (this - i) / 36e5
            break
          case 'day':
            r = (this - i - a) / 864e5
            break
          case 'week':
            r = (this - i - a) / 6048e5
            break
          default:
            r = this - i
        }
        return n ? r : w(r)
      }),
      (Mn.endOf = function (t) {
        let e
        if (void 0 === (t = R(t)) || t === 'millisecond' || !this.isValid()) { return this }
        let n = this._isUTC ? gn : fn
        switch (t) {
          case 'year':
            e = n(this.year() + 1, 0, 1) - 1
            break
          case 'quarter':
            e =
                  n(this.year(), this.month() - (this.month() % 3) + 3, 1) - 1
            break
          case 'month':
            e = n(this.year(), this.month() + 1, 1) - 1
            break
          case 'week':
            e =
                  n(
                    this.year(),
                    this.month(),
                    this.date() - this.weekday() + 7
                  ) - 1
            break
          case 'isoWeek':
            e =
                  n(
                    this.year(),
                    this.month(),
                    this.date() - (this.isoWeekday() - 1) + 7
                  ) - 1
            break
          case 'day':
          case 'date':
            e = n(this.year(), this.month(), this.date() + 1) - 1
            break
          case 'hour':
            (e = this._d.valueOf()),
            (e +=
                    dn -
                    cn(e + (this._isUTC ? 0 : this.utcOffset() * un), dn) -
                    1)
            break
          case 'minute':
            (e = this._d.valueOf()), (e += un - cn(e, un) - 1)
            break
          case 'second':
            (e = this._d.valueOf()), (e += ln - cn(e, ln) - 1)
        }
        return this._d.setTime(e), a.updateOffset(this, !0), this
      }),
      (Mn.format = function (t) {
        t || (t = this.isUtc() ? a.defaultFormatUtc : a.defaultFormat)
        let e = U(this, t)
        return this.localeData().postformat(e)
      }),
      (Mn.from = function (t, e) {
        return this.isValid() && ((_(t) && t.isValid()) || Le(t).isValid())
          ? Xe({ to: this, from: t }).locale(this.locale()).humanize(!e)
          : this.localeData().invalidDate()
      }),
      (Mn.fromNow = function (t) {
        return this.from(Le(), t)
      }),
      (Mn.to = function (t, e) {
        return this.isValid() && ((_(t) && t.isValid()) || Le(t).isValid())
          ? Xe({ from: this, to: t }).locale(this.locale()).humanize(!e)
          : this.localeData().invalidDate()
      }),
      (Mn.toNow = function (t) {
        return this.to(Le(), t)
      }),
      (Mn.get = function (t) {
        return O(this[(t = R(t))]) ? this[t]() : this
      }),
      (Mn.invalidAt = function () {
        return g(this).overflow
      }),
      (Mn.isAfter = function (t, e) {
        const n = _(t) ? t : Le(t)
        return (
          !(!this.isValid() || !n.isValid()) &&
              ((e = R(e) || 'millisecond') === 'millisecond'
                ? this.valueOf() > n.valueOf()
                : n.valueOf() < this.clone().startOf(e).valueOf())
        )
      }),
      (Mn.isBefore = function (t, e) {
        const n = _(t) ? t : Le(t)
        return (
          !(!this.isValid() || !n.isValid()) &&
              ((e = R(e) || 'millisecond') === 'millisecond'
                ? this.valueOf() < n.valueOf()
                : this.clone().endOf(e).valueOf() < n.valueOf())
        )
      }),
      (Mn.isBetween = function (t, e, n, i) {
        const a = _(t) ? t : Le(t)
        var r = _(e) ? e : Le(e)
        return (
          !!(this.isValid() && a.isValid() && r.isValid()) &&
              ((i = i || '()')[0] === '('
                ? this.isAfter(a, n)
                : !this.isBefore(a, n)) &&
              (i[1] === ')' ? this.isBefore(r, n) : !this.isAfter(r, n))
        )
      }),
      (Mn.isSame = function (t, e) {
        let n
        var i = _(t) ? t : Le(t)
        return (
          !(!this.isValid() || !i.isValid()) &&
              ((e = R(e) || 'millisecond') === 'millisecond'
                ? this.valueOf() === i.valueOf()
                : ((n = i.valueOf()),
                  this.clone().startOf(e).valueOf() <= n &&
                    n <= this.clone().endOf(e).valueOf()))
        )
      }),
      (Mn.isSameOrAfter = function (t, e) {
        return this.isSame(t, e) || this.isAfter(t, e)
      }),
      (Mn.isSameOrBefore = function (t, e) {
        return this.isSame(t, e) || this.isBefore(t, e)
      }),
      (Mn.isValid = function () {
        return m(this)
      }),
      (Mn.lang = on),
      (Mn.locale = rn),
      (Mn.localeData = sn),
      (Mn.max = Ne),
      (Mn.min = Re),
      (Mn.parsingFlags = function () {
        return c({}, g(this))
      }),
      (Mn.set = function (t, e) {
        if (typeof t === 'object') { for (
          var n = (function (t) {
              var e = []
              for (const n in t) e.push({ unit: n, priority: W[n] })
              return (
                e.sort(function (t, e) {
                  return t.priority - e.priority
                }),
                e
              );
            })((t = N(t))),
            i = 0;
          i < n.length;
          i++
        )
          this[n[i].unit](t[n[i].unit]) } else if (O(this[(t = R(t))])) return this[t](e)
        return this
      }),
      (Mn.startOf = function (t) {
        let e
        if (void 0 === (t = R(t)) || t === 'millisecond' || !this.isValid()) { return this }
        let n = this._isUTC ? gn : fn
        switch (t) {
          case 'year':
            e = n(this.year(), 0, 1)
            break
          case 'quarter':
            e = n(this.year(), this.month() - (this.month() % 3), 1)
            break
          case 'month':
            e = n(this.year(), this.month(), 1)
            break
          case 'week':
            e = n(this.year(), this.month(), this.date() - this.weekday())
            break
          case 'isoWeek':
            e = n(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            )
            break
          case 'day':
          case 'date':
            e = n(this.year(), this.month(), this.date())
            break
          case 'hour':
            (e = this._d.valueOf()),
            (e -= cn(e + (this._isUTC ? 0 : this.utcOffset() * un), dn))
            break
          case 'minute':
            (e = this._d.valueOf()), (e -= cn(e, un))
            break
          case 'second':
            (e = this._d.valueOf()), (e -= cn(e, ln))
        }
        return this._d.setTime(e), a.updateOffset(this, !0), this
      }),
      (Mn.subtract = nn),
      (Mn.toArray = function () {
        const t = this
        return [
          t.year(),
          t.month(),
          t.date(),
          t.hour(),
          t.minute(),
          t.second(),
          t.millisecond()
        ]
      }),
      (Mn.toObject = function () {
        const t = this
        return {
          years: t.year(),
          months: t.month(),
          date: t.date(),
          hours: t.hours(),
          minutes: t.minutes(),
          seconds: t.seconds(),
          milliseconds: t.milliseconds()
        }
      }),
      (Mn.toDate = function () {
        return new Date(this.valueOf())
      }),
      (Mn.toISOString = function (t) {
        if (!this.isValid()) return null
        let e = !0 !== t
        var n = e ? this.clone().utc() : this
        return n.year() < 0 || n.year() > 9999
          ? U(
            n,
            e
              ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
              : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
          )
          : O(Date.prototype.toISOString)
            ? e
              ? this.toDate().toISOString()
              : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3)
                .toISOString()
                .replace('Z', U(n, 'Z'))
            : U(
              n,
              e
                ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
            )
      }),
      (Mn.inspect = function () {
        if (!this.isValid()) return 'moment.invalid(/* ' + this._i + ' */)'
        let t = 'moment'
          var e = ''
        this.isLocal() ||
              ((t = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone'),
              (e = 'Z'))
        let n = '[' + t + '("]'
        var i = this.year() >= 0 && this.year() <= 9999 ? 'YYYY' : 'YYYYYY'
        var a = e + '[")]'
        return this.format(n + i + '-MM-DD[T]HH:mm:ss.SSS' + a)
      }),
      (Mn.toJSON = function () {
        return this.isValid() ? this.toISOString() : null
      }),
      (Mn.toString = function () {
        return this.clone()
          .locale('en')
          .format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ')
      }),
      (Mn.unix = function () {
        return Math.floor(this.valueOf() / 1e3)
      }),
      (Mn.valueOf = function () {
        return this._d.valueOf() - 6e4 * (this._offset || 0)
      }),
      (Mn.creationData = function () {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        }
      }),
      (Mn.year = Tt),
      (Mn.isLeapYear = function () {
        return Ct(this.year())
      }),
      (Mn.weekYear = function (t) {
        return pn.call(
          this,
          t,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        )
      }),
      (Mn.isoWeekYear = function (t) {
        return pn.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4)
      }),
      (Mn.quarter = Mn.quarters =
            function (t) {
              return t == null
                ? Math.ceil((this.month() + 1) / 3)
                : this.month(3 * (t - 1) + (this.month() % 3))
            }),
      (Mn.month = zt),
      (Mn.daysInMonth = function () {
        return It(this.year(), this.month())
      }),
      (Mn.week = Mn.weeks =
            function (t) {
              const e = this.localeData().week(this)
              return t == null ? e : this.add(7 * (t - e), 'd')
            }),
      (Mn.isoWeek = Mn.isoWeeks =
            function (t) {
              const e = qt(this, 1, 4).week
              return t == null ? e : this.add(7 * (t - e), 'd')
            }),
      (Mn.weeksInYear = function () {
        const t = this.localeData()._week
        return Zt(this.year(), t.dow, t.doy)
      }),
      (Mn.isoWeeksInYear = function () {
        return Zt(this.year(), 1, 4)
      }),
      (Mn.date = bn),
      (Mn.day = Mn.days =
            function (t) {
              if (!this.isValid()) return t != null ? this : NaN
              const e = this._isUTC ? this._d.getUTCDay() : this._d.getDay()
              return t != null
                ? ((t = (function (t, e) {
                    return typeof t !== 'string'
                      ? t
                      : isNaN(t)
                        ? typeof (t = e.weekdaysParse(t)) === 'number'
                          ? t
                          : null
                        : parseInt(t, 10)
                  })(t, this.localeData())),
                  this.add(t - e, 'd'))
                : e
            }),
      (Mn.weekday = function (t) {
        if (!this.isValid()) return t != null ? this : NaN
        let e = (this.day() + 7 - this.localeData()._week.dow) % 7
        return t == null ? e : this.add(t - e, 'd')
      }),
      (Mn.isoWeekday = function (t) {
        if (!this.isValid()) return t != null ? this : NaN
        if (t != null) {
          const e = (function (t, e) {
            return typeof t === 'string'
              ? e.weekdaysParse(t) % 7 || 7
              : isNaN(t)
                ? null
                : t
          })(t, this.localeData())
          return this.day(this.day() % 7 ? e : e - 7)
        }
        return this.day() || 7
      }),
      (Mn.dayOfYear = function (t) {
        const e =
              Math.round(
                (this.clone().startOf('day') - this.clone().startOf('year')) /
                  864e5
              ) + 1
        return t == null ? e : this.add(t - e, 'd')
      }),
      (Mn.hour = Mn.hours = le),
      (Mn.minute = Mn.minutes = yn),
      (Mn.second = Mn.seconds = _n),
      (Mn.millisecond = Mn.milliseconds = kn),
      (Mn.utcOffset = function (t, e, n) {
        let i
        var r = this._offset || 0
        if (!this.isValid()) return t != null ? this : NaN
        if (t != null) {
          if (typeof t === 'string') {
            if ((t = je(st, t)) === null) return this
          } else Math.abs(t) < 16 && !n && (t *= 60)
          return (
            !this._isUTC && e && (i = Ge(this)),
            (this._offset = t),
            (this._isUTC = !0),
            i != null && this.add(i, 'm'),
            r !== t &&
                  (!e || this._changeInProgress
                    ? tn(this, Xe(t - r, 'm'), 1, !1)
                    : this._changeInProgress ||
                      ((this._changeInProgress = !0),
                      a.updateOffset(this, !0),
                      (this._changeInProgress = null))),
            this
          )
        }
        return this._isUTC ? r : Ge(this)
      }),
      (Mn.utc = function (t) {
        return this.utcOffset(0, t)
      }),
      (Mn.local = function (t) {
        return (
          this._isUTC &&
                (this.utcOffset(0, t),
                (this._isUTC = !1),
                t && this.subtract(Ge(this), 'm')),
          this
        )
      }),
      (Mn.parseZone = function () {
        if (this._tzm != null) this.utcOffset(this._tzm, !1, !0)
        else if (typeof this._i === 'string') {
          const t = je(ot, this._i)
          t != null ? this.utcOffset(t) : this.utcOffset(0, !0)
        }
        return this
      }),
      (Mn.hasAlignedHourOffset = function (t) {
        return (
          !!this.isValid() &&
              ((t = t ? Le(t).utcOffset() : 0),
              (this.utcOffset() - t) % 60 == 0)
        )
      }),
      (Mn.isDST = function () {
        return (
          this.utcOffset() > this.clone().month(0).utcOffset() ||
              this.utcOffset() > this.clone().month(5).utcOffset()
        )
      }),
      (Mn.isLocal = function () {
        return !!this.isValid() && !this._isUTC
      }),
      (Mn.isUtcOffset = function () {
        return !!this.isValid() && this._isUTC
      }),
      (Mn.isUtc = qe),
      (Mn.isUTC = qe),
      (Mn.zoneAbbr = function () {
        return this._isUTC ? 'UTC' : ''
      }),
      (Mn.zoneName = function () {
        return this._isUTC ? 'Coordinated Universal Time' : ''
      }),
      (Mn.dates = D('dates accessor is deprecated. Use date instead.', bn)),
      (Mn.months = D(
        'months accessor is deprecated. Use month instead',
        zt
      )),
      (Mn.years = D('years accessor is deprecated. Use year instead', Tt)),
      (Mn.zone = D(
        'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
        function (t, e) {
          return t != null
            ? (typeof t !== 'string' && (t = -t), this.utcOffset(t, e), this)
            : -this.utcOffset()
        }
      )),
      (Mn.isDSTShifted = D(
        'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
        function () {
          if (!s(this._isDSTShifted)) return this._isDSTShifted
          let t = {}
          if ((b(t, this), (t = Fe(t))._a)) {
            const e = t._isUTC ? f(t._a) : Le(t._a)
            this._isDSTShifted = this.isValid() && M(t._a, e.toArray()) > 0
          } else this._isDSTShifted = !1
          return this._isDSTShifted
        }
      ))
      let Dn = F.prototype
      function Cn (t, e, n, i) {
        const a = pe()
        var r = f().set(i, e)
        return a[n](r, t)
      }
      function Pn (t, e, n) {
        if ((l(t) && ((e = t), (t = void 0)), (t = t || ''), e != null)) { return Cn(t, e, n, 'month')}
        let i
        var a = []
        for (i = 0; i < 12; i++) a[i] = Cn(t, i, n, 'month')
        return a
      }
      function Tn (t, e, n, i) {
        typeof t === 'boolean'
          ? (l(e) && ((n = e), (e = void 0)), (e = e || ''))
          : ((n = e = t),
            (t = !1),
            l(e) && ((n = e), (e = void 0)),
            (e = e || ''))
        let a
        var r = pe()
        var o = t ? r._week.dow : 0
        if (n != null) return Cn(e, (n + o) % 7, i, 'day')
        let s = []
        for (a = 0; a < 7; a++) s[a] = Cn(e, (a + o) % 7, i, 'day')
        return s
      }
      (Dn.calendar = function (t, e, n) {
        const i = this._calendar[t] || this._calendar.sameElse
        return O(i) ? i.call(e, n) : i
      }),
      (Dn.longDateFormat = function (t) {
        const e = this._longDateFormat[t]
        var n = this._longDateFormat[t.toUpperCase()]
        return e || !n
          ? e
          : ((this._longDateFormat[t] = n.replace(
              /MMMM|MM|DD|dddd/g,
              function (t) {
                return t.slice(1)
              }
            )),
            this._longDateFormat[t])
      }),
      (Dn.invalidDate = function () {
        return this._invalidDate
      }),
      (Dn.ordinal = function (t) {
        return this._ordinal.replace('%d', t)
      }),
      (Dn.preparse = Sn),
      (Dn.postformat = Sn),
      (Dn.relativeTime = function (t, e, n, i) {
        const a = this._relativeTime[n]
        return O(a) ? a(t, e, n, i) : a.replace(/%d/i, t)
      }),
      (Dn.pastFuture = function (t, e) {
        const n = this._relativeTime[t > 0 ? 'future' : 'past']
        return O(n) ? n(e) : n.replace(/%s/i, e)
      }),
      (Dn.set = function (t) {
        let e, n
        for (n in t) O((e = t[n])) ? (this[n] = e) : (this['_' + n] = e);
        (this._config = t),
        (this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source ||
                  this._ordinalParse.source) +
                  '|' +
                  /\d{1,2}/.source
        ))
      }),
      (Dn.months = function (t, e) {
        return t
          ? r(this._months)
            ? this._months[t.month()]
            : this._months[
              (this._months.isFormat || Lt).test(e)
                ? 'format'
                : 'standalone'
            ][t.month()]
          : r(this._months)
            ? this._months
            : this._months.standalone
      }),
      (Dn.monthsShort = function (t, e) {
        return t
          ? r(this._monthsShort)
            ? this._monthsShort[t.month()]
            : this._monthsShort[Lt.test(e) ? 'format' : 'standalone'][
              t.month()
            ]
          : r(this._monthsShort)
            ? this._monthsShort
            : this._monthsShort.standalone
      }),
      (Dn.monthsParse = function (t, e, n) {
        let i, a, r
        if (this._monthsParseExact) return Wt.call(this, t, e, n)
        for (
          this._monthsParse ||
                ((this._monthsParse = []),
                (this._longMonthsParse = []),
                (this._shortMonthsParse = [])),
          i = 0;
          i < 12;
          i++
        ) {
          if (
            ((a = f([2e3, i])),
            n &&
                  !this._longMonthsParse[i] &&
                  ((this._longMonthsParse[i] = new RegExp(
                    '^' + this.months(a, '').replace('.', '') + '$',
                    'i'
                  )),
                  (this._shortMonthsParse[i] = new RegExp(
                    '^' + this.monthsShort(a, '').replace('.', '') + '$',
                    'i'
                  ))),
            n ||
                  this._monthsParse[i] ||
                  ((r =
                    '^' + this.months(a, '') + '|^' + this.monthsShort(a, '')),
                  (this._monthsParse[i] = new RegExp(r.replace('.', ''), 'i'))),
            n && e === 'MMMM' && this._longMonthsParse[i].test(t))
          ) { return i }
          if (n && e === 'MMM' && this._shortMonthsParse[i].test(t)) { return i }
          if (!n && this._monthsParse[i].test(t)) return i
        }
      }),
      (Dn.monthsRegex = function (t) {
        return this._monthsParseExact
          ? (h(this, '_monthsRegex') || Ht.call(this),
            t ? this._monthsStrictRegex : this._monthsRegex)
          : (h(this, '_monthsRegex') || (this._monthsRegex = Vt),
            this._monthsStrictRegex && t
              ? this._monthsStrictRegex
              : this._monthsRegex)
      }),
      (Dn.monthsShortRegex = function (t) {
        return this._monthsParseExact
          ? (h(this, '_monthsRegex') || Ht.call(this),
            t ? this._monthsShortStrictRegex : this._monthsShortRegex)
          : (h(this, '_monthsShortRegex') || (this._monthsShortRegex = Et),
            this._monthsShortStrictRegex && t
              ? this._monthsShortStrictRegex
              : this._monthsShortRegex)
      }),
      (Dn.week = function (t) {
        return qt(t, this._week.dow, this._week.doy).week
      }),
      (Dn.firstDayOfYear = function () {
        return this._week.doy
      }),
      (Dn.firstDayOfWeek = function () {
        return this._week.dow
      }),
      (Dn.weekdays = function (t, e) {
        const n = r(this._weekdays)
          ? this._weekdays
          : this._weekdays[
            t && !0 !== t && this._weekdays.isFormat.test(e)
              ? 'format'
              : 'standalone'
          ]
        return !0 === t ? $t(n, this._week.dow) : t ? n[t.day()] : n
      }),
      (Dn.weekdaysMin = function (t) {
        return !0 === t
          ? $t(this._weekdaysMin, this._week.dow)
          : t
            ? this._weekdaysMin[t.day()]
            : this._weekdaysMin
      }),
      (Dn.weekdaysShort = function (t) {
        return !0 === t
          ? $t(this._weekdaysShort, this._week.dow)
          : t
            ? this._weekdaysShort[t.day()]
            : this._weekdaysShort
      }),
      (Dn.weekdaysParse = function (t, e, n) {
        let i, a, r
        if (this._weekdaysParseExact) return Qt.call(this, t, e, n)
        for (
          this._weekdaysParse ||
                ((this._weekdaysParse = []),
                (this._minWeekdaysParse = []),
                (this._shortWeekdaysParse = []),
                (this._fullWeekdaysParse = [])),
          i = 0;
          i < 7;
          i++
        ) {
          if (
            ((a = f([2e3, 1]).day(i)),
            n &&
                  !this._fullWeekdaysParse[i] &&
                  ((this._fullWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdays(a, '').replace('.', '\\.?') + '$',
                    'i'
                  )),
                  (this._shortWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysShort(a, '').replace('.', '\\.?') + '$',
                    'i'
                  )),
                  (this._minWeekdaysParse[i] = new RegExp(
                    '^' + this.weekdaysMin(a, '').replace('.', '\\.?') + '$',
                    'i'
                  ))),
            this._weekdaysParse[i] ||
                  ((r =
                    '^' +
                    this.weekdays(a, '') +
                    '|^' +
                    this.weekdaysShort(a, '') +
                    '|^' +
                    this.weekdaysMin(a, '')),
                  (this._weekdaysParse[i] = new RegExp(
                    r.replace('.', ''),
                    'i'
                  ))),
            n && e === 'dddd' && this._fullWeekdaysParse[i].test(t))
          ) { return i }
          if (n && e === 'ddd' && this._shortWeekdaysParse[i].test(t)) { return i }
          if (n && e === 'dd' && this._minWeekdaysParse[i].test(t)) { return i }
          if (!n && this._weekdaysParse[i].test(t)) return i
        }
      }),
      (Dn.weekdaysRegex = function (t) {
        return this._weekdaysParseExact
          ? (h(this, '_weekdaysRegex') || ie.call(this),
            t ? this._weekdaysStrictRegex : this._weekdaysRegex)
          : (h(this, '_weekdaysRegex') || (this._weekdaysRegex = te),
            this._weekdaysStrictRegex && t
              ? this._weekdaysStrictRegex
              : this._weekdaysRegex)
      }),
      (Dn.weekdaysShortRegex = function (t) {
        return this._weekdaysParseExact
          ? (h(this, '_weekdaysRegex') || ie.call(this),
            t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
          : (h(this, '_weekdaysShortRegex') ||
                  (this._weekdaysShortRegex = ee),
            this._weekdaysShortStrictRegex && t
              ? this._weekdaysShortStrictRegex
              : this._weekdaysShortRegex)
      }),
      (Dn.weekdaysMinRegex = function (t) {
        return this._weekdaysParseExact
          ? (h(this, '_weekdaysRegex') || ie.call(this),
            t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
          : (h(this, '_weekdaysMinRegex') || (this._weekdaysMinRegex = ne),
            this._weekdaysMinStrictRegex && t
              ? this._weekdaysMinStrictRegex
              : this._weekdaysMinRegex)
      }),
      (Dn.isPM = function (t) {
        return (t + '').toLowerCase().charAt(0) === 'p'
      }),
      (Dn.meridiem = function (t, e, n) {
        return t > 11 ? (n ? 'pm' : 'PM') : n ? 'am' : 'AM'
      }),
      ge('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function (t) {
          const e = t % 10
          return (
            t +
                (k((t % 100) / 10) === 1
                  ? 'th'
                  : e === 1
                    ? 'st'
                    : e === 2
                      ? 'nd'
                      : e === 3
                        ? 'rd'
                        : 'th')
          )
        }
      }),
      (a.lang = D(
        'moment.lang is deprecated. Use moment.locale instead.',
        ge
      )),
      (a.langData = D(
        'moment.langData is deprecated. Use moment.localeData instead.',
        pe
      ))
      let On = Math.abs
      function An (t, e, n, i) {
        const a = Xe(e, n)
        return (
          (t._milliseconds += i * a._milliseconds),
          (t._days += i * a._days),
          (t._months += i * a._months),
          t._bubble()
        )
      }
      function Fn (t) {
        return t < 0 ? Math.floor(t) : Math.ceil(t)
      }
      function In (t) {
        return (4800 * t) / 146097
      }
      function Ln (t) {
        return (146097 * t) / 4800
      }
      function Rn (t) {
        return function () {
          return this.as(t)
        }
      }
      const Nn = Rn('ms')
      var Wn = Rn('s')
      var Yn = Rn('m')
      var zn = Rn('h')
      var En = Rn('d')
      var Vn = Rn('w')
      var Hn = Rn('M')
      var Bn = Rn('Q')
      var jn = Rn('y')
      function Un (t) {
        return function () {
          return this.isValid() ? this._data[t] : NaN
        }
      }
      const Gn = Un('milliseconds')
      var qn = Un('seconds')
      var Zn = Un('minutes')
      var $n = Un('hours')
      var Xn = Un('days')
      var Kn = Un('months')
      var Jn = Un('years')
      var Qn = Math.round
      var ti = { ss: 44, s: 45, m: 45, h: 22, d: 26, M: 11 }
      function ei (t, e, n, i, a) {
        return a.relativeTime(e || 1, !!n, t, i)
      }
      const ni = Math.abs
      function ii (t) {
        return (t > 0) - (t < 0) || +t
      }
      function ai () {
        if (!this.isValid()) return this.localeData().invalidDate()
        let t
        var e
        var n = ni(this._milliseconds) / 1e3
        var i = ni(this._days)
        var a = ni(this._months);
        (t = w(n / 60)), (e = w(t / 60)), (n %= 60), (t %= 60)
        let r = w(a / 12)
        var o = (a %= 12)
        var s = i
        var l = e
        var u = t
        var d = n ? n.toFixed(3).replace(/\.?0+$/, '') : ''
        var h = this.asSeconds()
        if (!h) return 'P0D'
        let c = h < 0 ? '-' : ''
          var f = ii(this._months) !== ii(h) ? '-' : ''
          var g = ii(this._days) !== ii(h) ? '-' : ''
          var m = ii(this._milliseconds) !== ii(h) ? '-' : ''
        return (
          c +
            'P' +
            (r ? f + r + 'Y' : '') +
            (o ? f + o + 'M' : '') +
            (s ? g + s + 'D' : '') +
            (l || u || d ? 'T' : '') +
            (l ? m + l + 'H' : '') +
            (u ? m + u + 'M' : '') +
            (d ? m + d + 'S' : '')
        )
      }
      const ri = ze.prototype
      return (
        (ri.isValid = function () {
          return this._isValid
        }),
        (ri.abs = function () {
          const t = this._data
          return (
            (this._milliseconds = On(this._milliseconds)),
            (this._days = On(this._days)),
            (this._months = On(this._months)),
            (t.milliseconds = On(t.milliseconds)),
            (t.seconds = On(t.seconds)),
            (t.minutes = On(t.minutes)),
            (t.hours = On(t.hours)),
            (t.months = On(t.months)),
            (t.years = On(t.years)),
            this
          )
        }),
        (ri.add = function (t, e) {
          return An(this, t, e, 1)
        }),
        (ri.subtract = function (t, e) {
          return An(this, t, e, -1)
        }),
        (ri.as = function (t) {
          if (!this.isValid()) return NaN
          let e
          var n
          var i = this._milliseconds
          if ((t = R(t)) === 'month' || t === 'quarter' || t === 'year') { switch (
            ((e = this._days + i / 864e5), (n = this._months + In(e)), t)
          ) {
            case 'month':
              return n
            case 'quarter':
              return n / 3
            case 'year':
              return n / 12
          } } else { switch (((e = this._days + Math.round(Ln(this._months))), t)) {
            case 'week':
              return e / 7 + i / 6048e5
            case 'day':
              return e + i / 864e5
            case 'hour':
              return 24 * e + i / 36e5
            case 'minute':
              return 1440 * e + i / 6e4
            case 'second':
              return 86400 * e + i / 1e3
            case 'millisecond':
              return Math.floor(864e5 * e) + i
            default:
              throw new Error('Unknown unit ' + t)
          } }
        }),
        (ri.asMilliseconds = Nn),
        (ri.asSeconds = Wn),
        (ri.asMinutes = Yn),
        (ri.asHours = zn),
        (ri.asDays = En),
        (ri.asWeeks = Vn),
        (ri.asMonths = Hn),
        (ri.asQuarters = Bn),
        (ri.asYears = jn),
        (ri.valueOf = function () {
          return this.isValid()
            ? this._milliseconds +
                  864e5 * this._days +
                  (this._months % 12) * 2592e6 +
                  31536e6 * k(this._months / 12)
            : NaN
        }),
        (ri._bubble = function () {
          let t
          var e
          var n
          var i
          var a
          var r = this._milliseconds
          var o = this._days
          var s = this._months
          var l = this._data
          return (
            (r >= 0 && o >= 0 && s >= 0) ||
                (r <= 0 && o <= 0 && s <= 0) ||
                ((r += 864e5 * Fn(Ln(s) + o)), (o = 0), (s = 0)),
            (l.milliseconds = r % 1e3),
            (t = w(r / 1e3)),
            (l.seconds = t % 60),
            (e = w(t / 60)),
            (l.minutes = e % 60),
            (n = w(e / 60)),
            (l.hours = n % 24),
            (o += w(n / 24)),
            (a = w(In(o))),
            (s += a),
            (o -= Fn(Ln(a))),
            (i = w(s / 12)),
            (s %= 12),
            (l.days = o),
            (l.months = s),
            (l.years = i),
            this
          )
        }),
        (ri.clone = function () {
          return Xe(this)
        }),
        (ri.get = function (t) {
          return (t = R(t)), this.isValid() ? this[t + 's']() : NaN
        }),
        (ri.milliseconds = Gn),
        (ri.seconds = qn),
        (ri.minutes = Zn),
        (ri.hours = $n),
        (ri.days = Xn),
        (ri.weeks = function () {
          return w(this.days() / 7)
        }),
        (ri.months = Kn),
        (ri.years = Jn),
        (ri.humanize = function (t) {
          if (!this.isValid()) return this.localeData().invalidDate()
          let e = this.localeData()
          var n = (function (t, e, n) {
            let i = Xe(t).abs()
            var a = Qn(i.as('s'))
            var r = Qn(i.as('m'))
            var o = Qn(i.as('h'))
            var s = Qn(i.as('d'))
            var l = Qn(i.as('M'))
            var u = Qn(i.as('y'))
            var d = (a <= ti.ss && ['s', a]) ||
                    (a < ti.s && ['ss', a]) ||
                    (r <= 1 && ['m']) ||
                    (r < ti.m && ['mm', r]) ||
                    (o <= 1 && ['h']) ||
                    (o < ti.h && ['hh', o]) ||
                    (s <= 1 && ['d']) ||
                    (s < ti.d && ['dd', s]) ||
                    (l <= 1 && ['M']) ||
                    (l < ti.M && ['MM', l]) ||
                    (u <= 1 && ['y']) || ['yy', u]
            return (
              (d[2] = e), (d[3] = +t > 0), (d[4] = n), ei.apply(null, d)
            )
          })(this, !t, e)
          return t && (n = e.pastFuture(+this, n)), e.postformat(n)
        }),
        (ri.toISOString = ai),
        (ri.toString = ai),
        (ri.toJSON = ai),
        (ri.locale = rn),
        (ri.localeData = sn),
        (ri.toIsoString = D(
          'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
          ai
        )),
        (ri.lang = on),
        j('X', 0, 0, 'unix'),
        j('x', 0, 0, 'valueOf'),
        dt('x', rt),
        dt('X', /[+-]?\d+(\.\d{1,3})?/),
        gt('X', function (t, e, n) {
          n._d = new Date(1e3 * parseFloat(t, 10))
        }),
        gt('x', function (t, e, n) {
          n._d = new Date(k(t))
        }),
        (a.version = '2.24.0'),
        (n = Le),
        (a.fn = Mn),
        (a.min = function () {
          return We('isBefore', [].slice.call(arguments, 0))
        }),
        (a.max = function () {
          return We('isAfter', [].slice.call(arguments, 0))
        }),
        (a.now = function () {
          return Date.now ? Date.now() : +new Date()
        }),
        (a.utc = f),
        (a.unix = function (t) {
          return Le(1e3 * t)
        }),
        (a.months = function (t, e) {
          return Pn(t, e, 'months')
        }),
        (a.isDate = u),
        (a.locale = ge),
        (a.invalid = p),
        (a.duration = Xe),
        (a.isMoment = _),
        (a.weekdays = function (t, e, n) {
          return Tn(t, e, n, 'weekdays')
        }),
        (a.parseZone = function () {
          return Le.apply(null, arguments).parseZone()
        }),
        (a.localeData = pe),
        (a.isDuration = Ee),
        (a.monthsShort = function (t, e) {
          return Pn(t, e, 'monthsShort')
        }),
        (a.weekdaysMin = function (t, e, n) {
          return Tn(t, e, n, 'weekdaysMin')
        }),
        (a.defineLocale = me),
        (a.updateLocale = function (t, e) {
          if (e != null) {
            let n
            var i
            var a = ue
            (i = fe(t)) != null && (a = i._config),
            (e = A(a, e)),
            ((n = new F(e)).parentLocale = de[t]),
            (de[t] = n),
            ge(t)
          } else
            {de[t] != null &&
                (de[t].parentLocale != null
                  ? (de[t] = de[t].parentLocale)
                  : de[t] != null && delete de[t])}
          return de[t]
        }),
        (a.locales = function () {
          return C(de)
        }),
        (a.weekdaysShort = function (t, e, n) {
          return Tn(t, e, n, 'weekdaysShort')
        }),
        (a.normalizeUnits = R),
        (a.relativeTimeRounding = function (t) {
          return void 0 === t ? Qn : typeof t === 'function' && ((Qn = t), !0)
        }),
        (a.relativeTimeThreshold = function (t, e) {
          return (
            void 0 !== ti[t] &&
              (void 0 === e
                ? ti[t]
                : ((ti[t] = e), t === 's' && (ti.ss = e - 1), !0))
          )
        }),
        (a.calendarFormat = function (t, e) {
          const n = t.diff(e, 'days', !0)
          return n < -6
            ? 'sameElse'
            : n < -1
              ? 'lastWeek'
              : n < 0
                ? 'lastDay'
                : n < 1
                  ? 'sameDay'
                  : n < 2
                    ? 'nextDay'
                    : n < 7
                      ? 'nextWeek'
                      : 'sameElse'
        }),
        (a.prototype = Mn),
        (a.HTML5_FMT = {
          DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
          DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
          DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
          DATE: 'YYYY-MM-DD',
          TIME: 'HH:mm',
          TIME_SECONDS: 'HH:mm:ss',
          TIME_MS: 'HH:mm:ss.SSS',
          WEEK: 'GGGG-[W]WW',
          MONTH: 'YYYY-MM'
        }),
        a
      )
    })()
  })
  let pi = {
    datetime: 'MMM D, YYYY, h:mm:ss a',
    millisecond: 'h:mm:ss.SSS a',
    second: 'h:mm:ss a',
    minute: 'h:mm a',
    hour: 'hA',
    day: 'MMM D',
    week: 'll',
    month: 'MMM YYYY',
    quarter: '[Q]Q - YYYY',
    year: 'YYYY'
  }
  on._date.override(
    typeof mi === 'function'
      ? {
          _id: 'moment',
          formats: function () {
            return pi
          },
          parse: function (t, e) {
            return (
              typeof t === 'string' && typeof e === 'string'
                ? (t = mi(t, e))
                : t instanceof mi || (t = mi(t)),
              t.isValid() ? t.valueOf() : null
            )
          },
          format: function (t, e) {
            return mi(t).format(e)
          },
          add: function (t, e, n) {
            return mi(t).add(e, n).valueOf()
          },
          diff: function (t, e, n) {
            return mi(t).diff(mi(e), n)
          },
          startOf: function (t, e, n) {
            return (
              (t = mi(t)),
              e === 'isoWeek'
                ? t.isoWeekday(n).valueOf()
                : t.startOf(e).valueOf()
            )
          },
          endOf: function (t, e) {
            return mi(t).endOf(e).valueOf()
          },
          _create: function (t) {
            return mi(t)
          }
        }
      : {}
  ),
  Y._set('global', { plugins: { filler: { propagate: !0 } } })
  const vi = {
    dataset: function (t) {
      const e = t.fill
      var n = t.chart
      var i = n.getDatasetMeta(e)
      var a = (i && n.isDatasetVisible(e) && i.dataset._children) || []
      var r = a.length || 0
      return r
        ? function (t, e) {
          return (e < r && a[e]._view) || null
        }
        : null
    },
    boundary: function (t) {
      const e = t.boundary
      var n = e ? e.x : null
      var i = e ? e.y : null
      return B.isArray(e)
        ? function (t, n) {
          return e[n]
        }
        : function (t) {
          return { x: n === null ? t.x : n, y: i === null ? t.y : i }
        }
    }
  }
  function bi (t, e, n) {
    let i
    let a = t._model || {}
    let r = a.fill
    if ((void 0 === r && (r = !!a.backgroundColor), !1 === r || r === null)) { return !1 }
    if (!0 === r) return 'origin'
    if (((i = parseFloat(r, 10)), isFinite(i) && Math.floor(i) === i)) {
      return (
        (r[0] !== '-' && r[0] !== '+') || (i = e + i),
        !(i === e || i < 0 || i >= n) && i
      ) 
}
    switch (r) {
      case 'bottom':
        return 'start'
      case 'top':
        return 'end'
      case 'zero':
        return 'origin'
      case 'origin':
      case 'start':
      case 'end':
        return r
      default:
        return !1
    }
  }
  function yi (t) {
    return (t.el._scale || {}).getPointPositionForValue
      ? (function (t) {
          let e
          let n
          let i
          let a
          let r
          let o = t.el._scale
          let s = o.options
          let l = o.chart.data.labels.length
          let u = t.fill
          let d = []
          if (!l) return null
          for (
            e = s.ticks.reverse ? o.max : o.min,
            n = s.ticks.reverse ? o.min : o.max,
            i = o.getPointPositionForValue(0, e),
            a = 0;
            a < l;
            ++a
          ) {
            (r =
              u === 'start' || u === 'end'
                ? o.getPointPositionForValue(a, u === 'start' ? e : n)
                : o.getBasePosition(a)),
            s.gridLines.circular &&
                ((r.cx = i.x),
                (r.cy = i.y),
                (r.angle = o.getIndexAngle(a) - Math.PI / 2)),
            d.push(r) 
}
          return d
        })(t)
      : (function (t) {
          let e
          let n = t.el._model || {}
          let i = t.el._scale || {}
          let a = t.fill
          let r = null
          if (isFinite(a)) return null
          if (
            (a === 'start'
              ? (r = void 0 === n.scaleBottom ? i.bottom : n.scaleBottom)
              : a === 'end'
                ? (r = void 0 === n.scaleTop ? i.top : n.scaleTop)
                : void 0 !== n.scaleZero
                  ? (r = n.scaleZero)
                  : i.getBasePixel && (r = i.getBasePixel()),
            r != null)
          ) {
            if (void 0 !== r.x && void 0 !== r.y) return r
            if (B.isFinite(r)) { return { x: (e = i.isHorizontal()) ? r : null, y: e ? null : r } }
          }
          return null
        })(t)
  }
  function xi (t, e, n) {
    let i
    let a = t[e].fill
    let r = [e]
    if (!n) return a
    for (; !1 !== a && r.indexOf(a) === -1;) {
      if (!isFinite(a)) return a
      if (!(i = t[a])) return !1
      if (i.visible) return a
      r.push(a), (a = i.fill)
    }
    return !1
  }
  function _i (t) {
    const e = t.fill
    let n = 'dataset'
    return !1 === e ? null : (isFinite(e) || (n = 'boundary'), vi[n](t))
  }
  function wi (t) {
    return t && !t.skip
  }
  function ki (t, e, n, i, a) {
    let r, o, s, l
    if (i && a) {
      for (t.moveTo(e[0].x, e[0].y), r = 1; r < i; ++r) { B.canvas.lineTo(t, e[r - 1], e[r]) }
      if (void 0 === n[0].angle) {
        for (t.lineTo(n[a - 1].x, n[a - 1].y), r = a - 1; r > 0; --r) { B.canvas.lineTo(t, n[r], n[r - 1], !0) } } else {
        for (
          o = n[0].cx,
          s = n[0].cy,
          l = Math.sqrt(Math.pow(n[0].x - o, 2) + Math.pow(n[0].y - s, 2)),
          r = a - 1;
          r > 0;
          --r
        ) { t.arc(o, s, l, n[r].angle, n[r - 1].angle, !0) } }
    }
  }
  function Mi (t, e, n, i, a, r) {
    let o
    let s
    let l
    let u
    let d
    let h
    let c
    let f
    let g = e.length
    let m = i.spanGaps
    let p = []
    let v = []
    let b = 0
    let y = 0
    for (t.beginPath(), o = 0, s = g; o < s; ++o) {
      (d = n((u = e[(l = o % g)]._view), l, i)),
      (h = wi(u)),
      (c = wi(d)),
      r && void 0 === f && h && (s = g + (f = o + 1)),
      h && c
        ? ((b = p.push(u)), (y = v.push(d)))
        : b &&
            y &&
            (m
              ? (h && p.push(u), c && v.push(d))
              : (ki(t, p, v, b, y), (b = y = 0), (p = []), (v = []))) 
}
    ki(t, p, v, b, y), t.closePath(), (t.fillStyle = a), t.fill()
  }
  const Si = {
    id: 'filler',
    afterDatasetsUpdate: function (t, e) {
      let n
      var i
      var a
      var r
      var o = (t.data.datasets || []).length
      var s = e.propagate
      var l = []
      for (i = 0; i < o; ++i) {
 (r = null),
      (a = (n = t.getDatasetMeta(i)).dataset) &&
              a._model &&
              a instanceof kt.Line &&
              (r = {
                visible: t.isDatasetVisible(i),
                fill: bi(a, i, o),
                chart: t,
                el: a
              }),
      (n.$filler = r),
      l.push(r) }
      for (i = 0; i < o; ++i) {
 (r = l[i]) &&
            ((r.fill = xi(l, i, s)), (r.boundary = yi(r)), (r.mapper = _i(r))) }
    },
    beforeDatasetsDraw: function (t) {
      let e
      var n
      var i
      var a
      var r
      var o
      var s
      var l = t._getSortedVisibleDatasetMetas()
      var u = t.ctx
      for (n = l.length - 1; n >= 0; --n) {
 (e = l[n].$filler) &&
            e.visible &&
            ((a = (i = e.el)._view),
            (r = i._children || []),
            (o = e.mapper),
            (s = a.backgroundColor || Y.global.defaultColor),
            o &&
              s &&
              r.length &&
              (B.canvas.clipArea(u, t.chartArea),
              Mi(u, r, o, a, s, i._loop),
              B.canvas.unclipArea(u))) }
    }
  }
  let Di = B.rtl.getRtlAdapter
  let Ci = B.noop
  let Pi = B.valueOrDefault
  function Ti (t, e) {
    return t.usePointStyle && t.boxWidth > e ? e : t.boxWidth
  }
  Y._set('global', {
    legend: {
      display: !0,
      position: 'top',
      align: 'center',
      fullWidth: !0,
      reverse: !1,
      weight: 1e3,
      onClick: function (t, e) {
        const n = e.datasetIndex
        let i = this.chart
        let a = i.getDatasetMeta(n);
        (a.hidden = a.hidden === null ? !i.data.datasets[n].hidden : null),
        i.update()
      },
      onHover: null,
      onLeave: null,
      labels: {
        boxWidth: 40,
        padding: 10,
        generateLabels: function (t) {
          const e = t.data.datasets
          let n = t.options.legend || {}
          let i = n.labels && n.labels.usePointStyle
          return t._getSortedDatasetMetas().map(function (n) {
            const a = n.controller.getStyle(i ? 0 : void 0)
            return {
              text: e[n.index].label,
              fillStyle: a.backgroundColor,
              hidden: !t.isDatasetVisible(n.index),
              lineCap: a.borderCapStyle,
              lineDash: a.borderDash,
              lineDashOffset: a.borderDashOffset,
              lineJoin: a.borderJoinStyle,
              lineWidth: a.borderWidth,
              strokeStyle: a.borderColor,
              pointStyle: a.pointStyle,
              rotation: a.rotation,
              datasetIndex: n.index
            }
          }, this)
        }
      }
    },
    legendCallback: function (t) {
      let e
      let n
      let i
      let a = document.createElement('ul')
      let r = t.data.datasets
      for (
        a.setAttribute('class', t.id + '-legend'), e = 0, n = r.length;
        e < n;
        e++
      ) {
        ((i = a.appendChild(document.createElement('li'))).appendChild(
          document.createElement('span')
        ).style.backgroundColor = r[e].backgroundColor),
        r[e].label && i.appendChild(document.createTextNode(r[e].label)) 
}
      return a.outerHTML
    }
  })
  const Oi = X.extend({
    initialize: function (t) {
      B.extend(this, t),
      (this.legendHitBoxes = []),
      (this._hoveredItem = null),
      (this.doughnutMode = !1)
    },
    beforeUpdate: Ci,
    update: function (t, e, n) {
      const i = this
      return (
        i.beforeUpdate(),
        (i.maxWidth = t),
        (i.maxHeight = e),
        (i.margins = n),
        i.beforeSetDimensions(),
        i.setDimensions(),
        i.afterSetDimensions(),
        i.beforeBuildLabels(),
        i.buildLabels(),
        i.afterBuildLabels(),
        i.beforeFit(),
        i.fit(),
        i.afterFit(),
        i.afterUpdate(),
        i.minSize
      )
    },
    afterUpdate: Ci,
    beforeSetDimensions: Ci,
    setDimensions: function () {
      const t = this
      t.isHorizontal()
        ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
        : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
      (t.paddingLeft = 0),
      (t.paddingTop = 0),
      (t.paddingRight = 0),
      (t.paddingBottom = 0),
      (t.minSize = { width: 0, height: 0 })
    },
    afterSetDimensions: Ci,
    beforeBuildLabels: Ci,
    buildLabels: function () {
      const t = this
      var e = t.options.labels || {}
      var n = B.callback(e.generateLabels, [t.chart], t) || []
      e.filter &&
        (n = n.filter(function (n) {
          return e.filter(n, t.chart.data)
        })),
      t.options.reverse && n.reverse(),
      (t.legendItems = n)
    },
    afterBuildLabels: Ci,
    beforeFit: Ci,
    fit: function () {
      const t = this
      var e = t.options
      var n = e.labels
      var i = e.display
      var a = t.ctx
      var r = B.options._parseFont(n)
      var o = r.size
      var s = (t.legendHitBoxes = [])
      var l = t.minSize
      var u = t.isHorizontal()
      if (
        (u
          ? ((l.width = t.maxWidth), (l.height = i ? 10 : 0))
          : ((l.width = i ? 10 : 0), (l.height = t.maxHeight)),
        i)
      ) {
        if (((a.font = r.string), u)) {
          const d = (t.lineWidths = [0])
          var h = 0;
          (a.textAlign = 'left'),
          (a.textBaseline = 'middle'),
          B.each(t.legendItems, function (t, e) {
            const i = Ti(n, o) + o / 2 + a.measureText(t.text).width;
            (e === 0 || d[d.length - 1] + i + 2 * n.padding > l.width) &&
                ((h += o + n.padding), (d[d.length - (e > 0 ? 0 : 1)] = 0)),
            (s[e] = { left: 0, top: 0, width: i, height: o }),
            (d[d.length - 1] += i + n.padding)
          }),
          (l.height += h)
        } else {
          const c = n.padding
          var f = (t.columnWidths = [])
          var g = (t.columnHeights = [])
          var m = n.padding
          var p = 0
          var v = 0
          B.each(t.legendItems, function (t, e) {
            const i = Ti(n, o) + o / 2 + a.measureText(t.text).width
            e > 0 &&
              v + o + 2 * c > l.height &&
              ((m += p + n.padding), f.push(p), g.push(v), (p = 0), (v = 0)),
            (p = Math.max(p, i)),
            (v += o + c),
            (s[e] = { left: 0, top: 0, width: i, height: o })
          }),
          (m += p),
          f.push(p),
          g.push(v),
          (l.width += m)
        }
        (t.width = l.width), (t.height = l.height)
      } else t.width = l.width = t.height = l.height = 0
    },
    afterFit: Ci,
    isHorizontal: function () {
      return (
        this.options.position === 'top' || this.options.position === 'bottom'
      )
    },
    draw: function () {
      const t = this
      var e = t.options
      var n = e.labels
      var i = Y.global
      var a = i.defaultColor
      var r = i.elements.line
      var o = t.height
      var s = t.columnHeights
      var l = t.width
      var u = t.lineWidths
      if (e.display) {
        let d
        var h = Di(e.rtl, t.left, t.minSize.width)
        var c = t.ctx
        var f = Pi(n.fontColor, i.defaultFontColor)
        var g = B.options._parseFont(n)
        var m = g.size;
        (c.textAlign = h.textAlign('left')),
        (c.textBaseline = 'middle'),
        (c.lineWidth = 0.5),
        (c.strokeStyle = f),
        (c.fillStyle = f),
        (c.font = g.string)
        const p = Ti(n, m)
        var v = t.legendHitBoxes
        var b = function (t, i) {
          switch (e.align) {
            case 'start':
              return n.padding
            case 'end':
              return t - i
            default:
              return (t - i + n.padding) / 2
          }
        }
        var y = t.isHorizontal();
        (d = y
          ? { x: t.left + b(l, u[0]), y: t.top + n.padding, line: 0 }
          : { x: t.left + n.padding, y: t.top + b(o, s[0]), line: 0 }),
        B.rtl.overrideTextDirection(t.ctx, e.textDirection)
        const x = m + n.padding
        B.each(t.legendItems, function (e, i) {
          const f = c.measureText(e.text).width
          var g = p + m / 2 + f
          var _ = d.x
          var w = d.y
          h.setWidth(t.minSize.width),
          y
            ? i > 0 &&
                _ + g + n.padding > t.left + t.minSize.width &&
                ((w = d.y += x), d.line++, (_ = d.x = t.left + b(l, u[d.line])))
            : i > 0 &&
                w + x > t.top + t.minSize.height &&
                ((_ = d.x = _ + t.columnWidths[d.line] + n.padding),
                d.line++,
                (w = d.y = t.top + b(o, s[d.line])))
          const k = h.x(_)
          !(function (t, e, i) {
            if (!(isNaN(p) || p <= 0)) {
              c.save()
              const o = Pi(i.lineWidth, r.borderWidth)
              if (
                ((c.fillStyle = Pi(i.fillStyle, a)),
                (c.lineCap = Pi(i.lineCap, r.borderCapStyle)),
                (c.lineDashOffset = Pi(i.lineDashOffset, r.borderDashOffset)),
                (c.lineJoin = Pi(i.lineJoin, r.borderJoinStyle)),
                (c.lineWidth = o),
                (c.strokeStyle = Pi(i.strokeStyle, a)),
                c.setLineDash && c.setLineDash(Pi(i.lineDash, r.borderDash)),
                n && n.usePointStyle)
              ) {
                const s = (p * Math.SQRT2) / 2
                var l = h.xPlus(t, p / 2)
                var u = e + m / 2
                B.canvas.drawPoint(c, i.pointStyle, s, l, u, i.rotation)
              } else {
 c.fillRect(h.leftForLtr(t, p), e, p, m),
              o !== 0 && c.strokeRect(h.leftForLtr(t, p), e, p, m) }
              c.restore()
            }
          })(k, w, e),
          (v[i].left = h.leftForLtr(k, v[i].width)),
          (v[i].top = w),
          (function (t, e, n, i) {
            const a = m / 2
            var r = h.xPlus(t, p + a)
            var o = e + a
            c.fillText(n.text, r, o),
            n.hidden &&
                  (c.beginPath(),
                  (c.lineWidth = 2),
                  c.moveTo(r, o),
                  c.lineTo(h.xPlus(r, i), o),
                  c.stroke())
          })(k, w, e, f),
          y ? (d.x += g + n.padding) : (d.y += x)
        }),
        B.rtl.restoreTextDirection(t.ctx, e.textDirection)
      }
    },
    _getLegendItemAt: function (t, e) {
      let n
      var i
      var a
      var r = this
      if (t >= r.left && t <= r.right && e >= r.top && e <= r.bottom) {
 for (a = r.legendHitBoxes, n = 0; n < a.length; ++n)
        {if (
          t >= (i = a[n]).left &&
            t <= i.left + i.width &&
            e >= i.top &&
            e <= i.top + i.height
        )
          return r.legendItems[n]}}
      return null
    },
    handleEvent: function (t) {
      let e
      var n = this
      var i = n.options
      var a = t.type === 'mouseup' ? 'click' : t.type
      if (a === 'mousemove') {
        if (!i.onHover && !i.onLeave) return
      } else {
        if (a !== 'click') return
        if (!i.onClick) return
      }
      (e = n._getLegendItemAt(t.x, t.y)),
      a === 'click'
        ? e && i.onClick && i.onClick.call(n, t.native, e)
        : (i.onLeave &&
              e !== n._hoveredItem &&
              (n._hoveredItem && i.onLeave.call(n, t.native, n._hoveredItem),
              (n._hoveredItem = e)),
          i.onHover && e && i.onHover.call(n, t.native, e))
    }
  })
  function Ai (t, e) {
    const n = new Oi({ ctx: t.ctx, options: e, chart: t })
    pe.configure(t, n, e), pe.addBox(t, n), (t.legend = n)
  }
  const Fi = {
    id: 'legend',
    _element: Oi,
    beforeInit: function (t) {
      const e = t.options.legend
      e && Ai(t, e)
    },
    beforeUpdate: function (t) {
      const e = t.options.legend
      var n = t.legend
      e
        ? (B.mergeIf(e, Y.global.legend),
          n ? (pe.configure(t, n, e), (n.options = e)) : Ai(t, e))
        : n && (pe.removeBox(t, n), delete t.legend)
    },
    afterEvent: function (t, e) {
      const n = t.legend
      n && n.handleEvent(e)
    }
  }
  let Ii = B.noop
  Y._set('global', {
    title: {
      display: !1,
      fontStyle: 'bold',
      fullWidth: !0,
      padding: 10,
      position: 'top',
      text: '',
      weight: 2e3
    }
  })
  const Li = X.extend({
    initialize: function (t) {
      B.extend(this, t), (this.legendHitBoxes = [])
    },
    beforeUpdate: Ii,
    update: function (t, e, n) {
      const i = this
      return (
        i.beforeUpdate(),
        (i.maxWidth = t),
        (i.maxHeight = e),
        (i.margins = n),
        i.beforeSetDimensions(),
        i.setDimensions(),
        i.afterSetDimensions(),
        i.beforeBuildLabels(),
        i.buildLabels(),
        i.afterBuildLabels(),
        i.beforeFit(),
        i.fit(),
        i.afterFit(),
        i.afterUpdate(),
        i.minSize
      )
    },
    afterUpdate: Ii,
    beforeSetDimensions: Ii,
    setDimensions: function () {
      const t = this
      t.isHorizontal()
        ? ((t.width = t.maxWidth), (t.left = 0), (t.right = t.width))
        : ((t.height = t.maxHeight), (t.top = 0), (t.bottom = t.height)),
      (t.paddingLeft = 0),
      (t.paddingTop = 0),
      (t.paddingRight = 0),
      (t.paddingBottom = 0),
      (t.minSize = { width: 0, height: 0 })
    },
    afterSetDimensions: Ii,
    beforeBuildLabels: Ii,
    buildLabels: Ii,
    afterBuildLabels: Ii,
    beforeFit: Ii,
    fit: function () {
      let t
      var e = this
      var n = e.options
      var i = (e.minSize = {})
      var a = e.isHorizontal()
      n.display
        ? ((t =
            (B.isArray(n.text) ? n.text.length : 1) *
              B.options._parseFont(n).lineHeight +
            2 * n.padding),
          (e.width = i.width = a ? e.maxWidth : t),
          (e.height = i.height = a ? t : e.maxHeight))
        : (e.width = i.width = e.height = i.height = 0)
    },
    afterFit: Ii,
    isHorizontal: function () {
      const t = this.options.position
      return t === 'top' || t === 'bottom'
    },
    draw: function () {
      const t = this
      var e = t.ctx
      var n = t.options
      if (n.display) {
        let i
        var a
        var r
        var o = B.options._parseFont(n)
        var s = o.lineHeight
        var l = s / 2 + n.padding
        var u = 0
        var d = t.top
        var h = t.left
        var c = t.bottom
        var f = t.right;
        (e.fillStyle = B.valueOrDefault(
          n.fontColor,
          Y.global.defaultFontColor
        )),
        (e.font = o.string),
        t.isHorizontal()
          ? ((a = h + (f - h) / 2), (r = d + l), (i = f - h))
          : ((a = n.position === 'left' ? h + l : f - l),
            (r = d + (c - d) / 2),
            (i = c - d),
            (u = Math.PI * (n.position === 'left' ? -0.5 : 0.5))),
        e.save(),
        e.translate(a, r),
        e.rotate(u),
        (e.textAlign = 'center'),
        (e.textBaseline = 'middle')
        const g = n.text
        if (B.isArray(g)) {
 for (let m = 0, p = 0; p < g.length; ++p)
          {e.fillText(g[p], 0, m, i), (m += s)}} else e.fillText(g, 0, 0, i)
        e.restore()
      }
    }
  })
  function Ri (t, e) {
    const n = new Li({ ctx: t.ctx, options: e, chart: t })
    pe.configure(t, n, e), pe.addBox(t, n), (t.titleBlock = n)
  }
  const Ni = {}
  let Wi = Si
  let Yi = Fi
  let zi = {
    id: 'title',
    _element: Li,
    beforeInit: function (t) {
      const e = t.options.title
      e && Ri(t, e)
    },
    beforeUpdate: function (t) {
      const e = t.options.title
      let n = t.titleBlock
      e
        ? (B.mergeIf(e, Y.global.title),
          n ? (pe.configure(t, n, e), (n.options = e)) : Ri(t, e))
        : n && (pe.removeBox(t, n), delete t.titleBlock)
    }
  }
  for (const Ei in ((Ni.filler = Wi),
  (Ni.legend = Yi),
  (Ni.title = zi),
  (nn.helpers = B),
  (function () {
    function t (t, e, n) {
      let i
      return (
        typeof t === 'string'
          ? ((i = parseInt(t, 10)),
            t.indexOf('%') !== -1 && (i = (i / 100) * e.parentNode[n]))
          : (i = t),
        i
      )
    }
    function e (t) {
      return t != null && t !== 'none'
    }
    function n (n, i, a) {
      const r = document.defaultView
      let o = B._getParentNode(n)
      let s = r.getComputedStyle(n)[i]
      let l = r.getComputedStyle(o)[i]
      let u = e(s)
      let d = e(l)
      let h = Number.POSITIVE_INFINITY
      return u || d ? Math.min(u ? t(s, n, a) : h, d ? t(l, o, a) : h) : 'none'
    }
    (B.where = function (t, e) {
      if (B.isArray(t) && Array.prototype.filter) return t.filter(e)
      const n = []
      return (
        B.each(t, function (t) {
          e(t) && n.push(t)
        }),
        n
      )
    }),
    (B.findIndex = Array.prototype.findIndex
      ? function (t, e, n) {
        return t.findIndex(e, n)
      }
      : function (t, e, n) {
        n = void 0 === n ? t : n
        for (let i = 0, a = t.length; i < a; ++i) { if (e.call(n, t[i], i, t)) return i }
        return -1
      }),
    (B.findNextWhere = function (t, e, n) {
      B.isNullOrUndef(n) && (n = -1)
      for (let i = n + 1; i < t.length; i++) {
        const a = t[i]
        if (e(a)) return a
      }
    }),
    (B.findPreviousWhere = function (t, e, n) {
      B.isNullOrUndef(n) && (n = t.length)
      for (let i = n - 1; i >= 0; i--) {
        const a = t[i]
        if (e(a)) return a
      }
    }),
    (B.isNumber = function (t) {
      return !isNaN(parseFloat(t)) && isFinite(t)
    }),
    (B.almostEquals = function (t, e, n) {
      return Math.abs(t - e) < n
    }),
    (B.almostWhole = function (t, e) {
      const n = Math.round(t)
      return n - e <= t && n + e >= t
    }),
    (B.max = function (t) {
      return t.reduce(function (t, e) {
        return isNaN(e) ? t : Math.max(t, e)
      }, Number.NEGATIVE_INFINITY)
    }),
    (B.min = function (t) {
      return t.reduce(function (t, e) {
        return isNaN(e) ? t : Math.min(t, e)
      }, Number.POSITIVE_INFINITY)
    }),
    (B.sign = Math.sign
      ? function (t) {
        return Math.sign(t)
      }
      : function (t) {
        return (t = +t) === 0 || isNaN(t) ? t : t > 0 ? 1 : -1
      }),
    (B.toRadians = function (t) {
      return t * (Math.PI / 180)
    }),
    (B.toDegrees = function (t) {
      return t * (180 / Math.PI)
    }),
    (B._decimalPlaces = function (t) {
      if (B.isFinite(t)) {
        for (var e = 1, n = 0; Math.round(t * e) / e !== t;) (e *= 10), n++
        return n
      }
    }),
    (B.getAngleFromPoint = function (t, e) {
      const n = e.x - t.x
      let i = e.y - t.y
      let a = Math.sqrt(n * n + i * i)
      let r = Math.atan2(i, n)
      return (
        r < -0.5 * Math.PI && (r += 2 * Math.PI), { angle: r, distance: a }
      )
    }),
    (B.distanceBetweenPoints = function (t, e) {
      return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
    }),
    (B.aliasPixel = function (t) {
      return t % 2 == 0 ? 0 : 0.5
    }),
    (B._alignPixel = function (t, e, n) {
      const i = t.currentDevicePixelRatio
      let a = n / 2
      return Math.round((e - a) * i) / i + a
    }),
    (B.splineCurve = function (t, e, n, i) {
      const a = t.skip ? e : t
      let r = e
      let o = n.skip ? e : n
      let s = Math.sqrt(Math.pow(r.x - a.x, 2) + Math.pow(r.y - a.y, 2))
      let l = Math.sqrt(Math.pow(o.x - r.x, 2) + Math.pow(o.y - r.y, 2))
      let u = s / (s + l)
      let d = l / (s + l)
      let h = i * (u = isNaN(u) ? 0 : u)
      let c = i * (d = isNaN(d) ? 0 : d)
      return {
        previous: { x: r.x - h * (o.x - a.x), y: r.y - h * (o.y - a.y) },
        next: { x: r.x + c * (o.x - a.x), y: r.y + c * (o.y - a.y) }
      }
    }),
    (B.EPSILON = Number.EPSILON || 1e-14),
    (B.splineCurveMonotone = function (t) {
      let e
      let n
      let i
      let a
      let r
      let o
      let s
      let l
      let u
      let d = (t || []).map(function (t) {
        return { model: t._model, deltaK: 0, mK: 0 }
      })
      let h = d.length
      for (e = 0; e < h; ++e) {
 if (!(i = d[e]).model.skip) {
        if (
          ((n = e > 0 ? d[e - 1] : null),
          (a = e < h - 1 ? d[e + 1] : null) && !a.model.skip)
        ) {
          let c = a.model.x - i.model.x
          i.deltaK = c !== 0 ? (a.model.y - i.model.y) / c : 0
        }
        !n || n.model.skip
          ? (i.mK = i.deltaK)
          : !a || a.model.skip
              ? (i.mK = n.deltaK)
              : this.sign(n.deltaK) !== this.sign(i.deltaK)
                ? (i.mK = 0)
                : (i.mK = (n.deltaK + i.deltaK) / 2)
      } 
}
      for (e = 0; e < h - 1; ++e) {
 (i = d[e]),
      (a = d[e + 1]),
      i.model.skip ||
              a.model.skip ||
              (B.almostEquals(i.deltaK, 0, this.EPSILON)
                ? (i.mK = a.mK = 0)
                : ((r = i.mK / i.deltaK),
                  (o = a.mK / i.deltaK),
                  (l = Math.pow(r, 2) + Math.pow(o, 2)) <= 9 ||
                    ((s = 3 / Math.sqrt(l)),
                    (i.mK = r * s * i.deltaK),
                    (a.mK = o * s * i.deltaK)))) 
}
      for (e = 0; e < h; ++e) {
 (i = d[e]).model.skip ||
            ((n = e > 0 ? d[e - 1] : null),
            (a = e < h - 1 ? d[e + 1] : null),
            n &&
              !n.model.skip &&
              ((u = (i.model.x - n.model.x) / 3),
              (i.model.controlPointPreviousX = i.model.x - u),
              (i.model.controlPointPreviousY = i.model.y - u * i.mK)),
            a &&
              !a.model.skip &&
              ((u = (a.model.x - i.model.x) / 3),
              (i.model.controlPointNextX = i.model.x + u),
              (i.model.controlPointNextY = i.model.y + u * i.mK))) 
}
    }),
    (B.nextItem = function (t, e, n) {
      return n
        ? e >= t.length - 1
          ? t[0]
          : t[e + 1]
        : e >= t.length - 1
          ? t[t.length - 1]
          : t[e + 1]
    }),
    (B.previousItem = function (t, e, n) {
      return n
        ? e <= 0
          ? t[t.length - 1]
          : t[e - 1]
        : e <= 0
          ? t[0]
          : t[e - 1]
    }),
    (B.niceNum = function (t, e) {
      const n = Math.floor(B.log10(t))
      let i = t / Math.pow(10, n)
      return (
        (e
          ? i < 1.5
            ? 1
            : i < 3
              ? 2
              : i < 7
                ? 5
                : 10
          : i <= 1
            ? 1
            : i <= 2
              ? 2
              : i <= 5
                ? 5
                : 10) * Math.pow(10, n)
      )
    }),
    (B.requestAnimFrame =
        typeof window === 'undefined'
          ? function (t) {
            t()
          }
          : window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (t) {
              return window.setTimeout(t, 1e3 / 60)
            }),
    (B.getRelativePosition = function (t, e) {
      let n
      let i
      let a = t.originalEvent || t
      let r = t.target || t.srcElement
      let o = r.getBoundingClientRect()
      let s = a.touches
      s && s.length > 0
        ? ((n = s[0].clientX), (i = s[0].clientY))
        : ((n = a.clientX), (i = a.clientY))
      const l = parseFloat(B.getStyle(r, 'padding-left'))
      let u = parseFloat(B.getStyle(r, 'padding-top'))
      let d = parseFloat(B.getStyle(r, 'padding-right'))
      let h = parseFloat(B.getStyle(r, 'padding-bottom'))
      let c = o.right - o.left - l - d
      let f = o.bottom - o.top - u - h
      return {
        x: (n = Math.round(
          (((n - o.left - l) / c) * r.width) / e.currentDevicePixelRatio
        )),
        y: (i = Math.round(
          (((i - o.top - u) / f) * r.height) / e.currentDevicePixelRatio
        ))
      }
    }),
    (B.getConstraintWidth = function (t) {
      return n(t, 'max-width', 'clientWidth')
    }),
    (B.getConstraintHeight = function (t) {
      return n(t, 'max-height', 'clientHeight')
    }),
    (B._calculatePadding = function (t, e, n) {
      return (e = B.getStyle(t, e)).indexOf('%') > -1
        ? (n * parseInt(e, 10)) / 100
        : parseInt(e, 10)
    }),
    (B._getParentNode = function (t) {
      let e = t.parentNode
      return e && e.toString() === '[object ShadowRoot]' && (e = e.host), e
    }),
    (B.getMaximumWidth = function (t) {
      const e = B._getParentNode(t)
      if (!e) return t.clientWidth
      const n = e.clientWidth
      let i =
            n -
            B._calculatePadding(e, 'padding-left', n) -
            B._calculatePadding(e, 'padding-right', n)
      let a = B.getConstraintWidth(t)
      return isNaN(a) ? i : Math.min(i, a)
    }),
    (B.getMaximumHeight = function (t) {
      const e = B._getParentNode(t)
      if (!e) return t.clientHeight
      const n = e.clientHeight
      let i =
            n -
            B._calculatePadding(e, 'padding-top', n) -
            B._calculatePadding(e, 'padding-bottom', n)
      let a = B.getConstraintHeight(t)
      return isNaN(a) ? i : Math.min(i, a)
    }),
    (B.getStyle = function (t, e) {
      return t.currentStyle
        ? t.currentStyle[e]
        : document.defaultView.getComputedStyle(t, null).getPropertyValue(e)
    }),
    (B.retinaScale = function (t, e) {
      const n = (t.currentDevicePixelRatio =
          e || (typeof window !== 'undefined' && window.devicePixelRatio) || 1)
      if (n !== 1) {
        const i = t.canvas
        let a = t.height
        let r = t.width;
        (i.height = a * n),
        (i.width = r * n),
        t.ctx.scale(n, n),
        i.style.height ||
              i.style.width ||
              ((i.style.height = a + 'px'), (i.style.width = r + 'px'))
      }
    }),
    (B.fontString = function (t, e, n) {
      return e + ' ' + t + 'px ' + n
    }),
    (B.longestText = function (t, e, n, i) {
      let a = ((i = i || {}).data = i.data || {})
      let r = (i.garbageCollect = i.garbageCollect || [])
      i.font !== e &&
          ((a = i.data = {}), (r = i.garbageCollect = []), (i.font = e)),
      (t.font = e)
      let o
      let s
      let l
      let u
      let d
      let h = 0
      let c = n.length
      for (o = 0; o < c; o++) {
 if ((u = n[o]) != null && !0 !== B.isArray(u))
        {h = B.measureText(t, a, r, h, u)}
      else if (B.isArray(u))
        {for (s = 0, l = u.length; s < l; s++)
          null == (d = u[s]) ||
                B.isArray(d) ||
                (h = B.measureText(t, a, r, h, d))} 
}
      const f = r.length / 2
      if (f > n.length) {
        for (o = 0; o < f; o++) delete a[r[o]]
        r.splice(0, f)
      }
      return h
    }),
    (B.measureText = function (t, e, n, i, a) {
      let r = e[a]
      return (
        r || ((r = e[a] = t.measureText(a).width), n.push(a)),
        r > i && (i = r),
        i
      )
    }),
    (B.numberOfLabelLines = function (t) {
      let e = 1
      return (
        B.each(t, function (t) {
          B.isArray(t) && t.length > e && (e = t.length)
        }),
        e
      )
    }),
    (B.color = w
      ? function (t) {
        return (
          t instanceof CanvasGradient && (t = Y.global.defaultColor), w(t)
        )
      }
      : function (t) {
        return console.error('Color.js not found!'), t
      }),
    (B.getHoverColor = function (t) {
      return t instanceof CanvasPattern || t instanceof CanvasGradient
        ? t
        : B.color(t).saturate(0.5).darken(0.1).rgbString()
    })
  })(),
  (nn._adapters = on),
  (nn.Animation = J),
  (nn.animationService = Q),
  (nn.controllers = Qt),
  (nn.DatasetController = at),
  (nn.defaults = Y),
  (nn.Element = X),
  (nn.elements = kt),
  (nn.Interaction = oe),
  (nn.layouts = pe),
  (nn.platform = Le),
  (nn.plugins = Re),
  (nn.Scale = _n),
  (nn.scaleService = Ne),
  (nn.Ticks = sn),
  (nn.Tooltip = qe),
  nn.helpers.each(gi, function (t, e) {
    nn.scaleService.registerScaleType(e, t, t._defaults)
  }),
  Ni)) { Ni.hasOwnProperty(Ei) && nn.plugins.register(Ni[Ei]) }
  nn.platform.initialize()
  const Vi = nn
  return (
    typeof window !== 'undefined' && (window.Chart = nn),
    (nn.Chart = nn),
    (nn.Legend = Ni.legend._element),
    (nn.Title = Ni.title._element),
    (nn.pluginService = nn.plugins),
    (nn.PluginBase = nn.Element.extend({})),
    (nn.canvasHelpers = nn.helpers.canvas),
    (nn.layoutService = nn.layouts),
    (nn.LinearScaleBase = Cn),
    nn.helpers.each(
      ['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'],
      function (t) {
        nn[t] = function (e, n) {
          return new nn(
            e,
            nn.helpers.merge(n || {}, {
              type: t.charAt(0).toLowerCase() + t.slice(1)
            })
          )
        }
      }
    ),
    Vi
  )
})
